{"/home/travis/build/npmtest/node-npmtest-node-red/test.js":"/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/lib.npmtest_node_red.js":"/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_red = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_red = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-red && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_red\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_red.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_red.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_red.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_red.__dirname + '/lib.npmtest_node_red.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/red.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require(\"fs\");\nvar path = require('path');\n\nvar runtime = require(\"./runtime\");\nvar api = require(\"./api\");\n\nprocess.env.NODE_RED_HOME = process.env.NODE_RED_HOME || path.resolve(__dirname+\"/..\");\n\nvar nodeApp = null;\nvar adminApp = null;\nvar server = null;\nvar apiEnabled = false;\n\nfunction checkVersion(userSettings) {\n    var semver = require('semver');\n    if (!semver.satisfies(process.version,\">=4.0.0\")) {\n        // TODO: in the future, make this a hard error.\n        // var e = new Error(\"Unsupported version of node.js\");\n        // e.code = \"unsupported_version\";\n        // throw e;\n        userSettings.UNSUPPORTED_VERSION = process.version;\n    }\n}\n\nfunction checkBuild() {\n    var editorFile = path.resolve(path.join(__dirname,\"..\",\"public\",\"red\",\"red.min.js\"));\n    try {\n        var stats = fs.statSync(editorFile);\n    } catch(err) {\n        var e = new Error(\"Node-RED not built\");\n        e.code = \"not_built\";\n        throw e;\n    }\n}\n\nmodule.exports = {\n    init: function(httpServer,userSettings) {\n        if (!userSettings) {\n            userSettings = httpServer;\n            httpServer = null;\n        }\n\n        if (!userSettings.SKIP_BUILD_CHECK) {\n            checkVersion(userSettings);\n            checkBuild();\n        }\n\n        if (!userSettings.coreNodesDir) {\n            userSettings.coreNodesDir = path.resolve(path.join(__dirname,\"..\",\"nodes\"));\n        }\n\n        if (userSettings.httpAdminRoot !== false) {\n            runtime.init(userSettings,api);\n            api.init(httpServer,runtime);\n            apiEnabled = true;\n        } else {\n            runtime.init(userSettings);\n            apiEnabled = false;\n        }\n        adminApp = runtime.adminApi.adminApp;\n        nodeApp = runtime.nodeApp;\n        server = runtime.adminApi.server;\n        return;\n    },\n    start: function() {\n        return runtime.start().then(function() {\n            if (apiEnabled) {\n                return api.start();\n            }\n        });\n    },\n    stop: function() {\n        return runtime.stop().then(function() {\n            if (apiEnabled) {\n                return api.stop();\n            }\n        })\n    },\n    nodes: runtime.nodes,\n    log: runtime.log,\n    settings:runtime.settings,\n    util: runtime.util,\n    version: runtime.version,\n\n    comms: api.comms,\n    library: api.library,\n    auth: api.auth,\n\n    get app() { console.log(\"Deprecated use of RED.app - use RED.httpAdmin instead\"); return runtime.app },\n    get httpAdmin() { return adminApp },\n    get httpNode() { return nodeApp },\n    get server() { return server }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require('when');\n\nvar redNodes = require(\"./nodes\");\nvar storage = require(\"./storage\");\nvar log = require(\"./log\");\nvar i18n = require(\"./i18n\");\nvar events = require(\"./events\");\nvar settings = require(\"./settings\");\n\nvar express = require(\"express\");\nvar path = require('path');\nvar fs = require(\"fs\");\nvar os = require(\"os\");\n\nvar runtimeMetricInterval = null;\n\nvar started = false;\n\nvar stubbedExpressApp = {\n    get: function() {},\n    post: function() {},\n    put: function() {},\n    delete: function() {}\n}\nvar adminApi = {\n    library: {\n        register: function() {}\n    },\n    auth: {\n        needsPermission: function() {}\n    },\n    comms: {\n        publish: function() {}\n    },\n    adminApp: stubbedExpressApp,\n    server: {}\n}\n\nvar nodeApp;\n\nfunction init(userSettings,_adminApi) {\n    userSettings.version = getVersion();\n    log.init(userSettings);\n    settings.init(userSettings);\n\n    nodeApp = express();\n\n    if (_adminApi) {\n        adminApi = _adminApi;\n    }\n    redNodes.init(runtime);\n}\n\nvar version;\n\nfunction getVersion() {\n    if (!version) {\n        version = require(path.join(__dirname,\"..\",\"..\",\"package.json\")).version;\n        /* istanbul ignore else */\n        try {\n            fs.statSync(path.join(__dirname,\"..\",\"..\",\".git\"));\n            version += \"-git\";\n        } catch(err) {\n            // No git directory\n        }\n    }\n    return version;\n}\n\nfunction start() {\n    return i18n.init()\n        .then(function() {\n            return i18n.registerMessageCatalog(\"runtime\",path.resolve(path.join(__dirname,\"locales\")),\"runtime.json\")\n        })\n        .then(function() { return storage.init(runtime)})\n        .then(function() { return settings.load(storage)})\n        .then(function() {\n\n            if (log.metric()) {\n                runtimeMetricInterval = setInterval(function() {\n                    reportMetrics();\n                }, settings.runtimeMetricInterval||15000);\n            }\n            log.info(\"\\n\\n\"+log._(\"runtime.welcome\")+\"\\n===================\\n\");\n            if (settings.version) {\n                log.info(log._(\"runtime.version\",{component:\"Node-RED\",version:\"v\"+settings.version}));\n            }\n            log.info(log._(\"runtime.version\",{component:\"Node.js \",version:process.version}));\n            if (settings.UNSUPPORTED_VERSION) {\n                log.error(\"*****************************************************************\");\n                log.error(\"* \"+log._(\"runtime.unsupported_version\",{component:\"Node.js\",version:process.version,requires: \">=4\"})+\" *\");\n                log.error(\"*****************************************************************\");\n                events.emit(\"runtime-event\",{id:\"runtime-unsupported-version\",type:\"error\",text:\"notification.errors.unsupportedVersion\"});\n            }\n            log.info(os.type()+\" \"+os.release()+\" \"+os.arch()+\" \"+os.endianness());\n            return redNodes.load().then(function() {\n\n                var i;\n                var nodeErrors = redNodes.getNodeList(function(n) { return n.err!=null;});\n                var nodeMissing = redNodes.getNodeList(function(n) { return n.module && n.enabled && !n.loaded && !n.err;});\n                if (nodeErrors.length > 0) {\n                    log.warn(\"------------------------------------------------------\");\n                    for (i=0;i<nodeErrors.length;i+=1) {\n                        log.warn(\"[\"+nodeErrors[i].name+\"] \"+nodeErrors[i].err);\n                    }\n                    log.warn(\"------------------------------------------------------\");\n                }\n                if (nodeMissing.length > 0) {\n                    log.warn(log._(\"server.missing-modules\"));\n                    var missingModules = {};\n                    for (i=0;i<nodeMissing.length;i++) {\n                        var missing = nodeMissing[i];\n                        missingModules[missing.module] = (missingModules[missing.module]||[]).concat(missing.types);\n                    }\n                    var promises = [];\n                    for (i in missingModules) {\n                        if (missingModules.hasOwnProperty(i)) {\n                            log.warn(\" - \"+i+\": \"+missingModules[i].join(\", \"));\n                            if (settings.autoInstallModules && i != \"node-red\") {\n                                redNodes.installModule(i).otherwise(function(err) {\n                                    // Error already reported. Need the otherwise handler\n                                    // to stop the error propagating any further\n                                });\n                            }\n                        }\n                    }\n                    if (!settings.autoInstallModules) {\n                        log.info(log._(\"server.removing-modules\"));\n                        redNodes.cleanModuleList();\n                    }\n                }\n                if (settings.settingsFile) {\n                    log.info(log._(\"runtime.paths.settings\",{path:settings.settingsFile}));\n                }\n                redNodes.loadFlows().then(redNodes.startFlows);\n                started = true;\n            }).otherwise(function(err) {\n                console.log(err);\n            });\n        });\n}\n\nfunction reportMetrics() {\n    var memUsage = process.memoryUsage();\n\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.rss\",\n        value: memUsage.rss\n    });\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.heapTotal\",\n        value: memUsage.heapTotal\n    });\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.heapUsed\",\n        value: memUsage.heapUsed\n    });\n}\n\nfunction stop() {\n    if (runtimeMetricInterval) {\n        clearInterval(runtimeMetricInterval);\n        runtimeMetricInterval = null;\n    }\n    started = false;\n    return redNodes.stopFlows();\n}\n\nvar runtime = module.exports = {\n    init: init,\n    start: start,\n    stop: stop,\n\n    version: getVersion,\n\n    log: log,\n    i18n: i18n,\n    settings: settings,\n    storage: storage,\n    events: events,\n    nodes: redNodes,\n    util: require(\"./util\"),\n    get adminApi() { return adminApi },\n    get nodeApp() { return nodeApp },\n    isStarted: function() {\n        return started;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar registry = require(\"./registry\");\nvar credentials = require(\"./credentials\");\nvar flows = require(\"./flows\");\nvar flowUtil = require(\"./flows/util\")\nvar context = require(\"./context\");\nvar Node = require(\"./Node\");\nvar log = require(\"../log\");\n\nvar events = require(\"../events\");\n\nvar child_process = require('child_process');\n\nvar settings;\n\n/**\n * Registers a node constructor\n * @param nodeSet - the nodeSet providing the node (module/set)\n * @param type - the string type name\n * @param constructor - the constructor function for this node type\n * @param opts - optional additional options for the node\n */\nfunction registerType(nodeSet,type,constructor,opts) {\n    if (typeof type !== \"string\") {\n        // This is someone calling the api directly, rather than via the\n        // RED object provided to a node. Log a warning\n        log.warn(\"[\"+nodeSet+\"] Deprecated call to RED.runtime.nodes.registerType - node-set name must be provided as first argument\");\n        opts = constructor;\n        constructor = type;\n        type = nodeSet;\n        nodeSet = \"\";\n    }\n    if (opts && opts.credentials) {\n        credentials.register(type,opts.credentials);\n    }\n    registry.registerType(nodeSet,type,constructor);\n}\n\n/**\n * Called from a Node's constructor function, invokes the super-class\n * constructor and attaches any credentials to the node.\n * @param node the node object being created\n * @param def the instance definition for the node\n */\nfunction createNode(node,def) {\n    Node.call(node,def);\n    var id = node.id;\n    if (def._alias) {\n        id = def._alias;\n    }\n    var creds = credentials.get(id);\n    if (creds) {\n        //console.log(\"Attaching credentials to \",node.id);\n        // allow $(foo) syntax to substitute env variables for credentials also...\n        for (var p in creds) {\n            if (creds.hasOwnProperty(p)) {\n                flowUtil.mapEnvVarProperties(creds,p);\n            }\n        }\n        node.credentials = creds;\n    } else if (credentials.getDefinition(node.type)) {\n        node.credentials = {};\n    }\n}\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    credentials.init(runtime);\n    flows.init(runtime);\n    registry.init(runtime);\n    context.init(runtime.settings);\n}\n\nfunction disableNode(id) {\n    flows.checkTypeInUse(id);\n    return registry.disableNode(id);\n}\n\nfunction uninstallModule(module) {\n    var info = registry.getModuleInfo(module);\n    if (!info) {\n        throw new Error(log._(\"nodes.index.unrecognised-module\", {module:module}));\n    } else {\n        for (var i=0;i<info.nodes.length;i++) {\n            flows.checkTypeInUse(module+\"/\"+info.nodes[i].name);\n        }\n        return registry.uninstallModule(module);\n    }\n}\n\nmodule.exports = {\n    // Lifecycle\n    init: init,\n    load: registry.load,\n\n    // Node registry\n    createNode: createNode,\n    getNode: flows.get,\n    eachNode: flows.eachNode,\n\n    paletteEditorEnabled: registry.paletteEditorEnabled,\n    installModule: registry.installModule,\n    uninstallModule: uninstallModule,\n\n    enableNode: registry.enableNode,\n    disableNode: disableNode,\n\n    // Node type registry\n    registerType: registerType,\n    getType: registry.get,\n\n    getNodeInfo: registry.getNodeInfo,\n    getNodeList: registry.getNodeList,\n\n    getModuleInfo: registry.getModuleInfo,\n\n    getNodeConfigs: registry.getNodeConfigs,\n    getNodeConfig: registry.getNodeConfig,\n\n    clearRegistry: registry.clear,\n    cleanModuleList: registry.cleanModuleList,\n\n    // Flow handling\n    loadFlows:  flows.load,\n    startFlows: flows.startFlows,\n    stopFlows:  flows.stopFlows,\n    setFlows:   flows.setFlows,\n    getFlows:   flows.getFlows,\n\n    addFlow:     flows.addFlow,\n    getFlow:     flows.getFlow,\n    updateFlow:  flows.updateFlow,\n    removeFlow:  flows.removeFlow,\n    // disableFlow: flows.disableFlow,\n    // enableFlow:  flows.enableFlow,\n\n    // Credentials\n    addCredentials: credentials.add,\n    getCredentials: credentials.get,\n    deleteCredentials: credentials.delete,\n    getCredentialDefinition: credentials.getDefinition\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar events = require(\"../../events\");\nvar registry = require(\"./registry\");\nvar loader = require(\"./loader\");\nvar installer = require(\"./installer\");\n\nvar settings;\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    installer.init(runtime.settings);\n    loader.init(runtime);\n    registry.init(settings,loader);\n}\n\nfunction load() {\n    registry.load();\n    return installer.checkPrereq().then(loader.load);\n}\n\nfunction addModule(module) {\n    return loader.addModule(module).then(function() {\n        return registry.getModuleInfo(module);\n    });\n}\n\nfunction enableNodeSet(typeOrId) {\n    return registry.enableNodeSet(typeOrId).then(function() {\n        var nodeSet = registry.getNodeInfo(typeOrId);\n        if (!nodeSet.loaded) {\n            return loader.loadNodeSet(registry.getFullNodeInfo(typeOrId)).then(function() {\n                return registry.getNodeInfo(typeOrId);\n            });\n        }\n        return when.resolve(nodeSet);\n    });\n}\n\nmodule.exports = {\n    init:init,\n    load:load,\n    clear: registry.clear,\n    registerType: registry.registerNodeConstructor,\n\n    get: registry.getNodeConstructor,\n    getNodeInfo: registry.getNodeInfo,\n    getNodeList: registry.getNodeList,\n\n    getModuleInfo: registry.getModuleInfo,\n    getModuleList: registry.getModuleList,\n\n    getNodeConfigs: registry.getAllNodeConfigs,\n    getNodeConfig: registry.getNodeConfig,\n\n    enableNode: enableNodeSet,\n    disableNode: registry.disableNodeSet,\n\n    addModule: addModule,\n    removeModule: registry.removeModule,\n\n    installModule: installer.installModule,\n    uninstallModule: installer.uninstallModule,\n\n    cleanModuleList: registry.cleanModuleList,\n\n    paletteEditorEnabled: installer.paletteEditorEnabled\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/events.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar events = require(\"events\"); \n\nmodule.exports = new events.EventEmitter(); \n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/registry.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n //var UglifyJS = require(\"uglify-js\");\nvar util = require(\"util\");\nvar when = require(\"when\");\nvar events = require(\"../../events\");\n\nvar settings;\n\nvar Node;\n\nvar loader;\n\nvar nodeConfigCache = null;\nvar moduleConfigs = {};\nvar nodeList = [];\nvar nodeConstructors = {};\nvar nodeTypeToId = {};\nvar moduleNodes = {};\n\nfunction init(_settings,_loader) {\n    settings = _settings;\n    loader = _loader;\n    moduleNodes = {};\n    nodeTypeToId = {};\n    nodeConstructors = {};\n    nodeList = [];\n    nodeConfigCache = null;\n    Node = require(\"../Node\");\n}\n\nfunction load() {\n    if (settings.available()) {\n        moduleConfigs = loadNodeConfigs();\n    } else {\n        moduleConfigs = {};\n    }\n}\n\nfunction filterNodeInfo(n) {\n    var r = {\n        id: n.id||n.module+\"/\"+n.name,\n        name: n.name,\n        types: n.types,\n        enabled: n.enabled,\n        local: n.local||false\n    };\n    if (n.hasOwnProperty(\"module\")) {\n        r.module = n.module;\n    }\n    if (n.hasOwnProperty(\"err\")) {\n        r.err = n.err.toString();\n    }\n    return r;\n}\n\n\n\nfunction getModule(id) {\n    var parts = id.split(\"/\");\n    return parts.slice(0,parts.length-1).join(\"/\");\n}\n\nfunction getNode(id) {\n    var parts = id.split(\"/\");\n    return parts[parts.length-1];\n}\n\nfunction saveNodeList() {\n    var moduleList = {};\n\n    for (var module in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(module)) {\n            if (Object.keys(moduleConfigs[module].nodes).length > 0) {\n                if (!moduleList[module]) {\n                    moduleList[module] = {\n                        name: module,\n                        version: moduleConfigs[module].version,\n                        local: moduleConfigs[module].local||false,\n                        nodes: {}\n                    };\n                }\n                var nodes = moduleConfigs[module].nodes;\n                for(var node in nodes) {\n                    /* istanbul ignore else */\n                    if (nodes.hasOwnProperty(node)) {\n                        var config = nodes[node];\n                        var n = filterNodeInfo(config);\n                        delete n.err;\n                        delete n.file;\n                        delete n.id;\n                        n.file = config.file;\n                        moduleList[module].nodes[node] = n;\n                    }\n                }\n            }\n        }\n    }\n    if (settings.available()) {\n        return settings.set(\"nodes\",moduleList);\n    } else {\n        return when.reject(\"Settings unavailable\");\n    }\n}\n\nfunction loadNodeConfigs() {\n    var configs = settings.get(\"nodes\");\n\n    if (!configs) {\n        return {};\n    } else if (configs['node-red']) {\n        return configs;\n    } else {\n        // Migrate from the 0.9.1 format of settings\n        var newConfigs = {};\n        for (var id in configs) {\n            /* istanbul ignore else */\n            if (configs.hasOwnProperty(id)) {\n                var nodeConfig = configs[id];\n                var moduleName;\n                var nodeSetName;\n\n                if (nodeConfig.module) {\n                    moduleName = nodeConfig.module;\n                    nodeSetName = nodeConfig.name.split(\":\")[1];\n                } else {\n                    moduleName = \"node-red\";\n                    nodeSetName = nodeConfig.name.replace(/^\\d+-/,\"\").replace(/\\.js$/,\"\");\n                }\n\n                if (!newConfigs[moduleName]) {\n                    newConfigs[moduleName] = {\n                        name: moduleName,\n                        nodes:{}\n                    };\n                }\n                newConfigs[moduleName].nodes[nodeSetName] = {\n                    name: nodeSetName,\n                    types: nodeConfig.types,\n                    enabled: nodeConfig.enabled,\n                    module: moduleName\n                };\n            }\n        }\n        settings.set(\"nodes\",newConfigs);\n        return newConfigs;\n    }\n}\n\nfunction addNodeSet(id,set,version) {\n    if (!set.err) {\n        set.types.forEach(function(t) {\n            nodeTypeToId[t] = id;\n        });\n    }\n    moduleNodes[set.module] = moduleNodes[set.module]||[];\n    moduleNodes[set.module].push(set.name);\n\n    if (!moduleConfigs[set.module]) {\n        moduleConfigs[set.module] = {\n            name: set.module,\n            nodes: {}\n        };\n    }\n\n    if (version) {\n        moduleConfigs[set.module].version = version;\n    }\n    moduleConfigs[set.module].local = set.local;\n\n    moduleConfigs[set.module].nodes[set.name] = set;\n    nodeList.push(id);\n    nodeConfigCache = null;\n}\n\nfunction removeNode(id) {\n    var config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n    if (!config) {\n        throw new Error(\"Unrecognised id: \"+id);\n    }\n    delete moduleConfigs[getModule(id)].nodes[getNode(id)];\n    var i = nodeList.indexOf(id);\n    if (i > -1) {\n        nodeList.splice(i,1);\n    }\n    config.types.forEach(function(t) {\n        var typeId = nodeTypeToId[t];\n        if (typeId === id) {\n            delete nodeConstructors[t];\n            delete nodeTypeToId[t];\n        }\n    });\n    config.enabled = false;\n    config.loaded = false;\n    nodeConfigCache = null;\n    return filterNodeInfo(config);\n}\n\nfunction removeModule(module) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var nodes = moduleNodes[module];\n    if (!nodes) {\n        throw new Error(\"Unrecognised module: \"+module);\n    }\n    var infoList = [];\n    for (var i=0;i<nodes.length;i++) {\n        infoList.push(removeNode(module+\"/\"+nodes[i]));\n    }\n    delete moduleNodes[module];\n    delete moduleConfigs[module];\n    saveNodeList();\n    return infoList;\n}\n\nfunction getNodeInfo(typeOrId) {\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    /* istanbul ignore else */\n    if (id) {\n        var module = moduleConfigs[getModule(id)];\n        if (module) {\n            var config = module.nodes[getNode(id)];\n            if (config) {\n                var info = filterNodeInfo(config);\n                if (config.hasOwnProperty(\"loaded\")) {\n                    info.loaded = config.loaded;\n                }\n                info.version = module.version;\n                return info;\n            }\n        }\n    }\n    return null;\n}\n\nfunction getFullNodeInfo(typeOrId) {\n    // Used by index.enableNodeSet so that .file can be retrieved to pass\n    // to loader.loadNodeSet\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    /* istanbul ignore else */\n    if (id) {\n        var module = moduleConfigs[getModule(id)];\n        if (module) {\n            return module.nodes[getNode(id)];\n        }\n    }\n    return null;\n}\n\nfunction getNodeList(filter) {\n    var list = [];\n    for (var module in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(module)) {\n            var nodes = moduleConfigs[module].nodes;\n            for (var node in nodes) {\n                /* istanbul ignore else */\n                if (nodes.hasOwnProperty(node)) {\n                    var nodeInfo = filterNodeInfo(nodes[node]);\n                    nodeInfo.version = moduleConfigs[module].version;\n                    if (!filter || filter(nodes[node])) {\n                        list.push(nodeInfo);\n                    }\n                }\n            }\n        }\n    }\n    return list;\n}\n\nfunction getModuleList() {\n    //var list = [];\n    //for (var module in moduleNodes) {\n    //    /* istanbul ignore else */\n    //    if (moduleNodes.hasOwnProperty(module)) {\n    //        list.push(registry.getModuleInfo(module));\n    //    }\n    //}\n    //return list;\n    return moduleConfigs;\n\n}\n\nfunction getModuleInfo(module) {\n    if (moduleNodes[module]) {\n        var nodes = moduleNodes[module];\n        var m = {\n            name: module,\n            version: moduleConfigs[module].version,\n            local: moduleConfigs[module].local,\n            nodes: []\n        };\n        for (var i = 0; i < nodes.length; ++i) {\n            var nodeInfo = filterNodeInfo(moduleConfigs[module].nodes[nodes[i]]);\n            nodeInfo.version = m.version;\n            m.nodes.push(nodeInfo);\n        }\n        return m;\n    } else {\n        return null;\n    }\n}\n\nfunction getCaller(){\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(_, stack){ return stack; };\n    var err = new Error();\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    stack.shift();\n    stack.shift();\n    return stack[0].getFileName();\n}\n\nfunction inheritNode(constructor) {\n    if(Object.getPrototypeOf(constructor.prototype) === Object.prototype) {\n        util.inherits(constructor,Node);\n    } else {\n        var proto = constructor.prototype;\n        while(Object.getPrototypeOf(proto) !== Object.prototype) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        //TODO: This is a partial implementation of util.inherits >= node v5.0.0\n        //      which should be changed when support for node < v5.0.0 is dropped\n        //      see: https://github.com/nodejs/node/pull/3455\n        proto.constructor.super_ = Node;\n        if(Object.setPrototypeOf) {\n            Object.setPrototypeOf(proto, Node.prototype);\n        } else {\n            // hack for node v0.10\n            proto.__proto__ = Node.prototype;\n        }\n    }\n}\n\nfunction registerNodeConstructor(nodeSet,type,constructor) {\n    if (nodeConstructors.hasOwnProperty(type)) {\n        throw new Error(type+\" already registered\");\n    }\n    //TODO: Ensure type is known - but doing so will break some tests\n    //      that don't have a way to register a node template ahead\n    //      of registering the constructor\n    if(!(constructor.prototype instanceof Node)) {\n        inheritNode(constructor);\n    }\n\n    var nodeSetInfo = getFullNodeInfo(nodeSet);\n    if (nodeSetInfo) {\n        if (nodeSetInfo.types.indexOf(type) === -1) {\n            // A type is being registered for a known set, but for some reason\n            // we didn't spot it when parsing the HTML file.\n            // Registered a type is the definitive action - not the presence\n            // of an edit template. Ensure it is on the list of known types.\n            nodeSetInfo.types.push(type);\n        }\n    }\n\n    nodeConstructors[type] = constructor;\n    events.emit(\"type-registered\",type);\n}\n\nfunction getAllNodeConfigs(lang) {\n    if (!nodeConfigCache) {\n        var result = \"\";\n        var script = \"\";\n        for (var i=0;i<nodeList.length;i++) {\n            var id = nodeList[i];\n            var config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n            if (config.enabled && !config.err) {\n                result += config.config;\n                result += loader.getNodeHelp(config,lang||\"en-US\")||\"\";\n                //script += config.script;\n            }\n        }\n        //if (script.length > 0) {\n        //    result += '<script type=\"text/javascript\">';\n        //    result += UglifyJS.minify(script, {fromString: true}).code;\n        //    result += '</script>';\n        //}\n        nodeConfigCache = result;\n    }\n    return nodeConfigCache;\n}\n\nfunction getNodeConfig(id,lang) {\n    var config = moduleConfigs[getModule(id)];\n    if (!config) {\n        return null;\n    }\n    config = config.nodes[getNode(id)];\n    if (config) {\n        var result = config.config;\n        result += loader.getNodeHelp(config,lang||\"en-US\")\n\n        //if (config.script) {\n        //    result += '<script type=\"text/javascript\">'+config.script+'</script>';\n        //}\n        return result;\n    } else {\n        return null;\n    }\n}\n\nfunction getNodeConstructor(type) {\n    var id = nodeTypeToId[type];\n\n    var config;\n    if (typeof id === \"undefined\") {\n        config = undefined;\n    } else {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n    }\n\n    if (!config || (config.enabled && !config.err)) {\n        return nodeConstructors[type];\n    }\n    return null;\n}\n\nfunction clear() {\n    nodeConfigCache = null;\n    moduleConfigs = {};\n    nodeList = [];\n    nodeConstructors = {};\n    nodeTypeToId = {};\n}\n\nfunction getTypeId(type) {\n    if (nodeTypeToId.hasOwnProperty(type)) {\n        return nodeTypeToId[type];\n    } else {\n        return null;\n    }\n}\n\nfunction enableNodeSet(typeOrId) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    var config;\n    try {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n        delete config.err;\n        config.enabled = true;\n        nodeConfigCache = null;\n        return saveNodeList().then(function() {\n            return filterNodeInfo(config);\n        });\n    } catch (err) {\n        throw new Error(\"Unrecognised id: \"+typeOrId);\n    }\n}\n\nfunction disableNodeSet(typeOrId) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    var config;\n    try {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n        // TODO: persist setting\n        config.enabled = false;\n        nodeConfigCache = null;\n        return saveNodeList().then(function() {\n            return filterNodeInfo(config);\n        });\n    } catch (err) {\n        throw new Error(\"Unrecognised id: \"+id);\n    }\n}\n\nfunction cleanModuleList() {\n    var removed = false;\n    for (var mod in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(mod)) {\n            var nodes = moduleConfigs[mod].nodes;\n            var node;\n            if (mod == \"node-red\") {\n                // For core nodes, look for nodes that are enabled, !loaded and !errored\n                for (node in nodes) {\n                    /* istanbul ignore else */\n                    if (nodes.hasOwnProperty(node)) {\n                        var n = nodes[node];\n                        if (n.enabled && !n.err && !n.loaded) {\n                            removeNode(mod+\"/\"+node);\n                            removed = true;\n                        }\n                    }\n                }\n            } else {\n                if (moduleConfigs[mod] && !moduleNodes[mod]) {\n                    // For node modules, look for missing ones\n                    for (node in nodes) {\n                        /* istanbul ignore else */\n                        if (nodes.hasOwnProperty(node)) {\n                            removeNode(mod+\"/\"+node);\n                            removed = true;\n                        }\n                    }\n                    delete moduleConfigs[mod];\n                }\n            }\n        }\n    }\n    if (removed) {\n        saveNodeList();\n    }\n}\n\nvar registry = module.exports = {\n    init: init,\n    load: load,\n    clear: clear,\n\n    registerNodeConstructor: registerNodeConstructor,\n    getNodeConstructor: getNodeConstructor,\n\n    addNodeSet: addNodeSet,\n    enableNodeSet: enableNodeSet,\n    disableNodeSet: disableNodeSet,\n\n    removeModule: removeModule,\n\n    getNodeInfo: getNodeInfo,\n    getFullNodeInfo: getFullNodeInfo,\n    getNodeList: getNodeList,\n    getModuleList: getModuleList,\n    getModuleInfo: getModuleInfo,\n\n    /**\n     * Gets all of the node template configs\n     * @return all of the node templates in a single string\n     */\n    getAllNodeConfigs: getAllNodeConfigs,\n    getNodeConfig: getNodeConfig,\n\n    getTypeId: getTypeId,\n\n    saveNodeList: saveNodeList,\n\n    cleanModuleList: cleanModuleList\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/loader.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar semver = require(\"semver\");\n\nvar localfilesystem = require(\"./localfilesystem\");\nvar registry = require(\"./registry\");\n\nvar settings;\nvar runtime;\n\nfunction init(_runtime) {\n    runtime = _runtime;\n    settings = runtime.settings;\n    localfilesystem.init(runtime);\n}\n\nfunction load(defaultNodesDir,disableNodePathScan) {\n    // To skip node scan, the following line will use the stored node list.\n    // We should expose that as an option at some point, although the\n    // performance gains are minimal.\n    //return loadNodeFiles(registry.getModuleList());\n    runtime.log.info(runtime.log._(\"server.loading\"));\n\n    var nodeFiles = localfilesystem.getNodeFiles(defaultNodesDir,disableNodePathScan);\n    return loadNodeFiles(nodeFiles);\n}\n\nfunction copyObjectProperties(src,dst,copyList,blockList) {\n    if (!src) {\n        return;\n    }\n    if (copyList && !blockList) {\n        copyList.forEach(function(i) {\n            if (src.hasOwnProperty(i)) {\n                var propDescriptor = Object.getOwnPropertyDescriptor(src,i);\n                Object.defineProperty(dst,i,propDescriptor);\n            }\n        });\n    } else if (!copyList && blockList) {\n        for (var i in src) {\n            if (src.hasOwnProperty(i) && blockList.indexOf(i) === -1) {\n                var propDescriptor = Object.getOwnPropertyDescriptor(src,i);\n                Object.defineProperty(dst,i,propDescriptor);\n            }\n        }\n    }\n}\n\nfunction createNodeApi(node) {\n    var red = {\n        nodes: {},\n        log: {},\n        settings: {},\n        events: runtime.events,\n        util: runtime.util,\n        version: runtime.version,\n    }\n    copyObjectProperties(runtime.nodes,red.nodes,[\"createNode\",\"getNode\",\"eachNode\",\"addCredentials\",\"getCredentials\",\"deleteCredentials\" ]);\n    red.nodes.registerType = function(type,constructor,opts) {\n        runtime.nodes.registerType(node.id,type,constructor,opts);\n    }\n    copyObjectProperties(runtime.log,red.log,null,[\"init\"]);\n    copyObjectProperties(runtime.settings,red.settings,null,[\"init\",\"load\",\"reset\"]);\n    if (runtime.adminApi) {\n        red.comms = runtime.adminApi.comms;\n        red.library = runtime.adminApi.library;\n        red.auth = runtime.adminApi.auth;\n        red.httpAdmin = runtime.adminApi.adminApp;\n        red.httpNode = runtime.nodeApp;\n        red.server = runtime.adminApi.server;\n    } else {\n        //TODO: runtime.adminApi is always stubbed if not enabled, so this block\n        // is unused - but may be needed for the unit tests\n        red.comms = {\n            publish: function() {}\n        };\n        red.library = {\n            register: function() {}\n        };\n        red.auth = {\n            needsPermission: function() {}\n        };\n        // TODO: stub out httpAdmin/httpNode/server\n    }\n    red[\"_\"] = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        if (args[0].indexOf(\":\") === -1) {\n            args[0] = node.namespace+\":\"+args[0];\n        }\n        return runtime.i18n._.apply(null,args);\n    }\n    return red;\n}\n\n\nfunction loadNodeFiles(nodeFiles) {\n    var promises = [];\n    for (var module in nodeFiles) {\n        /* istanbul ignore else */\n        if (nodeFiles.hasOwnProperty(module)) {\n            if (nodeFiles[module].redVersion &&\n                !semver.satisfies(runtime.version().replace(\"-git\",\"\"), nodeFiles[module].redVersion)) {\n                //TODO: log it\n                runtime.log.warn(\"[\"+module+\"] \"+runtime.log._(\"server.node-version-mismatch\",{version:nodeFiles[module].redVersion}));\n                continue;\n            }\n            if (module == \"node-red\" || !registry.getModuleInfo(module)) {\n                var first = true;\n                for (var node in nodeFiles[module].nodes) {\n                    /* istanbul ignore else */\n                    if (nodeFiles[module].nodes.hasOwnProperty(node)) {\n                        if (module != \"node-red\" && first) {\n                            // Check the module directory exists\n                            first = false;\n                            var fn = nodeFiles[module].nodes[node].file;\n                            var parts = fn.split(\"/\");\n                            var i = parts.length-1;\n                            for (;i>=0;i--) {\n                                if (parts[i] == \"node_modules\") {\n                                    break;\n                                }\n                            }\n                            var moduleFn = parts.slice(0,i+2).join(\"/\");\n\n                            try {\n                                var stat = fs.statSync(moduleFn);\n                            } catch(err) {\n                                // Module not found, don't attempt to load its nodes\n                                break;\n                            }\n                        }\n\n                        try {\n                            promises.push(loadNodeConfig(nodeFiles[module].nodes[node]))\n                        } catch(err) {\n                            //\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return when.settle(promises).then(function(results) {\n        var nodes = results.map(function(r) {\n            registry.addNodeSet(r.value.id,r.value,r.value.version);\n            return r.value;\n        });\n        return loadNodeSetList(nodes);\n    });\n}\n\nfunction loadNodeConfig(fileInfo) {\n    return when.promise(function(resolve) {\n        var file = fileInfo.file;\n        var module = fileInfo.module;\n        var name = fileInfo.name;\n        var version = fileInfo.version;\n\n        var id = module + \"/\" + name;\n        var info = registry.getNodeInfo(id);\n        var isEnabled = true;\n        if (info) {\n            if (info.hasOwnProperty(\"loaded\")) {\n                throw new Error(file+\" already loaded\");\n            }\n            isEnabled = info.enabled;\n        }\n\n        var node = {\n            id: id,\n            module: module,\n            name: name,\n            file: file,\n            template: file.replace(/\\.js$/,\".html\"),\n            enabled: isEnabled,\n            loaded:false,\n            version: version,\n            local: fileInfo.local\n        };\n        if (fileInfo.hasOwnProperty(\"types\")) {\n            node.types = fileInfo.types;\n        }\n\n        fs.readFile(node.template,'utf8', function(err,content) {\n            if (err) {\n                node.types = [];\n                if (err.code === 'ENOENT') {\n                    if (!node.types) {\n                        node.types = [];\n                    }\n                    node.err = \"Error: \"+node.template+\" does not exist\";\n                } else {\n                    node.types = [];\n                    node.err = err.toString();\n                }\n                resolve(node);\n            } else {\n                var types = [];\n\n                var regExp = /<script ([^>]*)data-template-name=['\"]([^'\"]*)['\"]/gi;\n                var match = null;\n\n                while ((match = regExp.exec(content)) !== null) {\n                    types.push(match[2]);\n                }\n                node.types = types;\n\n                var langRegExp = /^<script[^>]* data-lang=['\"](.+?)['\"]/i;\n                regExp = /(<script[^>]* data-help-name=[\\s\\S]*?<\\/script>)/gi;\n                match = null;\n                var mainContent = \"\";\n                var helpContent = {};\n                var index = 0;\n                while ((match = regExp.exec(content)) !== null) {\n                    mainContent += content.substring(index,regExp.lastIndex-match[1].length);\n                    index = regExp.lastIndex;\n                    var help = content.substring(regExp.lastIndex-match[1].length,regExp.lastIndex);\n\n                    var lang = runtime.i18n.defaultLang;\n                    if ((match = langRegExp.exec(help)) !== null) {\n                        lang = match[1];\n                    }\n                    if (!helpContent.hasOwnProperty(lang)) {\n                        helpContent[lang] = \"\";\n                    }\n\n                    helpContent[lang] += help;\n                }\n                mainContent += content.substring(index);\n\n                node.config = mainContent;\n                node.help = helpContent;\n                // TODO: parse out the javascript portion of the template\n                //node.script = \"\";\n                for (var i=0;i<node.types.length;i++) {\n                    if (registry.getTypeId(node.types[i])) {\n                        node.err = node.types[i]+\" already registered\";\n                        break;\n                    }\n                }\n                fs.stat(path.join(path.dirname(file),\"locales\"),function(err,stat) {\n                    if (!err) {\n                        node.namespace = node.id;\n                        runtime.i18n.registerMessageCatalog(node.id,\n                                path.join(path.dirname(file),\"locales\"),\n                                path.basename(file,\".js\")+\".json\")\n                            .then(function() {\n                                resolve(node);\n                            });\n                    } else {\n                        node.namespace = node.module;\n                        resolve(node);\n                    }\n                });\n            }\n        });\n    });\n}\n\n/**\n * Loads the specified node into the runtime\n * @param node a node info object - see loadNodeConfig\n * @return a promise that resolves to an update node info object. The object\n *         has the following properties added:\n *            err: any error encountered whilst loading the node\n *\n */\nfunction loadNodeSet(node) {\n    var nodeDir = path.dirname(node.file);\n    var nodeFn = path.basename(node.file);\n    if (!node.enabled) {\n        return when.resolve(node);\n    } else {\n    }\n    try {\n        var loadPromise = null;\n        var r = require(node.file);\n        if (typeof r === \"function\") {\n\n            var red = createNodeApi(node);\n            var promise = r(red);\n            if (promise != null && typeof promise.then === \"function\") {\n                loadPromise = promise.then(function() {\n                    node.enabled = true;\n                    node.loaded = true;\n                    return node;\n                }).otherwise(function(err) {\n                    node.err = err;\n                    return node;\n                });\n            }\n        }\n        if (loadPromise == null) {\n            node.enabled = true;\n            node.loaded = true;\n            loadPromise = when.resolve(node);\n        }\n        return loadPromise;\n    } catch(err) {\n        node.err = err;\n        return when.resolve(node);\n    }\n}\n\nfunction loadNodeSetList(nodes) {\n    var promises = [];\n    nodes.forEach(function(node) {\n        if (!node.err) {\n            promises.push(loadNodeSet(node));\n        } else {\n            promises.push(node);\n        }\n    });\n\n    return when.settle(promises).then(function() {\n        if (settings.available()) {\n            return registry.saveNodeList();\n        } else {\n            return;\n        }\n    });\n}\n\nfunction addModule(module) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var nodes = [];\n    if (registry.getModuleInfo(module)) {\n        // TODO: nls\n        var e = new Error(\"module_already_loaded\");\n        e.code = \"module_already_loaded\";\n        return when.reject(e);\n    }\n    try {\n        var moduleFiles = localfilesystem.getModuleFiles(module);\n        return loadNodeFiles(moduleFiles);\n    } catch(err) {\n        return when.reject(err);\n    }\n}\n\nfunction loadNodeHelp(node,lang) {\n    var dir = path.dirname(node.template);\n    var base = path.basename(node.template);\n    var localePath = path.join(dir,\"locales\",lang,base);\n    try {\n        // TODO: make this async\n        var content = fs.readFileSync(localePath, \"utf8\")\n        return content;\n    } catch(err) {\n        return null;\n    }\n}\n\nfunction getNodeHelp(node,lang) {\n    if (!node.help[lang]) {\n        var help = loadNodeHelp(node,lang);\n        if (help == null) {\n            var langParts = lang.split(\"-\");\n            if (langParts.length == 2) {\n                help = loadNodeHelp(node,langParts[0]);\n            }\n        }\n        if (help) {\n            node.help[lang] = help;\n        } else {\n            node.help[lang] = node.help[runtime.i18n.defaultLang];\n        }\n    }\n    return node.help[lang];\n}\n\nmodule.exports = {\n    init: init,\n    load: load,\n    addModule: addModule,\n    loadNodeSet: loadNodeSet,\n    getNodeHelp: getNodeHelp\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/localfilesystem.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar events;\nvar log;\nvar i18n;\n\nvar settings;\nvar disableNodePathScan = false;\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    events = runtime.events;\n    log = runtime.log;\n    i18n = runtime.i18n;\n}\n\nfunction isExcluded(name) {\n     if (settings.nodesExcludes) {\n        for (var i=0;i<settings.nodesExcludes.length;i++) {\n            if (settings.nodesExcludes[i] == name) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getLocalFile(file) {\n    if (isExcluded(path.basename(file))) {\n        return null;\n    }\n    try {\n        fs.statSync(file.replace(/\\.js$/,\".html\"));\n        return {\n            file:    file,\n            module:  \"node-red\",\n            name:    path.basename(file).replace(/^\\d+-/,\"\").replace(/\\.js$/,\"\"),\n            version: settings.version\n        };\n    } catch(err) {\n        return null;\n    }\n}\n\n\n/**\n * Synchronously walks the directory looking for node files.\n * Emits 'node-icon-dir' events for an icon dirs found\n * @param dir the directory to search\n * @return an array of fully-qualified paths to .js files\n */\nfunction getLocalNodeFiles(dir) {\n    var result = [];\n    var files = [];\n    try {\n        files = fs.readdirSync(dir);\n    } catch(err) {\n        return result;\n    }\n    files.sort();\n    files.forEach(function(fn) {\n        var stats = fs.statSync(path.join(dir,fn));\n        if (stats.isFile()) {\n            if (/\\.js$/.test(fn)) {\n                var info = getLocalFile(path.join(dir,fn));\n                if (info) {\n                    result.push(info);\n                }\n            }\n        } else if (stats.isDirectory()) {\n            // Ignore /.dirs/, /lib/ /node_modules/\n            if (!/^(\\..*|lib|icons|node_modules|test|locales)$/.test(fn)) {\n                result = result.concat(getLocalNodeFiles(path.join(dir,fn)));\n            } else if (fn === \"icons\") {\n                events.emit(\"node-icon-dir\",path.join(dir,fn));\n            }\n        }\n    });\n    return result;\n}\n\nfunction scanDirForNodesModules(dir,moduleName) {\n    var results = [];\n    try {\n        var files = fs.readdirSync(dir);\n        for (var i=0;i<files.length;i++) {\n            var fn = files[i];\n            if (/^@/.test(fn)) {\n                results = results.concat(scanDirForNodesModules(path.join(dir,fn),moduleName));\n            } else {\n                if (!isExcluded(fn) && (!moduleName || fn == moduleName)) {\n                    var pkgfn = path.join(dir,fn,\"package.json\");\n                    try {\n                        var pkg = require(pkgfn);\n                        if (pkg['node-red']) {\n                            var moduleDir = path.join(dir,fn);\n                            results.push({dir:moduleDir,package:pkg});\n                        }\n                    } catch(err) {\n                        if (err.code != \"MODULE_NOT_FOUND\") {\n                            // TODO: handle unexpected error\n                        }\n                    }\n                    if (fn == moduleName) {\n                        break;\n                    }\n                }\n            }\n        }\n    } catch(err) {\n    }\n    return results;\n}\n\n/**\n * Scans the node_modules path for nodes\n * @param moduleName the name of the module to be found\n * @return a list of node modules: {dir,package}\n */\nfunction scanTreeForNodesModules(moduleName) {\n    var dir = settings.coreNodesDir;\n    var results = [];\n    var userDir;\n\n    if (settings.userDir) {\n        userDir = path.join(settings.userDir,\"node_modules\");\n        results = scanDirForNodesModules(userDir,moduleName);\n        results.forEach(function(r) { r.local = true; });\n    }\n\n    if (dir) {\n        var up = path.resolve(path.join(dir,\"..\"));\n        while (up !== dir) {\n            var pm = path.join(dir,\"node_modules\");\n            if (pm != userDir) {\n                results = results.concat(scanDirForNodesModules(pm,moduleName));\n            }\n            dir = up;\n            up = path.resolve(path.join(dir,\"..\"));\n        }\n    }\n    return results;\n}\n\nfunction getModuleNodeFiles(module) {\n\n    var moduleDir = module.dir;\n    var pkg = module.package;\n\n    var nodes = pkg['node-red'].nodes||{};\n    var results = [];\n    var iconDirs = [];\n\n    for (var n in nodes) {\n        /* istanbul ignore else */\n        if (nodes.hasOwnProperty(n)) {\n            var file = path.join(moduleDir,nodes[n]);\n            results.push({\n                file:    file,\n                module:  pkg.name,\n                name:    n,\n                version: pkg.version\n            });\n            var iconDir = path.join(moduleDir,path.dirname(nodes[n]),\"icons\");\n            if (iconDirs.indexOf(iconDir) == -1) {\n                try {\n                    fs.statSync(iconDir);\n                    events.emit(\"node-icon-dir\",iconDir);\n                    iconDirs.push(iconDir);\n                } catch(err) {\n                }\n            }\n        }\n    }\n    var examplesDir = path.join(moduleDir,\"examples\");\n    try {\n        fs.statSync(examplesDir)\n        events.emit(\"node-examples-dir\",{name:pkg.name,path:examplesDir});\n    } catch(err) {\n    }\n    return results;\n}\n\nfunction getNodeFiles(disableNodePathScan) {\n    var dir;\n    // Find all of the nodes to load\n    var nodeFiles = [];\n\n    if (settings.coreNodesDir) {\n        nodeFiles = getLocalNodeFiles(path.resolve(settings.coreNodesDir));\n        var defaultLocalesPath = path.resolve(path.join(settings.coreNodesDir,\"core\",\"locales\"));\n        i18n.registerMessageCatalog(\"node-red\",defaultLocalesPath,\"messages.json\");\n    }\n\n    if (settings.userDir) {\n        dir = path.join(settings.userDir,\"nodes\");\n        nodeFiles = nodeFiles.concat(getLocalNodeFiles(dir));\n    }\n    if (settings.nodesDir) {\n        dir = settings.nodesDir;\n        if (typeof settings.nodesDir == \"string\") {\n            dir = [dir];\n        }\n        for (var i=0;i<dir.length;i++) {\n            nodeFiles = nodeFiles.concat(getLocalNodeFiles(dir[i]));\n        }\n    }\n\n    var nodeList = {\n        \"node-red\": {\n            name: \"node-red\",\n            version: settings.version,\n            nodes: {}\n        }\n    }\n    nodeFiles.forEach(function(node) {\n        nodeList[\"node-red\"].nodes[node.name] = node;\n    });\n\n    if (!disableNodePathScan) {\n        var moduleFiles = scanTreeForNodesModules();\n        moduleFiles.forEach(function(moduleFile) {\n            var nodeModuleFiles = getModuleNodeFiles(moduleFile);\n            nodeList[moduleFile.package.name] = {\n                name: moduleFile.package.name,\n                version: moduleFile.package.version,\n                local: moduleFile.local||false,\n                nodes: {}\n            };\n            if (moduleFile.package['node-red'].version) {\n                nodeList[moduleFile.package.name].redVersion = moduleFile.package['node-red'].version;\n            }\n            nodeModuleFiles.forEach(function(node) {\n                node.local = moduleFile.local||false;\n                nodeList[moduleFile.package.name].nodes[node.name] = node;\n            });\n            nodeFiles = nodeFiles.concat(nodeModuleFiles);\n        });\n    } else {\n        console.log(\"node path scan disabled\");\n    }\n    return nodeList;\n}\n\nfunction getModuleFiles(module) {\n    var nodeList = {};\n\n    var moduleFiles = scanTreeForNodesModules(module);\n    if (moduleFiles.length === 0) {\n        var err = new Error(log._(\"nodes.registry.localfilesystem.module-not-found\", {module:module}));\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n    }\n\n    moduleFiles.forEach(function(moduleFile) {\n        var nodeModuleFiles = getModuleNodeFiles(moduleFile);\n        nodeList[moduleFile.package.name] = {\n            name: moduleFile.package.name,\n            version: moduleFile.package.version,\n            nodes: {}\n        };\n        if (moduleFile.package['node-red'].version) {\n            nodeList[moduleFile.package.name].redVersion = moduleFile.package['node-red'].version;\n        }\n        nodeModuleFiles.forEach(function(node) {\n            nodeList[moduleFile.package.name].nodes[node.name] = node;\n            nodeList[moduleFile.package.name].nodes[node.name].local = moduleFile.local || false;\n        });\n    });\n    return nodeList;\n}\n\n\nmodule.exports = {\n    init: init,\n    getNodeFiles: getNodeFiles,\n    getLocalFile: getLocalFile,\n    getModuleFiles: getModuleFiles\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/installer.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar registry = require(\"./registry\");\nvar log = require(\"../../log\");\n\nvar events = require(\"../../events\");\n\nvar child_process = require('child_process');\nvar npmCommand = process.platform === 'win32' ? 'npm.cmd' : 'npm';\nvar paletteEditorEnabled = false;\n\nvar settings;\n\nvar moduleRe = /^[^/]+$/;\nvar slashRe = process.platform === \"win32\" ? /\\\\|[/]/ : /[/]/;\n\nfunction init(_settings) {\n    settings = _settings;\n}\n\nfunction checkModulePath(folder) {\n    var moduleName;\n    var err;\n    var fullPath = path.resolve(folder);\n    var packageFile = path.join(fullPath,'package.json');\n    try {\n        var pkg = require(packageFile);\n        moduleName = pkg.name;\n        if (!pkg['node-red']) {\n            // TODO: nls\n            err = new Error(\"Invalid Node-RED module\");\n            err.code = 'invalid_module';\n            throw err;\n        }\n    } catch(err2) {\n        err = new Error(\"Module not found\");\n        err.code = 404;\n        throw err;\n    }\n    return moduleName;\n}\n\nfunction checkExistingModule(module) {\n    if (registry.getModuleInfo(module)) {\n        // TODO: nls\n        var err = new Error(\"Module already loaded\");\n        err.code = \"module_already_loaded\";\n        throw err;\n    }\n}\n\nfunction installModule(module) {\n    //TODO: ensure module is 'safe'\n    return when.promise(function(resolve,reject) {\n        var installName = module;\n\n        try {\n            if (moduleRe.test(module)) {\n                // Simple module name - assume it can be npm installed\n            } else if (slashRe.test(module)) {\n                // A path - check if there's a valid package.json\n                installName = module;\n                module = checkModulePath(module);\n            }\n            checkExistingModule(module);\n        } catch(err) {\n            return reject(err);\n        }\n        log.info(log._(\"server.install.installing\",{name: module}));\n\n        var installDir = settings.userDir || process.env.NODE_RED_HOME || \".\";\n        var child = child_process.execFile(npmCommand,['install','--production',installName],\n            {\n                cwd: installDir\n            },\n            function(err, stdin, stdout) {\n                if (err) {\n                    var lookFor404 = new RegExp(\" 404 .*\"+installName+\"$\",\"m\");\n                    if (lookFor404.test(stdout)) {\n                        log.warn(log._(\"server.install.install-failed-not-found\",{name:module}));\n                        var e = new Error(\"Module not found\");\n                        e.code = 404;\n                        reject(e);\n                    } else {\n                        log.warn(log._(\"server.install.install-failed-long\",{name:module}));\n                        log.warn(\"------------------------------------------\");\n                        log.warn(err.toString());\n                        log.warn(\"------------------------------------------\");\n                        reject(new Error(log._(\"server.install.install-failed\")));\n                    }\n                } else {\n                    log.info(log._(\"server.install.installed\",{name:module}));\n                    resolve(require(\"./index\").addModule(module).then(reportAddedModules));\n                }\n            }\n        );\n    });\n}\n\n\nfunction reportAddedModules(info) {\n    //comms.publish(\"node/added\",info.nodes,false);\n    if (info.nodes.length > 0) {\n        log.info(log._(\"server.added-types\"));\n        for (var i=0;i<info.nodes.length;i++) {\n            for (var j=0;j<info.nodes[i].types.length;j++) {\n                log.info(\" - \"+\n                    (info.nodes[i].module?info.nodes[i].module+\":\":\"\")+\n                    info.nodes[i].types[j]+\n                    (info.nodes[i].err?\" : \"+info.nodes[i].err:\"\")\n                );\n            }\n        }\n    }\n    return info;\n}\n\nfunction reportRemovedModules(removedNodes) {\n    //comms.publish(\"node/removed\",removedNodes,false);\n    log.info(log._(\"server.removed-types\"));\n    for (var j=0;j<removedNodes.length;j++) {\n        for (var i=0;i<removedNodes[j].types.length;i++) {\n            log.info(\" - \"+(removedNodes[j].module?removedNodes[j].module+\":\":\"\")+removedNodes[j].types[i]);\n        }\n    }\n    return removedNodes;\n}\n\nfunction uninstallModule(module) {\n    return when.promise(function(resolve,reject) {\n        if (/[\\s;]/.test(module)) {\n            reject(new Error(log._(\"server.install.invalid\")));\n            return;\n        }\n        var installDir = settings.userDir || process.env.NODE_RED_HOME || \".\";\n        var moduleDir = path.join(installDir,\"node_modules\",module);\n\n        try {\n            fs.statSync(moduleDir);\n        } catch(err) {\n            return reject(new Error(log._(\"server.install.uninstall-failed\",{name:module})));\n        }\n\n        var list = registry.removeModule(module);\n        log.info(log._(\"server.install.uninstalling\",{name:module}));\n        var child = child_process.execFile(npmCommand,['remove',module],\n            {\n                cwd: installDir\n            },\n            function(err, stdin, stdout) {\n                if (err) {\n                    log.warn(log._(\"server.install.uninstall-failed-long\",{name:module}));\n                    log.warn(\"------------------------------------------\");\n                    log.warn(err.toString());\n                    log.warn(\"------------------------------------------\");\n                    reject(new Error(log._(\"server.install.uninstall-failed\",{name:module})));\n                } else {\n                    log.info(log._(\"server.install.uninstalled\",{name:module}));\n                    reportRemovedModules(list);\n                    // TODO: tidy up internal event names\n                    events.emit(\"node-module-uninstalled\",module)\n                    resolve(list);\n                }\n            }\n        );\n    });\n}\n\nfunction checkPrereq() {\n    if (settings.hasOwnProperty('editorTheme') &&\n        settings.editorTheme.hasOwnProperty('palette') &&\n        settings.editorTheme.palette.hasOwnProperty('editable') &&\n        settings.editorTheme.palette.editable === false\n    ) {\n        log.info(log._(\"server.palette-editor.disabled\"));\n        paletteEditorEnabled = false;\n        return when.resolve();\n    } else {\n        return when.promise(function(resolve) {\n            child_process.execFile(npmCommand,['-v'],function(err) {\n                if (err) {\n                    log.info(log._(\"server.palette-editor.npm-not-found\"));\n                    paletteEditorEnabled = false;\n                } else {\n                    paletteEditorEnabled = true;\n                }\n                resolve();\n            });\n        })\n    }\n}\nmodule.exports = {\n    init: init,\n    checkPrereq: checkPrereq,\n    installModule: installModule,\n    uninstallModule: uninstallModule,\n    paletteEditorEnabled: function() {\n        return paletteEditorEnabled\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/log.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar i18n = require(\"./i18n\");\n\nvar levels = {\n    off:    1,\n    fatal:  10,\n    error:  20,\n    warn:   30,\n    info:   40,\n    debug:  50,\n    trace:  60,\n    audit:  98,\n    metric: 99\n};\n\nvar levelNames = {\n    10: \"fatal\",\n    20: \"error\",\n    30: \"warn\",\n    40: \"info\",\n    50: \"debug\",\n    60: \"trace\",\n    98: \"audit\",\n    99: \"metric\"\n};\n\nvar logHandlers = [];\n\nvar metricsEnabled = false;\n\nvar LogHandler = function(settings) {\n    this.logLevel  = settings ? levels[settings.level]||levels.info : levels.info;\n    this.metricsOn = settings ? settings.metrics||false : false;\n    this.auditOn = settings ? settings.audit||false : false;\n\n    metricsEnabled = metricsEnabled || this.metricsOn;\n\n    this.handler   = (settings && settings.handler) ? settings.handler(settings) : consoleLogger;\n    this.on(\"log\",function(msg) {\n        if (this.shouldReportMessage(msg.level)) {\n            this.handler(msg);\n        }\n    });\n}\nutil.inherits(LogHandler, EventEmitter);\n\nLogHandler.prototype.shouldReportMessage = function(msglevel) {\n    return (msglevel == log.METRIC && this.metricsOn) ||\n           (msglevel == log.AUDIT && this.auditOn) ||\n           msglevel <= this.logLevel;\n}\n\nvar consoleLogger = function(msg) {\n    if (msg.level == log.METRIC || msg.level == log.AUDIT) {\n        util.log(\"[\"+levelNames[msg.level]+\"] \"+JSON.stringify(msg));\n    } else {\n        var message = msg.msg;\n        if (typeof message === 'object' && message.toString() === '[object Object]' && message.message) {\n            message = message.message;\n        }\n        util.log(\"[\"+levelNames[msg.level]+\"] \"+(msg.type?\"[\"+msg.type+\":\"+(msg.name||msg.id)+\"] \":\"\")+message);\n    }\n}\n\nvar log = module.exports = {\n    FATAL:  10,\n    ERROR:  20,\n    WARN:   30,\n    INFO:   40,\n    DEBUG:  50,\n    TRACE:  60,\n    AUDIT:  98,\n    METRIC: 99,\n\n    init: function(settings) {\n        metricsEnabled = false;\n        logHandlers = [];\n        var loggerSettings = {};\n        if (settings.logging) {\n            var keys = Object.keys(settings.logging);\n            if (keys.length === 0) {\n                log.addHandler(new LogHandler());\n            } else {\n                for (var i=0, l=keys.length; i<l; i++) {\n                    var config = settings.logging[keys[i]];\n                    loggerSettings = config || {};\n                    if ((keys[i] === \"console\") || config.handler) {\n                        log.addHandler(new LogHandler(loggerSettings));\n                    }\n                }\n            }\n        } else {\n            log.addHandler(new LogHandler());\n        }\n    },\n    addHandler: function(func) {\n        logHandlers.push(func);\n    },\n    removeHandler: function(func) {\n        var index = logHandlers.indexOf(func);\n        if (index > -1) {\n            logHandlers.splice(index,1);\n        }\n    },\n    log: function(msg) {\n        msg.timestamp = Date.now();\n        logHandlers.forEach(function(handler) {\n            handler.emit(\"log\",msg);\n        });\n    },\n    info: function(msg) {\n        log.log({level:log.INFO,msg:msg});\n    },\n    warn: function(msg) {\n        log.log({level:log.WARN,msg:msg});\n    },\n    error: function(msg) {\n        log.log({level:log.ERROR,msg:msg});\n    },\n    trace: function(msg) {\n        log.log({level:log.TRACE,msg:msg});\n    },\n    debug: function(msg) {\n        log.log({level:log.DEBUG,msg:msg});\n    },\n    metric: function() {\n        return metricsEnabled;\n    },\n\n    audit: function(msg,req) {\n        msg.level = log.AUDIT;\n        if (req) {\n            msg.user = req.user;\n            msg.path = req.path;\n            msg.ip = (req.headers && req.headers['x-forwarded-for']) || (req.connection && req.connection.remoteAddress) || undefined;\n        }\n        log.log(msg);\n    }\n}\n\nlog[\"_\"] = i18n._;\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/i18n.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar i18n = require(\"i18next\");\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar defaultLang = \"en-US\";\n\nvar resourceMap = {};\nvar resourceCache = {};\n\nfunction registerMessageCatalogs(catalogs) {\n    var promises = catalogs.map(function(catalog) {\n        return registerMessageCatalog(catalog.namespace,catalog.dir,catalog.file);\n    });\n    return when.settle(promises);\n}\n\nfunction registerMessageCatalog(namespace,dir,file) {\n    return when.promise(function(resolve,reject) {\n        resourceMap[namespace] = { basedir:dir, file:file};\n        i18n.loadNamespace(namespace,function() {\n            resolve();\n        });\n    });\n}\n\nfunction mergeCatalog(fallback,catalog) {\n    for (var k in fallback) {\n        if (fallback.hasOwnProperty(k)) {\n            if (!catalog[k]) {\n                catalog[k] = fallback[k];\n            } else if (typeof fallback[k] === 'object') {\n                mergeCatalog(fallback[k],catalog[k]);\n            }\n        }\n    }\n}\n\nvar MessageFileLoader = {\n    fetchOne: function(lng, ns, callback) {\n        if (resourceMap[ns]) {\n            var file = path.join(resourceMap[ns].basedir,lng,resourceMap[ns].file);\n            //console.log(file);\n            fs.readFile(file,\"utf8\",function(err,content) {\n                if (err) {\n                    callback(err);\n                } else {\n                    try {\n                        resourceCache[ns] = resourceCache[ns]||{};\n                        resourceCache[ns][lng] = JSON.parse(content.replace(/^\\uFEFF/, ''));\n                        //console.log(resourceCache[ns][lng]);\n                        if (lng !== defaultLang) {\n                            mergeCatalog(resourceCache[ns][defaultLang],resourceCache[ns][lng]);\n                        }\n                        callback(null, resourceCache[ns][lng]);\n                    } catch(e) {\n                        callback(e);\n                    }\n                }\n            });\n        } else {\n            callback(new Error(\"Unrecognised namespace\"));\n        }\n    }\n\n}\n\nfunction init() {\n    return when.promise(function(resolve,reject) {\n        i18n.backend(MessageFileLoader);\n        i18n.init({\n            ns: {\n                namespaces: [],\n                defaultNs: \"runtime\"\n            },\n            fallbackLng: [defaultLang]\n        },function() {\n            resolve();\n        });\n    });\n}\n\nfunction getCatalog(namespace,lang) {\n    var result = null;\n    if (resourceCache.hasOwnProperty(namespace)) {\n        result = resourceCache[namespace][lang];\n        if (!result) {\n            var langParts = lang.split(\"-\");\n            if (langParts.length == 2) {\n                result = resourceCache[namespace][langParts[0]];\n            }\n            if (!result) {\n                return resourceCache[namespace][defaultLang];\n            }\n        }\n    }\n    return result;\n}\n\nvar obj = module.exports = {\n    init: init,\n    registerMessageCatalog: registerMessageCatalog,\n    registerMessageCatalogs: registerMessageCatalogs,\n    catalog: getCatalog,\n    i: i18n,\n    defaultLang: defaultLang\n}\n\nobj['_'] = function() {\n    //var opts = {};\n    //if (def) {\n    //    opts.defaultValue = def;\n    //}\n    //console.log(arguments);\n    return i18n.t.apply(null,arguments);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/credentials.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar crypto = require('crypto');\nvar settings;\nvar log;\n\nvar encryptedCredentials = null;\nvar credentialCache = {};\nvar credentialsDef = {};\nvar dirty = false;\n\nvar removeDefaultKey = false;\nvar encryptionEnabled = null;\nvar encryptionAlgorithm = \"aes-256-ctr\";\nvar encryptionKey;\n\nfunction decryptCredentials(key,credentials) {\n    var creds = credentials[\"$\"];\n    var initVector = new Buffer(creds.substring(0, 32),'hex');\n    creds = creds.substring(32);\n    var decipher = crypto.createDecipheriv(encryptionAlgorithm, key, initVector);\n    var decrypted = decipher.update(creds, 'base64', 'utf8') + decipher.final('utf8');\n    return JSON.parse(decrypted);\n}\n\nvar api = module.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n        settings = runtime.settings;\n        dirty = false;\n        credentialCache = {};\n        credentialsDef = {};\n        encryptionEnabled = null;\n    },\n\n    /**\n     * Sets the credentials from storage.\n     */\n    load: function (credentials) {\n        dirty = false;\n        /*\n          - if encryptionEnabled === null, check the current configuration\n        */\n        var credentialsEncrypted = credentials.hasOwnProperty(\"$\") && Object.keys(credentials).length === 1;\n        var setupEncryptionPromise = when.resolve();\n        if (encryptionEnabled === null) {\n            var defaultKey;\n            try {\n                defaultKey = settings.get('_credentialSecret');\n            } catch(err) {\n            }\n            if (defaultKey) {\n                defaultKey = crypto.createHash('sha256').update(defaultKey).digest();\n            }\n            var userKey;\n            try {\n                userKey = settings.get('credentialSecret');\n            } catch(err) {\n                userKey = false;\n            }\n            if (userKey === false) {\n                log.debug(\"red/runtime/nodes/credentials.load : user disabled encryption\");\n                // User has disabled encryption\n                encryptionEnabled = false;\n                // Check if we have a generated _credSecret to decrypt with and remove\n                if (defaultKey) {\n                    log.debug(\"red/runtime/nodes/credentials.load : default key present. Will migrate\");\n                    if (credentialsEncrypted) {\n                        try {\n                            credentials = decryptCredentials(defaultKey,credentials)\n                        } catch(err) {\n                            credentials = {};\n                            log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                        }\n                    }\n                    dirty = true;\n                    removeDefaultKey = true;\n                }\n            } else if (typeof userKey === 'string') {\n                log.debug(\"red/runtime/nodes/credentials.load : user provided key\");\n                // User has provided own encryption key, get the 32-byte hash of it\n                encryptionKey = crypto.createHash('sha256').update(userKey).digest();\n                encryptionEnabled = true;\n\n                if (defaultKey) {\n                    log.debug(\"red/runtime/nodes/credentials.load : default key present. Will migrate\");\n                    // User has provided their own key, but we already have a default key\n                    // Decrypt using default key\n                    if (credentialsEncrypted) {\n                        try {\n                            credentials = decryptCredentials(defaultKey,credentials)\n                        } catch(err) {\n                            credentials = {};\n                            log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                        }\n                    }\n                    dirty = true;\n                    removeDefaultKey = true;\n                }\n            } else {\n                log.debug(\"red/runtime/nodes/credentials.load : no user key present\");\n                // User has not provide their own key\n                encryptionKey = defaultKey;\n                encryptionEnabled = true;\n                if (encryptionKey === undefined) {\n                    log.debug(\"red/runtime/nodes/credentials.load : no default key present - generating one\");\n                    // No user-provided key, no generated key\n                    // Generate a new key\n                    defaultKey = crypto.randomBytes(32).toString('hex');\n                    try {\n                        setupEncryptionPromise = settings.set('_credentialSecret',defaultKey);\n                        encryptionKey = crypto.createHash('sha256').update(defaultKey).digest();\n                    } catch(err) {\n                        log.debug(\"red/runtime/nodes/credentials.load : settings unavailable - disabling encryption\");\n                        // Settings unavailable\n                        encryptionEnabled = false;\n                        encryptionKey = null;\n                    }\n                    dirty = true;\n                } else {\n                    log.debug(\"red/runtime/nodes/credentials.load : using default key\");\n                }\n            }\n        }\n        if (encryptionEnabled && !dirty) {\n            encryptedCredentials = credentials;\n        }\n        return setupEncryptionPromise.then(function() {\n            if (credentials.hasOwnProperty(\"$\")) {\n                // These are encrypted credentials\n                try {\n                    credentialCache = decryptCredentials(encryptionKey,credentials)\n                } catch(err) {\n                    credentialCache = {};\n                    dirty = true;\n                    log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                }\n            } else {\n                credentialCache = credentials;\n            }\n        });\n    },\n\n    /**\n     * Adds a set of credentials for the given node id.\n     * @param id the node id for the credentials\n     * @param creds an object of credential key/value pairs\n     * @return a promise for backwards compatibility TODO: can this be removed?\n     */\n    add: function (id, creds) {\n        if (!credentialCache.hasOwnProperty(id) || JSON.stringify(creds) !== JSON.stringify(credentialCache[id])) {\n            credentialCache[id] = creds;\n            dirty = true;\n        }\n        return when.resolve();\n    },\n\n    /**\n     * Gets the credentials for the given node id.\n     * @param id the node id for the credentials\n     * @return the credentials\n     */\n    get: function (id) {\n        return credentialCache[id];\n    },\n\n    /**\n     * Deletes the credentials for the given node id.\n     * @param id the node id for the credentials\n     * @return a promise for the saving of credentials to storage\n     */\n    delete: function (id) {\n        delete credentialCache[id];\n        dirty = true;\n    },\n\n    /**\n     * Deletes any credentials for nodes that no longer exist\n     * @param config a flow config\n     * @return a promise for the saving of credentials to storage\n     */\n    clean: function (config) {\n        var existingIds = {};\n        config.forEach(function(n) {\n            existingIds[n.id] = true;\n            if (n.credentials) {\n                api.extract(n);\n            }\n        });\n        var deletedCredentials = false;\n        for (var c in credentialCache) {\n            if (credentialCache.hasOwnProperty(c)) {\n                if (!existingIds[c]) {\n                    deletedCredentials = true;\n                    delete credentialCache[c];\n                }\n            }\n        }\n        if (deletedCredentials) {\n            dirty = true;\n        }\n        return when.resolve();\n    },\n\n    /**\n     * Registers a node credential definition.\n     * @param type the node type\n     * @param definition the credential definition\n     */\n    register: function (type, definition) {\n        var dashedType = type.replace(/\\s+/g, '-');\n        credentialsDef[dashedType] = definition;\n    },\n\n    /**\n     * Extracts and stores any credential updates in the provided node.\n     * The provided node may have a .credentials property that contains\n     * new credentials for the node.\n     * This function loops through the credentials in the definition for\n     * the node-type and applies any of the updates provided in the node.\n     *\n     * This function does not save the credentials to disk as it is expected\n     * to be called multiple times when a new flow is deployed.\n     *\n     * @param node the node to extract credentials from\n     */\n    extract: function(node) {\n        var nodeID = node.id;\n        var nodeType = node.type;\n        var newCreds = node.credentials;\n        if (newCreds) {\n            delete node.credentials;\n            var savedCredentials = credentialCache[nodeID] || {};\n            var dashedType = nodeType.replace(/\\s+/g, '-');\n            var definition = credentialsDef[dashedType];\n            if (!definition) {\n                log.warn(log._(\"nodes.credentials.not-registered\",{type:nodeType}));\n                return;\n            }\n\n            for (var cred in definition) {\n                if (definition.hasOwnProperty(cred)) {\n                    if (newCreds[cred] === undefined) {\n                        continue;\n                    }\n                    if (definition[cred].type == \"password\" && newCreds[cred] == '__PWRD__') {\n                        continue;\n                    }\n                    if (0 === newCreds[cred].length || /^\\s*$/.test(newCreds[cred])) {\n                        delete savedCredentials[cred];\n                        dirty = true;\n                        continue;\n                    }\n                    if (!savedCredentials.hasOwnProperty(cred) || JSON.stringify(savedCredentials[cred]) !== JSON.stringify(newCreds[cred])) {\n                        savedCredentials[cred] = newCreds[cred];\n                        dirty = true;\n                    }\n                }\n            }\n            credentialCache[nodeID] = savedCredentials;\n        }\n    },\n\n    /**\n     * Gets the credential definition for the given node type\n     * @param type the node type\n     * @return the credential definition\n     */\n    getDefinition: function (type) {\n        return credentialsDef[type];\n    },\n\n    dirty: function() {\n        return dirty;\n    },\n\n    export: function() {\n        var result = credentialCache;\n        if (encryptionEnabled) {\n            if (dirty) {\n                try {\n                    log.debug(\"red/runtime/nodes/credentials.export : encrypting\");\n                    var initVector = crypto.randomBytes(16);\n                    var cipher = crypto.createCipheriv(encryptionAlgorithm, encryptionKey, initVector);\n                    result = {\"$\":initVector.toString('hex') + cipher.update(JSON.stringify(credentialCache), 'utf8', 'base64') + cipher.final('base64')};\n                } catch(err) {\n                    log.warn(log._(\"nodes.credentials.error-saving\",{message:err.toString()}))\n                }\n            } else {\n                result = encryptedCredentials;\n            }\n        }\n        dirty = false;\n        if (removeDefaultKey) {\n            log.debug(\"red/runtime/nodes/credentials.export : removing unused default key\");\n            return settings.delete('_credentialSecret').then(function() {\n                removeDefaultKey = false;\n                return result;\n            })\n        } else {\n            return when.resolve(result);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/flows/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar when = require(\"when\");\n\nvar Flow = require('./Flow');\n\nvar typeRegistry = require(\"../registry\");\nvar context = require(\"../context\")\nvar credentials = require(\"../credentials\");\n\nvar flowUtil = require(\"./util\");\nvar log = require(\"../../log\");\nvar events = require(\"../../events\");\nvar redUtil = require(\"../../util\");\nvar deprecated = require(\"../registry/deprecated\");\n\nvar storage = null;\nvar settings = null;\n\nvar activeConfig = null;\nvar activeFlowConfig = null;\n\nvar activeFlows = {};\nvar started = false;\n\nvar activeNodesToFlow = {};\nvar subflowInstanceNodeMap = {};\n\nvar typeEventRegistered = false;\n\nfunction init(runtime) {\n    if (started) {\n        throw new Error(\"Cannot init without a stop\");\n    }\n    settings = runtime.settings;\n    storage = runtime.storage;\n    started = false;\n    if (!typeEventRegistered) {\n        events.on('type-registered',function(type) {\n            if (activeFlowConfig && activeFlowConfig.missingTypes.length > 0) {\n                var i = activeFlowConfig.missingTypes.indexOf(type);\n                if (i != -1) {\n                    log.info(log._(\"nodes.flows.registered-missing\", {type:type}));\n                    activeFlowConfig.missingTypes.splice(i,1);\n                    if (activeFlowConfig.missingTypes.length === 0 && started) {\n                        events.emit(\"runtime-event\",{id:\"runtime-state\"});\n                        start();\n                    }\n                }\n            }\n        });\n        typeEventRegistered = true;\n    }\n}\n\nfunction loadFlows() {\n    return storage.getFlows().then(function(config) {\n        log.debug(\"loaded flow revision: \"+config.rev);\n        return credentials.load(config.credentials).then(function() {\n            return config;\n        });\n    }).otherwise(function(err) {\n        log.warn(log._(\"nodes.flows.error\",{message:err.toString()}));\n        console.log(err.stack);\n    });\n}\nfunction load() {\n    return setFlows(null,\"load\",false);\n}\n\n/*\n * _config - new node array configuration\n * type - full/nodes/flows/load (default full)\n * muteLog - don't emit the standard log messages (used for individual flow api)\n */\nfunction setFlows(_config,type,muteLog) {\n    type = type||\"full\";\n\n    var configSavePromise = null;\n    var config = null;\n    var diff;\n    var newFlowConfig;\n    var isLoad = false;\n    if (type === \"load\") {\n        isLoad = true;\n        configSavePromise = loadFlows().then(function(_config) {\n            config = clone(_config.flows);\n            newFlowConfig = flowUtil.parseConfig(clone(config));\n            type = \"full\";\n            return _config.rev;\n        });\n    } else {\n        config = clone(_config);\n        newFlowConfig = flowUtil.parseConfig(clone(config));\n        if (type !== 'full') {\n            diff = flowUtil.diffConfigs(activeFlowConfig,newFlowConfig);\n        }\n        credentials.clean(config);\n        var credsDirty = credentials.dirty();\n        configSavePromise = credentials.export().then(function(creds) {\n            var saveConfig = {\n                flows: config,\n                credentialsDirty:credsDirty,\n                credentials: creds\n            }\n            return storage.saveFlows(saveConfig);\n        });\n    }\n\n    return configSavePromise\n        .then(function(flowRevision) {\n            if (!isLoad) {\n                log.debug(\"saved flow revision: \"+flowRevision);\n            }\n            activeConfig = {\n                flows:config,\n                rev:flowRevision\n            };\n            activeFlowConfig = newFlowConfig;\n            if (started) {\n                return stop(type,diff,muteLog).then(function() {\n                    context.clean(activeFlowConfig);\n                    start(type,diff,muteLog);\n                    return flowRevision;\n                }).otherwise(function(err) {\n                })\n            }\n        });\n}\n\nfunction getNode(id) {\n    var node;\n    if (activeNodesToFlow[id] && activeFlows[activeNodesToFlow[id]]) {\n        return activeFlows[activeNodesToFlow[id]].getNode(id);\n    }\n    for (var flowId in activeFlows) {\n        if (activeFlows.hasOwnProperty(flowId)) {\n            node = activeFlows[flowId].getNode(id);\n            if (node) {\n                return node;\n            }\n        }\n    }\n    return null;\n}\n\nfunction eachNode(cb) {\n    for (var id in activeFlowConfig.allNodes) {\n        if (activeFlowConfig.allNodes.hasOwnProperty(id)) {\n            cb(activeFlowConfig.allNodes[id]);\n        }\n    }\n}\n\nfunction getFlows() {\n    return activeConfig;\n}\n\nfunction delegateError(node,logMessage,msg) {\n    if (activeFlows[node.z]) {\n        activeFlows[node.z].handleError(node,logMessage,msg);\n    } else if (activeNodesToFlow[node.z] && activeFlows[activeNodesToFlow[node.z]]) {\n        activeFlows[activeNodesToFlow[node.z]].handleError(node,logMessage,msg);\n    } else if (activeFlowConfig.subflows[node.z] && subflowInstanceNodeMap[node.id]) {\n        subflowInstanceNodeMap[node.id].forEach(function(n) {\n            delegateError(getNode(n),logMessage,msg);\n        });\n    }\n}\nfunction handleError(node,logMessage,msg) {\n    if (node.z) {\n        delegateError(node,logMessage,msg);\n    } else {\n        if (activeFlowConfig.configs[node.id]) {\n            activeFlowConfig.configs[node.id]._users.forEach(function(id) {\n                var userNode = activeFlowConfig.allNodes[id];\n                delegateError(userNode,logMessage,msg);\n            })\n        }\n    }\n}\n\nfunction delegateStatus(node,statusMessage) {\n    if (activeFlows[node.z]) {\n        activeFlows[node.z].handleStatus(node,statusMessage);\n    } else if (activeNodesToFlow[node.z] && activeFlows[activeNodesToFlow[node.z]]) {\n        activeFlows[activeNodesToFlow[node.z]].handleStatus(node,statusMessage);\n    }\n}\nfunction handleStatus(node,statusMessage) {\n    events.emit(\"node-status\",{\n        id: node.id,\n        status:statusMessage\n    });\n    if (node.z) {\n        delegateStatus(node,statusMessage);\n    } else {\n        if (activeFlowConfig.configs[node.id]) {\n            activeFlowConfig.configs[node.id]._users.forEach(function(id) {\n                var userNode = activeFlowConfig.allNodes[id];\n                delegateStatus(userNode,statusMessage);\n            })\n        }\n    }\n}\n\n\nfunction start(type,diff,muteLog) {\n    //dumpActiveNodes();\n    type = type||\"full\";\n    started = true;\n    var i;\n    if (activeFlowConfig.missingTypes.length > 0) {\n        log.info(log._(\"nodes.flows.missing-types\"));\n        var knownUnknowns = 0;\n        for (i=0;i<activeFlowConfig.missingTypes.length;i++) {\n            var nodeType = activeFlowConfig.missingTypes[i];\n            var info = deprecated.get(nodeType);\n            if (info) {\n                log.info(log._(\"nodes.flows.missing-type-provided\",{type:activeFlowConfig.missingTypes[i],module:info.module}));\n                knownUnknowns += 1;\n            } else {\n                log.info(\" - \"+activeFlowConfig.missingTypes[i]);\n            }\n        }\n        if (knownUnknowns > 0) {\n            log.info(log._(\"nodes.flows.missing-type-install-1\"));\n            log.info(\"  npm install <module name>\");\n            log.info(log._(\"nodes.flows.missing-type-install-2\"));\n            log.info(\"  \"+settings.userDir);\n        }\n        events.emit(\"runtime-event\",{id:\"runtime-state\",type:\"warning\",text:\"notification.warnings.missing-types\"});\n        return when.resolve();\n    }\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.starting-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.starting-flows\"));\n        }\n    }\n    var id;\n    if (!diff) {\n        if (!activeFlows['global']) {\n            activeFlows['global'] = Flow.create(activeFlowConfig);\n        }\n        for (id in activeFlowConfig.flows) {\n            if (activeFlowConfig.flows.hasOwnProperty(id)) {\n                if (!activeFlows[id]) {\n                    activeFlows[id] = Flow.create(activeFlowConfig,activeFlowConfig.flows[id]);\n                }\n            }\n        }\n    } else {\n        activeFlows['global'].update(activeFlowConfig,activeFlowConfig);\n        for (id in activeFlowConfig.flows) {\n            if (activeFlowConfig.flows.hasOwnProperty(id)) {\n                if (activeFlows[id]) {\n                    activeFlows[id].update(activeFlowConfig,activeFlowConfig.flows[id]);\n                } else {\n                    activeFlows[id] = Flow.create(activeFlowConfig,activeFlowConfig.flows[id]);\n                }\n            }\n        }\n    }\n\n    for (id in activeFlows) {\n        if (activeFlows.hasOwnProperty(id)) {\n            activeFlows[id].start(diff);\n            var activeNodes = activeFlows[id].getActiveNodes();\n            Object.keys(activeNodes).forEach(function(nid) {\n                activeNodesToFlow[nid] = id;\n                if (activeNodes[nid]._alias) {\n                    subflowInstanceNodeMap[activeNodes[nid]._alias] = subflowInstanceNodeMap[activeNodes[nid]._alias] || [];\n                    subflowInstanceNodeMap[activeNodes[nid]._alias].push(nid);\n                }\n            });\n\n        }\n    }\n    events.emit(\"nodes-started\");\n    events.emit(\"runtime-event\",{id:\"runtime-state\"});\n\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.started-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.started-flows\"));\n        }\n    }\n    return when.resolve();\n}\n\nfunction stop(type,diff,muteLog) {\n    type = type||\"full\";\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.stopping-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.stopping-flows\"));\n        }\n    }\n    started = false;\n    var promises = [];\n    var stopList;\n    if (type === 'nodes') {\n        stopList = diff.changed.concat(diff.removed);\n    } else if (type === 'flows') {\n        stopList = diff.changed.concat(diff.removed).concat(diff.linked);\n    }\n    for (var id in activeFlows) {\n        if (activeFlows.hasOwnProperty(id)) {\n            promises = promises.concat(activeFlows[id].stop(stopList));\n            if (!diff || diff.removed.indexOf(id)!==-1) {\n                delete activeFlows[id];\n            }\n        }\n    }\n\n    return when.promise(function(resolve,reject) {\n        when.settle(promises).then(function() {\n            for (id in activeNodesToFlow) {\n                if (activeNodesToFlow.hasOwnProperty(id)) {\n                    if (!activeFlows[activeNodesToFlow[id]]) {\n                        delete activeNodesToFlow[id];\n                    }\n                }\n            }\n            if (stopList) {\n                stopList.forEach(function(id) {\n                    delete activeNodesToFlow[id];\n                });\n            }\n            // Ideally we'd prune just what got stopped - but mapping stopList\n            // id to the list of subflow instance nodes is something only Flow\n            // can do... so cheat by wiping the map knowing it'll be rebuilt\n            // in start()\n            subflowInstanceNodeMap = {};\n            if (!muteLog) {\n                if (diff) {\n                    log.info(log._(\"nodes.flows.stopped-modified-\"+type));\n                } else {\n                    log.info(log._(\"nodes.flows.stopped-flows\"));\n                }\n            }\n            resolve();\n        });\n    });\n}\n\n\nfunction checkTypeInUse(id) {\n    var nodeInfo = typeRegistry.getNodeInfo(id);\n    if (!nodeInfo) {\n        throw new Error(log._(\"nodes.index.unrecognised-id\", {id:id}));\n    } else {\n        var inUse = {};\n        var config = getFlows();\n        config.flows.forEach(function(n) {\n            inUse[n.type] = (inUse[n.type]||0)+1;\n        });\n        var nodesInUse = [];\n        nodeInfo.types.forEach(function(t) {\n            if (inUse[t]) {\n                nodesInUse.push(t);\n            }\n        });\n        if (nodesInUse.length > 0) {\n            var msg = nodesInUse.join(\", \");\n            var err = new Error(log._(\"nodes.index.type-in-use\", {msg:msg}));\n            err.code = \"type_in_use\";\n            throw err;\n        }\n    }\n}\n\nfunction updateMissingTypes() {\n    var subflowInstanceRE = /^subflow:(.+)$/;\n    activeFlowConfig.missingTypes = [];\n\n    for (var id in activeFlowConfig.allNodes) {\n        if (activeFlowConfig.allNodes.hasOwnProperty(id)) {\n            var node = activeFlowConfig.allNodes[id];\n            if (node.type !== 'tab' && node.type !== 'subflow') {\n                var subflowDetails = subflowInstanceRE.exec(node.type);\n                if ( (subflowDetails && !activeFlowConfig.subflows[subflowDetails[1]]) || (!subflowDetails && !typeRegistry.get(node.type)) ) {\n                    if (activeFlowConfig.missingTypes.indexOf(node.type) === -1) {\n                        activeFlowConfig.missingTypes.push(node.type);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction addFlow(flow) {\n    var i,node;\n    if (!flow.hasOwnProperty('nodes')) {\n        throw new Error('missing nodes property');\n    }\n    flow.id = redUtil.generateId();\n\n    var nodes = [{\n        type:'tab',\n        label:flow.label,\n        id:flow.id\n    }];\n\n    for (i=0;i<flow.nodes.length;i++) {\n        node = flow.nodes[i];\n        if (activeFlowConfig.allNodes[node.id]) {\n            // TODO nls\n            return when.reject(new Error('duplicate id'));\n        }\n        if (node.type === 'tab' || node.type === 'subflow') {\n            return when.reject(new Error('invalid node type: '+node.type));\n        }\n        node.z = flow.id;\n        nodes.push(node);\n    }\n    if (flow.configs) {\n        for (i=0;i<flow.configs.length;i++) {\n            node = flow.configs[i];\n            if (activeFlowConfig.allNodes[node.id]) {\n                // TODO nls\n                return when.reject(new Error('duplicate id'));\n            }\n            if (node.type === 'tab' || node.type === 'subflow') {\n                return when.reject(new Error('invalid node type: '+node.type));\n            }\n            node.z = flow.id;\n            nodes.push(node);\n        }\n    }\n    var newConfig = clone(activeConfig.flows);\n    newConfig = newConfig.concat(nodes);\n\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.added-flow\",{label:(flow.label?flow.label+\" \":\"\")+\"[\"+flow.id+\"]\"}));\n        return flow.id;\n    });\n}\n\nfunction getFlow(id) {\n    var flow;\n    if (id === 'global') {\n        flow = activeFlowConfig;\n    } else {\n        flow = activeFlowConfig.flows[id];\n    }\n    if (!flow) {\n        return null;\n    }\n    var result = {\n        id: id\n    };\n    if (flow.label) {\n        result.label = flow.label;\n    }\n    if (id !== 'global') {\n        result.nodes = [];\n    }\n    if (flow.nodes) {\n        var nodeIds = Object.keys(flow.nodes);\n        if (nodeIds.length > 0) {\n            result.nodes = nodeIds.map(function(nodeId) {\n                var node = clone(flow.nodes[nodeId]);\n                if (node.type === 'link out') {\n                    delete node.wires;\n                }\n                return node;\n            })\n        }\n    }\n    if (flow.configs) {\n        var configIds = Object.keys(flow.configs);\n        result.configs = configIds.map(function(configId) {\n            return clone(flow.configs[configId]);\n        })\n        if (result.configs.length === 0) {\n            delete result.configs;\n        }\n    }\n    if (flow.subflows) {\n        var subflowIds = Object.keys(flow.subflows);\n        result.subflows = subflowIds.map(function(subflowId) {\n            var subflow = clone(flow.subflows[subflowId]);\n            var nodeIds = Object.keys(subflow.nodes);\n            subflow.nodes = nodeIds.map(function(id) {\n                return subflow.nodes[id];\n            });\n            if (subflow.configs) {\n                var configIds = Object.keys(subflow.configs);\n                subflow.configs = configIds.map(function(id) {\n                    return subflow.configs[id];\n                })\n            }\n            delete subflow.instances;\n            return subflow;\n        });\n        if (result.subflows.length === 0) {\n            delete result.subflows;\n        }\n    }\n    return result;\n}\n\nfunction updateFlow(id,newFlow) {\n    var label = id;\n    if (id !== 'global') {\n        if (!activeFlowConfig.flows[id]) {\n            var e = new Error();\n            e.code = 404;\n            throw e;\n        }\n        label = activeFlowConfig.flows[id].label;\n    }\n    var newConfig = clone(activeConfig.flows);\n    var nodes;\n\n    if (id === 'global') {\n        // Remove all nodes whose z is not a known flow\n        // When subflows can be owned by a flow, this logic will have to take\n        // that into account\n        newConfig = newConfig.filter(function(node) {\n            return node.type === 'tab' || (node.hasOwnProperty('z') && activeFlowConfig.flows.hasOwnProperty(node.z));\n        })\n\n        // Add in the new config nodes\n        nodes = newFlow.configs||[];\n        if (newFlow.subflows) {\n            // Add in the new subflows\n            newFlow.subflows.forEach(function(sf) {\n                nodes = nodes.concat(sf.nodes||[]).concat(sf.configs||[]);\n                delete sf.nodes;\n                delete sf.configs;\n                nodes.push(sf);\n            });\n        }\n    } else {\n        newConfig = newConfig.filter(function(node) {\n            return node.z !== id && node.id !== id;\n        });\n        var tabNode = {\n            type:'tab',\n            label:newFlow.label,\n            id:id\n        }\n        nodes = [tabNode].concat(newFlow.nodes||[]).concat(newFlow.configs||[]);\n        nodes.forEach(function(n) {\n            n.z = id;\n        });\n    }\n\n    newConfig = newConfig.concat(nodes);\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.updated-flow\",{label:(label?label+\" \":\"\")+\"[\"+id+\"]\"}));\n    })\n}\n\nfunction removeFlow(id) {\n    if (id === 'global') {\n        // TODO: nls + error code\n        throw new Error('not allowed to remove global');\n    }\n    var flow = activeFlowConfig.flows[id];\n    if (!flow) {\n        var e = new Error();\n        e.code = 404;\n        throw e;\n    }\n\n    var newConfig = clone(activeConfig.flows);\n    newConfig = newConfig.filter(function(node) {\n        return node.z !== id && node.id !== id;\n    });\n\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.removed-flow\",{label:(flow.label?flow.label+\" \":\"\")+\"[\"+flow.id+\"]\"}));\n    });\n}\n\nmodule.exports = {\n    init: init,\n\n    /**\n     * Load the current flow configuration from storage\n     * @return a promise for the loading of the config\n     */\n    load: load,\n\n    get:getNode,\n    eachNode: eachNode,\n\n    /**\n     * Gets the current flow configuration\n     */\n    getFlows: getFlows,\n\n    /**\n     * Sets the current active config.\n     * @param config the configuration to enable\n     * @param type the type of deployment to do: full (default), nodes, flows, load\n     * @return a promise for the saving/starting of the new flow\n     */\n    setFlows: setFlows,\n\n    /**\n     * Starts the current flow configuration\n     */\n    startFlows: start,\n\n    /**\n     * Stops the current flow configuration\n     * @return a promise for the stopping of the flow\n     */\n    stopFlows: stop,\n\n    get started() { return started },\n\n    handleError: handleError,\n    handleStatus: handleStatus,\n\n    checkTypeInUse: checkTypeInUse,\n\n    addFlow: addFlow,\n    getFlow: getFlow,\n    updateFlow: updateFlow,\n    removeFlow: removeFlow,\n    disableFlow:null,\n    enableFlow:null\n\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/flows/Flow.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar clone = require(\"clone\");\nvar typeRegistry = require(\"../registry\");\nvar Log = require(\"../../log\");\nvar redUtil = require(\"../../util\");\nvar flowUtil = require(\"./util\");\n\nfunction Flow(global,flow) {\n    if (typeof flow === 'undefined') {\n        flow = global;\n    }\n    var activeNodes = {};\n    var subflowInstanceNodes = {};\n    var catchNodeMap = {};\n    var statusNodeMap = {};\n\n    this.start = function(diff) {\n        var node;\n        var newNode;\n        var id;\n        catchNodeMap = {};\n        statusNodeMap = {};\n\n        var configNodes = Object.keys(flow.configs);\n        var configNodeAttempts = {};\n        while (configNodes.length > 0) {\n            id = configNodes.shift();\n            node = flow.configs[id];\n            if (!activeNodes[id]) {\n                var readyToCreate = true;\n                // This node doesn't exist.\n                // Check it doesn't reference another non-existent config node\n                for (var prop in node) {\n                    if (node.hasOwnProperty(prop) && prop !== 'id' && prop !== 'wires' && prop !== '_users' && flow.configs[node[prop]]) {\n                        if (!activeNodes[node[prop]]) {\n                            // References a non-existent config node\n                            // Add it to the back of the list to try again later\n                            configNodes.push(id);\n                            configNodeAttempts[id] = (configNodeAttempts[id]||0)+1;\n                            if (configNodeAttempts[id] === 100) {\n                                throw new Error(\"Circular config node dependency detected: \"+id);\n                            }\n                            readyToCreate = false;\n                            break;\n                        }\n                    }\n                }\n                if (readyToCreate) {\n                    newNode = createNode(node.type,node);\n                    if (newNode) {\n                        activeNodes[id] = newNode;\n                    }\n                }\n            }\n        }\n\n        if (diff && diff.rewired) {\n            for (var j=0;j<diff.rewired.length;j++) {\n                var rewireNode = activeNodes[diff.rewired[j]];\n                if (rewireNode) {\n                    rewireNode.updateWires(flow.nodes[rewireNode.id].wires);\n                }\n            }\n        }\n\n        for (id in flow.nodes) {\n            if (flow.nodes.hasOwnProperty(id)) {\n                node = flow.nodes[id];\n                if (!node.subflow) {\n                    if (!activeNodes[id]) {\n                        newNode = createNode(node.type,node);\n                        if (newNode) {\n                            activeNodes[id] = newNode;\n                        }\n                    }\n                } else {\n                    if (!subflowInstanceNodes[id]) {\n                        try {\n                            var nodes = createSubflow(flow.subflows[node.subflow]||global.subflows[node.subflow],node,flow.subflows,global.subflows,activeNodes);\n                            subflowInstanceNodes[id] = nodes.map(function(n) { return n.id});\n                            for (var i=0;i<nodes.length;i++) {\n                                if (nodes[i]) {\n                                    activeNodes[nodes[i].id] = nodes[i];\n                                }\n                            }\n                        } catch(err) {\n                            console.log(err.stack)\n                        }\n                    }\n                }\n            }\n        }\n\n        for (id in activeNodes) {\n            if (activeNodes.hasOwnProperty(id)) {\n                node = activeNodes[id];\n                if (node.type === \"catch\") {\n                    catchNodeMap[node.z] = catchNodeMap[node.z] || [];\n                    catchNodeMap[node.z].push(node);\n                } else if (node.type === \"status\") {\n                    statusNodeMap[node.z] = statusNodeMap[node.z] || [];\n                    statusNodeMap[node.z].push(node);\n                }\n            }\n        }\n    }\n\n    this.stop = function(stopList) {\n        return when.promise(function(resolve) {\n            var i;\n            if (stopList) {\n                for (i=0;i<stopList.length;i++) {\n                    if (subflowInstanceNodes[stopList[i]]) {\n                        // The first in the list is the instance node we already\n                        // know about\n                        stopList = stopList.concat(subflowInstanceNodes[stopList[i]].slice(1))\n                    }\n                }\n            } else {\n                stopList = Object.keys(activeNodes);\n            }\n            var promises = [];\n            for (i=0;i<stopList.length;i++) {\n                var node = activeNodes[stopList[i]];\n                if (node) {\n                    delete activeNodes[stopList[i]];\n                    if (subflowInstanceNodes[stopList[i]]) {\n                        delete subflowInstanceNodes[stopList[i]];\n                    }\n                    try {\n                        var p = node.close();\n                        if (p) {\n                            promises.push(p);\n                        }\n                    } catch(err) {\n                        node.error(err);\n                    }\n                }\n            }\n            when.settle(promises).then(function() {\n                resolve();\n            });\n        });\n    }\n\n    this.update = function(_global,_flow) {\n        global = _global;\n        flow = _flow;\n    }\n\n    this.getNode = function(id) {\n        return activeNodes[id];\n    }\n\n    this.getActiveNodes = function() {\n        return activeNodes;\n    }\n\n    this.handleStatus = function(node,statusMessage) {\n        var targetStatusNodes = null;\n        var reportingNode = node;\n        var handled = false;\n        while (reportingNode && !handled) {\n            targetStatusNodes = statusNodeMap[reportingNode.z];\n            if (targetStatusNodes) {\n                targetStatusNodes.forEach(function(targetStatusNode) {\n                    if (targetStatusNode.scope && targetStatusNode.scope.indexOf(node.id) === -1) {\n                        return;\n                    }\n                    var message = {\n                        status: {\n                            text: \"\",\n                            source: {\n                                id: node.id,\n                                type: node.type,\n                                name: node.name\n                            }\n                        }\n                    };\n                    if (statusMessage.hasOwnProperty(\"text\")) {\n                        message.status.text = statusMessage.text.toString();\n                    }\n                    targetStatusNode.receive(message);\n                    handled = true;\n                });\n            }\n            if (!handled) {\n                reportingNode = activeNodes[reportingNode.z];\n            }\n        }\n    }\n\n    this.handleError = function(node,logMessage,msg) {\n        var count = 1;\n        if (msg && msg.hasOwnProperty(\"error\")) {\n            if (msg.error.hasOwnProperty(\"source\")) {\n                if (msg.error.source.id === node.id) {\n                    count = msg.error.source.count+1;\n                    if (count === 10) {\n                        node.warn(Log._(\"nodes.flow.error-loop\"));\n                        return;\n                    }\n                }\n            }\n        }\n        var targetCatchNodes = null;\n        var throwingNode = node;\n        var handled = false;\n        while (throwingNode && !handled) {\n            targetCatchNodes = catchNodeMap[throwingNode.z];\n            if (targetCatchNodes) {\n                targetCatchNodes.forEach(function(targetCatchNode) {\n                    if (targetCatchNode.scope && targetCatchNode.scope.indexOf(throwingNode.id) === -1) {\n                        return;\n                    }\n                    var errorMessage;\n                    if (msg) {\n                        errorMessage = redUtil.cloneMessage(msg);\n                    } else {\n                        errorMessage = {};\n                    }\n                    if (errorMessage.hasOwnProperty(\"error\")) {\n                        errorMessage._error = errorMessage.error;\n                    }\n                    errorMessage.error = {\n                        message: logMessage.toString(),\n                        source: {\n                            id: node.id,\n                            type: node.type,\n                            name: node.name,\n                            count: count\n                        }\n                    };\n                    if (logMessage.hasOwnProperty('stack')) {\n                        errorMessage.error.stack = logMessage.stack;\n                    }\n                    targetCatchNode.receive(errorMessage);\n                    handled = true;\n                });\n            }\n            if (!handled) {\n                throwingNode = activeNodes[throwingNode.z];\n            }\n        }\n    }\n}\n\nfunction createNode(type,config) {\n    var nn = null;\n    var nt = typeRegistry.get(type);\n    if (nt) {\n        var conf = clone(config);\n        delete conf.credentials;\n        for (var p in conf) {\n            if (conf.hasOwnProperty(p)) {\n                flowUtil.mapEnvVarProperties(conf,p);\n            }\n        }\n        try {\n            nn = new nt(conf);\n        }\n        catch (err) {\n            Log.log({\n                level: Log.ERROR,\n                id:conf.id,\n                type: type,\n                msg: err\n            });\n        }\n    } else {\n        Log.error(Log._(\"nodes.flow.unknown-type\", {type:type}));\n    }\n    return nn;\n}\n\nfunction createSubflow(sf,sfn,subflows,globalSubflows,activeNodes) {\n    //console.log(\"CREATE SUBFLOW\",sf.id,sfn.id);\n    var nodes = [];\n    var node_map = {};\n    var newNodes = [];\n    var node;\n    var wires;\n    var i,j,k;\n\n    var createNodeInSubflow = function(def) {\n        node = clone(def);\n        var nid = redUtil.generateId();\n        node_map[node.id] = node;\n        node._alias = node.id;\n        node.id = nid;\n        node.z = sfn.id;\n        newNodes.push(node);\n    }\n\n    // Clone all of the subflow node definitions and give them new IDs\n    for (i in sf.configs) {\n        if (sf.configs.hasOwnProperty(i)) {\n            createNodeInSubflow(sf.configs[i]);\n        }\n    }\n    // Clone all of the subflow node definitions and give them new IDs\n    for (i in sf.nodes) {\n        if (sf.nodes.hasOwnProperty(i)) {\n            createNodeInSubflow(sf.nodes[i]);\n        }\n    }\n\n    // Look for any catch/status nodes and update their scope ids\n    // Update all subflow interior wiring to reflect new node IDs\n    for (i=0;i<newNodes.length;i++) {\n        node = newNodes[i];\n        if (node.wires) {\n            var outputs = node.wires;\n            for (j=0;j<outputs.length;j++) {\n                wires = outputs[j];\n                for (k=0;k<wires.length;k++) {\n                    outputs[j][k] = node_map[outputs[j][k]].id\n                }\n            }\n            if ((node.type === 'catch' || node.type === 'status') && node.scope) {\n                node.scope = node.scope.map(function(id) {\n                    return node_map[id]?node_map[id].id:\"\"\n                })\n            } else {\n                for (var prop in node) {\n                    if (node.hasOwnProperty(prop) && prop !== '_alias') {\n                        if (node_map[node[prop]]) {\n                            //console.log(\"Mapped\",node.type,node.id,prop,node_map[node[prop]].id);\n                            node[prop] = node_map[node[prop]].id;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Create a subflow node to accept inbound messages and route appropriately\n    var Node = require(\"../Node\");\n    var subflowInstance = {\n        id: sfn.id,\n        type: sfn.type,\n        z: sfn.z,\n        name: sfn.name,\n        wires: []\n    }\n    if (sf.in) {\n        subflowInstance.wires = sf.in.map(function(n) { return n.wires.map(function(w) { return node_map[w.id].id;})})\n        subflowInstance._originalWires = clone(subflowInstance.wires);\n    }\n    var subflowNode = new Node(subflowInstance);\n\n    subflowNode.on(\"input\", function(msg) { this.send(msg);});\n\n\n    subflowNode._updateWires = subflowNode.updateWires;\n\n    subflowNode.updateWires = function(newWires) {\n        // Wire the subflow outputs\n        if (sf.out) {\n            var node,wires,i,j;\n            // Restore the original wiring to the internal nodes\n            subflowInstance.wires = clone(subflowInstance._originalWires);\n            for (i=0;i<sf.out.length;i++) {\n                wires = sf.out[i].wires;\n                for (j=0;j<wires.length;j++) {\n                    if (wires[j].id != sf.id) {\n                        node = node_map[wires[j].id];\n                        if (node._originalWires) {\n                            node.wires = clone(node._originalWires);\n                        }\n                    }\n                }\n            }\n\n            var modifiedNodes = {};\n            var subflowInstanceModified = false;\n\n            for (i=0;i<sf.out.length;i++) {\n                wires = sf.out[i].wires;\n                for (j=0;j<wires.length;j++) {\n                    if (wires[j].id === sf.id) {\n                        subflowInstance.wires[wires[j].port] = subflowInstance.wires[wires[j].port].concat(newWires[i]);\n                        subflowInstanceModified = true;\n                    } else {\n                        node = node_map[wires[j].id];\n                        node.wires[wires[j].port] = node.wires[wires[j].port].concat(newWires[i]);\n                        modifiedNodes[node.id] = node;\n                    }\n                }\n            }\n            Object.keys(modifiedNodes).forEach(function(id) {\n                var node = modifiedNodes[id];\n                subflowNode.instanceNodes[id].updateWires(node.wires);\n            });\n            if (subflowInstanceModified) {\n                subflowNode._updateWires(subflowInstance.wires);\n            }\n        }\n    }\n\n    nodes.push(subflowNode);\n\n    // Wire the subflow outputs\n    if (sf.out) {\n        var modifiedNodes = {};\n        for (i=0;i<sf.out.length;i++) {\n            wires = sf.out[i].wires;\n            for (j=0;j<wires.length;j++) {\n                if (wires[j].id === sf.id) {\n                    // A subflow input wired straight to a subflow output\n                    subflowInstance.wires[wires[j].port] = subflowInstance.wires[wires[j].port].concat(sfn.wires[i])\n                    subflowNode._updateWires(subflowInstance.wires);\n                } else {\n                    node = node_map[wires[j].id];\n                    modifiedNodes[node.id] = node;\n                    if (!node._originalWires) {\n                        node._originalWires = clone(node.wires);\n                    }\n                    node.wires[wires[j].port] = (node.wires[wires[j].port]||[]).concat(sfn.wires[i]);\n                }\n            }\n        }\n    }\n\n    // Instantiate the nodes\n    for (i=0;i<newNodes.length;i++) {\n        node = newNodes[i];\n        var type = node.type;\n\n        var m = /^subflow:(.+)$/.exec(type);\n        if (!m) {\n            var newNode = createNode(type,node);\n            if (newNode) {\n                activeNodes[node.id] = newNode;\n                nodes.push(newNode);\n            }\n        } else {\n            var subflowId = m[1];\n            nodes = nodes.concat(createSubflow(subflows[subflowId]||globalSubflows[subflowId],node,subflows,globalSubflows,activeNodes));\n        }\n    }\n\n    subflowNode.instanceNodes = {};\n\n    nodes.forEach(function(node) {\n        subflowNode.instanceNodes[node.id] = node;\n    });\n    return nodes;\n}\n\nmodule.exports = {\n    create: function(global,conf) {\n        return new Flow(global,conf);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/util.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar jsonata = require(\"jsonata\");\n\nfunction generateId() {\n    return (1+Math.random()*4294967295).toString(16);\n}\n\nfunction ensureString(o) {\n    if (Buffer.isBuffer(o)) {\n        return o.toString();\n    } else if (typeof o === \"object\") {\n        return JSON.stringify(o);\n    } else if (typeof o === \"string\") {\n        return o;\n    }\n    return \"\"+o;\n}\n\nfunction ensureBuffer(o) {\n    if (Buffer.isBuffer(o)) {\n        return o;\n    } else if (typeof o === \"object\") {\n        o = JSON.stringify(o);\n    } else if (typeof o !== \"string\") {\n        o = \"\"+o;\n    }\n    return new Buffer(o);\n}\n\nfunction cloneMessage(msg) {\n    // Temporary fix for #97\n    // TODO: remove this http-node-specific fix somehow\n    var req = msg.req;\n    var res = msg.res;\n    delete msg.req;\n    delete msg.res;\n    var m = clone(msg);\n    if (req) {\n        m.req = req;\n        msg.req = req;\n    }\n    if (res) {\n        m.res = res;\n        msg.res = res;\n    }\n    return m;\n}\n\nfunction compareObjects(obj1,obj2) {\n    var i;\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n\n    var isArray1 = Array.isArray(obj1);\n    var isArray2 = Array.isArray(obj2);\n    if (isArray1 != isArray2) {\n        return false;\n    }\n    if (isArray1 && isArray2) {\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (i=0;i<obj1.length;i++) {\n            if (!compareObjects(obj1[i],obj2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    var isBuffer1 = Buffer.isBuffer(obj1);\n    var isBuffer2 = Buffer.isBuffer(obj2);\n    if (isBuffer1 != isBuffer2) {\n        return false;\n    }\n    if (isBuffer1 && isBuffer2) {\n        if (obj1.equals) {\n            // For node 0.12+ - use the native equals\n            return obj1.equals(obj2);\n        } else {\n            if (obj1.length !== obj2.length) {\n                return false;\n            }\n            for (i=0;i<obj1.length;i++) {\n                if (obj1.readUInt8(i) !== obj2.readUInt8(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {\n        return false;\n    }\n    var keys1 = Object.keys(obj1);\n    var keys2 = Object.keys(obj2);\n    if (keys1.length != keys2.length) {\n        return false;\n    }\n    for (var k in obj1) {\n        /* istanbul ignore else */\n        if (obj1.hasOwnProperty(k)) {\n            if (!compareObjects(obj1[k],obj2[k])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction normalisePropertyExpression(str) {\n    // This must be kept in sync with validatePropertyExpression\n    // in editor/js/ui/utils.js\n\n    var length = str.length;\n    if (length === 0) {\n        throw new Error(\"Invalid property expression: zero-length\");\n    }\n    var parts = [];\n    var start = 0;\n    var inString = false;\n    var inBox = false;\n    var quoteChar;\n    var v;\n    for (var i=0;i<length;i++) {\n        var c = str[i];\n        if (!inString) {\n            if (c === \"'\" || c === '\"') {\n                if (i != start) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                inString = true;\n                quoteChar = c;\n                start = i+1;\n            } else if (c === '.') {\n                if (i===0) {\n                    throw new Error(\"Invalid property expression: unexpected . at position 0\");\n                }\n                if (start != i) {\n                    v = str.substring(start,i);\n                    if (/^\\d+$/.test(v)) {\n                        parts.push(parseInt(v));\n                    } else {\n                        parts.push(v);\n                    }\n                }\n                if (i===length-1) {\n                    throw new Error(\"Invalid property expression: unterminated expression\");\n                }\n                // Next char is first char of an identifier: a-z 0-9 $ _\n                if (!/[a-z0-9\\$\\_]/i.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" at position \"+(i+1));\n                }\n                start = i+1;\n            } else if (c === '[') {\n                if (i === 0) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                if (start != i) {\n                    parts.push(str.substring(start,i));\n                }\n                if (i===length-1) {\n                    throw new Error(\"Invalid property expression: unterminated expression\");\n                }\n                // Next char is either a quote or a number\n                if (!/[\"'\\d]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" at position \"+(i+1));\n                }\n                start = i+1;\n                inBox = true;\n            } else if (c === ']') {\n                if (!inBox) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                if (start != i) {\n                    v = str.substring(start,i);\n                    if (/^\\d+$/.test(v)) {\n                        parts.push(parseInt(v));\n                    } else {\n                        throw new Error(\"Invalid property expression: unexpected array expression at position \"+start);\n                    }\n                }\n                start = i+1;\n                inBox = false;\n            } else if (c === ' ') {\n                throw new Error(\"Invalid property expression: unexpected ' ' at position \"+i);\n            }\n        } else {\n            if (c === quoteChar) {\n                if (i-start === 0) {\n                    throw new Error(\"Invalid property expression: zero-length string at position \"+start);\n                }\n                parts.push(str.substring(start,i));\n                // If inBox, next char must be a ]. Otherwise it may be [ or .\n                if (inBox && !/\\]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected array expression at position \"+start);\n                } else if (!inBox && i+1!==length && !/[\\[\\.]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" expression at position \"+(i+1));\n                }\n                start = i+1;\n                inString = false;\n            }\n        }\n\n    }\n    if (inBox || inString) {\n        throw new Error(\"Invalid property expression: unterminated expression\");\n    }\n    if (start < length) {\n        parts.push(str.substring(start));\n    }\n    return parts;\n}\n\nfunction getMessageProperty(msg,expr) {\n    var result = null;\n    if (expr.indexOf('msg.')===0) {\n        expr = expr.substring(4);\n    }\n    var msgPropParts = normalisePropertyExpression(expr);\n    var m;\n    msgPropParts.reduce(function(obj, key) {\n        result = (typeof obj[key] !== \"undefined\" ? obj[key] : undefined);\n        return result;\n    }, msg);\n    return result;\n}\n\nfunction setMessageProperty(msg,prop,value,createMissing) {\n    if (typeof createMissing === 'undefined') {\n        createMissing = (typeof value !== 'undefined');\n    }\n    if (prop.indexOf('msg.')===0) {\n        prop = prop.substring(4);\n    }\n    var msgPropParts = normalisePropertyExpression(prop);\n    var depth = 0;\n    var length = msgPropParts.length;\n    var obj = msg;\n    var key;\n    for (var i=0;i<length-1;i++) {\n        key = msgPropParts[i];\n        if (typeof key === 'string' || (typeof key === 'number' && !Array.isArray(obj))) {\n            if (obj.hasOwnProperty(key)) {\n                obj = obj[key];\n            } else if (createMissing) {\n                if (typeof msgPropParts[i+1] === 'string') {\n                    obj[key] = {};\n                } else {\n                    obj[key] = [];\n                }\n                obj = obj[key];\n            } else {\n                return null;\n            }\n        } else if (typeof key === 'number') {\n            // obj is an array\n            if (obj[key] === undefined) {\n                if (createMissing) {\n                    if (typeof msgPropParts[i+1] === 'string') {\n                        obj[key] = {};\n                    } else {\n                        obj[key] = [];\n                    }\n                    obj = obj[key];\n                } else {\n                    return null\n                }\n            } else {\n                obj = obj[key];\n            }\n        }\n    }\n    key = msgPropParts[length-1];\n    if (typeof value === \"undefined\") {\n        if (typeof key === 'number' && Array.isArray(obj)) {\n            obj.splice(key,1);\n        } else {\n            delete obj[key]\n        }\n    } else {\n        obj[key] = value;\n    }\n}\n\nfunction evaluateNodeProperty(value, type, node, msg) {\n    if (type === 'str') {\n        return \"\"+value;\n    } else if (type === 'num') {\n        return Number(value);\n    } else if (type === 'json') {\n        return JSON.parse(value);\n    } else if (type === 're') {\n        return new RegExp(value);\n    } else if (type === 'date') {\n        return Date.now();\n    } else if (type === 'msg' && msg) {\n        return getMessageProperty(msg,value);\n    } else if (type === 'flow' && node) {\n        return node.context().flow.get(value);\n    } else if (type === 'global' && node) {\n        return node.context().global.get(value);\n    } else if (type === 'bool') {\n        return /^true$/i.test(value);\n    } else if (type === 'jsonata') {\n        return jsonata(value).evaluate({msg:msg});\n    }\n    return value;\n}\n\n\nmodule.exports = {\n    ensureString: ensureString,\n    ensureBuffer: ensureBuffer,\n    cloneMessage: cloneMessage,\n    compareObjects: compareObjects,\n    generateId: generateId,\n    getMessageProperty: getMessageProperty,\n    setMessageProperty: setMessageProperty,\n    evaluateNodeProperty: evaluateNodeProperty,\n    normalisePropertyExpression: normalisePropertyExpression\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/flows/util.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar clone = require(\"clone\");\nvar redUtil = require(\"../../util\");\nvar subflowInstanceRE = /^subflow:(.+)$/;\nvar typeRegistry = require(\"../registry\");\n\nfunction diffNodes(oldNode,newNode) {\n    if (oldNode == null) {\n        return true;\n    }\n    var oldKeys = Object.keys(oldNode).filter(function(p) { return p != \"x\" && p != \"y\" && p != \"wires\" });\n    var newKeys = Object.keys(newNode).filter(function(p) { return p != \"x\" && p != \"y\" && p != \"wires\" });\n    if (oldKeys.length != newKeys.length) {\n        return true;\n    }\n    for (var i=0;i<newKeys.length;i++) {\n        var p = newKeys[i];\n        if (!redUtil.compareObjects(oldNode[p],newNode[p])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar EnvVarPropertyRE = /^\\$\\((\\S+)\\)$/;\n\nfunction mapEnvVarProperties(obj,prop) {\n    if (Buffer.isBuffer(obj[prop])) {\n        return;\n    } else if (Array.isArray(obj[prop])) {\n        for (var i=0;i<obj[prop].length;i++) {\n            mapEnvVarProperties(obj[prop],i);\n        }\n    } else if (typeof obj[prop] === 'string') {\n        var m;\n        if ( (m = EnvVarPropertyRE.exec(obj[prop])) !== null) {\n            if (process.env.hasOwnProperty(m[1])) {\n                obj[prop] = process.env[m[1]];\n            }\n        }\n    } else {\n        for (var p in obj[prop]) {\n            if (obj[prop].hasOwnProperty(p)) {\n                mapEnvVarProperties(obj[prop],p);\n            }\n        }\n    }\n}\n\nmodule.exports = {\n\n    diffNodes: diffNodes,\n    mapEnvVarProperties: mapEnvVarProperties,\n\n    parseConfig: function(config) {\n        var flow = {};\n        flow.allNodes = {};\n        flow.subflows = {};\n        flow.configs = {};\n        flow.flows = {};\n        flow.missingTypes = [];\n\n        config.forEach(function(n) {\n            flow.allNodes[n.id] = clone(n);\n            if (n.type === 'tab') {\n                flow.flows[n.id] = n;\n                flow.flows[n.id].subflows = {};\n                flow.flows[n.id].configs = {};\n                flow.flows[n.id].nodes = {};\n            }\n        });\n\n        config.forEach(function(n) {\n            if (n.type === 'subflow') {\n                flow.subflows[n.id] = n;\n                flow.subflows[n.id].configs = {};\n                flow.subflows[n.id].nodes = {};\n                flow.subflows[n.id].instances = [];\n            }\n        });\n        var linkWires = {};\n        var linkOutNodes = [];\n        config.forEach(function(n) {\n            if (n.type !== 'subflow' && n.type !== 'tab') {\n                var subflowDetails = subflowInstanceRE.exec(n.type);\n\n                if ( (subflowDetails && !flow.subflows[subflowDetails[1]]) || (!subflowDetails && !typeRegistry.get(n.type)) ) {\n                    if (flow.missingTypes.indexOf(n.type) === -1) {\n                        flow.missingTypes.push(n.type);\n                    }\n                }\n                var container = null;\n                if (flow.flows[n.z]) {\n                    container = flow.flows[n.z];\n                } else if (flow.subflows[n.z]) {\n                    container = flow.subflows[n.z];\n                }\n                if (n.hasOwnProperty('x') && n.hasOwnProperty('y')) {\n                    if (subflowDetails) {\n                        var subflowType = subflowDetails[1]\n                        n.subflow = subflowType;\n                        flow.subflows[subflowType].instances.push(n)\n                    }\n                    if (container) {\n                        container.nodes[n.id] = n;\n                    }\n                } else {\n                    if (container) {\n                        container.configs[n.id] = n;\n                    } else {\n                        flow.configs[n.id] = n;\n                        flow.configs[n.id]._users = [];\n                    }\n                }\n                if (n.type === 'link in' && n.links) {\n                    // Ensure wires are present in corresponding link out nodes\n                    n.links.forEach(function(id) {\n                        linkWires[id] = linkWires[id]||{};\n                        linkWires[id][n.id] = true;\n                    })\n                } else if (n.type === 'link out' && n.links) {\n                    linkWires[n.id] = linkWires[n.id]||{};\n                    n.links.forEach(function(id) {\n                        linkWires[n.id][id] = true;\n                    })\n                    linkOutNodes.push(n);\n                }\n            }\n        });\n        linkOutNodes.forEach(function(n) {\n            var links = linkWires[n.id];\n            var targets = Object.keys(links);\n            n.wires = [targets];\n        });\n\n\n        var addedTabs = {};\n        config.forEach(function(n) {\n            if (n.type !== 'subflow' && n.type !== 'tab') {\n                for (var prop in n) {\n                    if (n.hasOwnProperty(prop) && prop !== 'id' && prop !== 'wires' && prop !== 'type' && prop !== '_users' && flow.configs.hasOwnProperty(n[prop])) {\n                        // This property references a global config node\n                        flow.configs[n[prop]]._users.push(n.id)\n                    }\n                }\n                if (n.z && !flow.subflows[n.z]) {\n\n                    if (!flow.flows[n.z]) {\n                        flow.flows[n.z] = {type:'tab',id:n.z};\n                        flow.flows[n.z].subflows = {};\n                        flow.flows[n.z].configs = {};\n                        flow.flows[n.z].nodes = {};\n                        addedTabs[n.z] = flow.flows[n.z];\n                    }\n                    if (addedTabs[n.z]) {\n                        if (n.hasOwnProperty('x') && n.hasOwnProperty('y')) {\n                            addedTabs[n.z].nodes[n.id] = n;\n                        } else {\n                            addedTabs[n.z].configs[n.id] = n;\n                        }\n                    }\n                }\n            }\n        });\n        return flow;\n    },\n\n    diffConfigs: function(oldConfig, newConfig) {\n        var id;\n        var node;\n        var nn;\n        var wires;\n        var j,k;\n\n        var changedSubflows = {};\n\n        var added = {};\n        var removed = {};\n        var changed = {};\n        var wiringChanged = {};\n\n        var linkMap = {};\n\n        for (id in oldConfig.allNodes) {\n            if (oldConfig.allNodes.hasOwnProperty(id)) {\n                node = oldConfig.allNodes[id];\n                // build the map of what this node was previously wired to\n                if (node.wires) {\n                    linkMap[node.id] = linkMap[node.id] || [];\n                    for (j=0;j<node.wires.length;j++) {\n                        wires = node.wires[j];\n                        for (k=0;k<wires.length;k++) {\n                            linkMap[node.id].push(wires[k]);\n                            nn = oldConfig.allNodes[wires[k]];\n                            if (nn) {\n                                linkMap[nn.id] = linkMap[nn.id] || [];\n                                linkMap[nn.id].push(node.id);\n                            }\n                        }\n                    }\n                }\n                // This node has been removed\n                if (!newConfig.allNodes.hasOwnProperty(id)) {\n                    removed[id] = node;\n                    // Mark the container as changed\n                    if (newConfig.allNodes[removed[id].z]) {\n                        changed[removed[id].z] = newConfig.allNodes[removed[id].z];\n                        if (changed[removed[id].z].type === \"subflow\") {\n                            changedSubflows[removed[id].z] = changed[removed[id].z];\n                            //delete removed[id];\n                        }\n                    }\n                } else {\n                    // This node has a material configuration change\n                    if (diffNodes(node,newConfig.allNodes[id]) || newConfig.allNodes[id].credentials) {\n                        changed[id] = newConfig.allNodes[id];\n                        if (changed[id].type === \"subflow\") {\n                            changedSubflows[id] = changed[id];\n                        }\n                        // Mark the container as changed\n                        if (newConfig.allNodes[changed[id].z]) {\n                            changed[changed[id].z] = newConfig.allNodes[changed[id].z];\n                            if (changed[changed[id].z].type === \"subflow\") {\n                                changedSubflows[changed[id].z] = changed[changed[id].z];\n                                delete changed[id];\n                            }\n                        }\n                    }\n                    // This node's wiring has changed\n                    if (!redUtil.compareObjects(node.wires,newConfig.allNodes[id].wires)) {\n                        wiringChanged[id] = newConfig.allNodes[id];\n                        // Mark the container as changed\n                        if (newConfig.allNodes[wiringChanged[id].z]) {\n                            changed[wiringChanged[id].z] = newConfig.allNodes[wiringChanged[id].z];\n                            if (changed[wiringChanged[id].z].type === \"subflow\") {\n                                changedSubflows[wiringChanged[id].z] = changed[wiringChanged[id].z];\n                                delete wiringChanged[id];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Look for added nodes\n        for (id in newConfig.allNodes) {\n            if (newConfig.allNodes.hasOwnProperty(id)) {\n                node = newConfig.allNodes[id];\n                // build the map of what this node is now wired to\n                if (node.wires) {\n                    linkMap[node.id] = linkMap[node.id] || [];\n                    for (j=0;j<node.wires.length;j++) {\n                        wires = node.wires[j];\n                        for (k=0;k<wires.length;k++) {\n                            if (linkMap[node.id].indexOf(wires[k]) === -1) {\n                                linkMap[node.id].push(wires[k]);\n                            }\n                            nn = newConfig.allNodes[wires[k]];\n                            if (nn) {\n                                linkMap[nn.id] = linkMap[nn.id] || [];\n                                if (linkMap[nn.id].indexOf(node.id) === -1) {\n                                    linkMap[nn.id].push(node.id);\n                                }\n                            }\n                        }\n                    }\n                }\n                // This node has been added\n                if (!oldConfig.allNodes.hasOwnProperty(id)) {\n                    added[id] = node;\n                    // Mark the container as changed\n                    if (newConfig.allNodes[added[id].z]) {\n                        changed[added[id].z] = newConfig.allNodes[added[id].z];\n                        if (changed[added[id].z].type === \"subflow\") {\n                            changedSubflows[added[id].z] = changed[added[id].z];\n                            delete added[id];\n                        }\n                    }\n                }\n            }\n        }\n\n        var madeChange;\n        // Loop through the nodes looking for references to changed config nodes\n        // Repeat the loop if anything is marked as changed as it may need to be\n        // propagated to parent nodes.\n        // TODO: looping through all nodes every time is a bit inefficient - could be more targeted\n        do {\n            madeChange = false;\n            for (id in newConfig.allNodes) {\n                if (newConfig.allNodes.hasOwnProperty(id)) {\n                    node = newConfig.allNodes[id];\n                    for (var prop in node) {\n                        if (node.hasOwnProperty(prop) && prop != \"z\" && prop != \"id\" && prop != \"wires\") {\n                            // This node has a property that references a changed/removed node\n                            // Assume it is a config node change and mark this node as\n                            // changed.\n                            if (changed[node[prop]] || removed[node[prop]]) {\n                                if (!changed[node.id]) {\n                                    madeChange = true;\n                                    changed[node.id] = node;\n                                    // This node exists within subflow template\n                                    // Mark the template as having changed\n                                    if (newConfig.allNodes[node.z]) {\n                                        changed[node.z] = newConfig.allNodes[node.z];\n                                        if (changed[node.z].type === \"subflow\") {\n                                            changedSubflows[node.z] = changed[node.z];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } while (madeChange===true)\n\n        // Find any nodes that exist on a subflow template and remove from changed\n        // list as the parent subflow will now be marked as containing a change\n        for (id in newConfig.allNodes) {\n            if (newConfig.allNodes.hasOwnProperty(id)) {\n                node = newConfig.allNodes[id];\n                if (newConfig.allNodes[node.z] && newConfig.allNodes[node.z].type === \"subflow\") {\n                    delete changed[node.id];\n                }\n            }\n        }\n\n        // Recursively mark all instances of changed subflows as changed\n        var changedSubflowStack = Object.keys(changedSubflows);\n        while (changedSubflowStack.length > 0) {\n            var subflowId = changedSubflowStack.pop();\n            for (id in newConfig.allNodes) {\n                if (newConfig.allNodes.hasOwnProperty(id)) {\n                    node = newConfig.allNodes[id];\n                    if (node.type === 'subflow:'+subflowId) {\n                        if (!changed[node.id]) {\n                            changed[node.id] = node;\n                            if (!changed[changed[node.id].z] && newConfig.allNodes[changed[node.id].z]) {\n                                changed[changed[node.id].z] = newConfig.allNodes[changed[node.id].z];\n                                if (newConfig.allNodes[changed[node.id].z].type === \"subflow\") {\n                                    // This subflow instance is inside a subflow. Add the\n                                    // containing subflow to the stack to mark\n                                    changedSubflowStack.push(changed[node.id].z);\n                                    delete changed[node.id];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        var diff = {\n            added:Object.keys(added),\n            changed:Object.keys(changed),\n            removed:Object.keys(removed),\n            rewired:Object.keys(wiringChanged),\n            linked:[]\n        }\n\n        // Traverse the links of all modified nodes to mark the connected nodes\n        var modifiedNodes = diff.added.concat(diff.changed).concat(diff.removed).concat(diff.rewired);\n        var visited = {};\n        while (modifiedNodes.length > 0) {\n            node = modifiedNodes.pop();\n            if (!visited[node]) {\n                visited[node] = true;\n                if (linkMap[node]) {\n                    if (!changed[node] && !added[node] && !removed[node] && !wiringChanged[node]) {\n                        diff.linked.push(node);\n                    }\n                    modifiedNodes = modifiedNodes.concat(linkMap[node]);\n                }\n            }\n        }\n        // for (id in newConfig.allNodes) {\n        //     console.log(\n        //         (added[id]?\"+\":(changed[id]?\"!\":\" \"))+(wiringChanged[id]?\"w\":\" \")+(diff.linked.indexOf(id)!==-1?\"~\":\" \"),\n        //         id,\n        //         newConfig.allNodes[id].type,\n        //         newConfig.allNodes[id].name||newConfig.allNodes[id].label||\"\"\n        //     );\n        // }\n        // for (id in removed) {\n        //     console.log(\n        //         \"- \"+(diff.linked.indexOf(id)!==-1?\"~\":\" \"),\n        //         id,\n        //         oldConfig.allNodes[id].type,\n        //         oldConfig.allNodes[id].name||oldConfig.allNodes[id].label||\"\"\n        //     );\n        // }\n\n        return diff;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/context.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar when = require(\"when\");\nvar util = require(\"../util\");\n\nfunction createContext(id,seed) {\n    var data = seed || {};\n    var obj = seed || {};\n    obj.get = function get(key) {\n        return util.getMessageProperty(data,key);\n    };\n    obj.set = function set(key, value) {\n        util.setMessageProperty(data,key,value);\n    }\n    return obj;\n}\n\nvar contexts = {};\nvar globalContext = null;\n\nfunction getContext(localId,flowId) {\n    var contextId = localId;\n    if (flowId) {\n        contextId = localId+\":\"+flowId;\n    }\n    if (contexts.hasOwnProperty(contextId)) {\n        return contexts[contextId];\n    }\n    var newContext = createContext(contextId);\n    if (flowId) {\n        newContext.flow = getContext(flowId);\n        if (globalContext) {\n            newContext.global = globalContext;\n        }\n    }\n    contexts[contextId] = newContext;\n    return newContext;\n}\nfunction deleteContext(id,flowId) {\n    var contextId = id;\n    if (flowId) {\n        contextId = id+\":\"+flowId;\n    }\n    delete contexts[contextId];\n}\nfunction clean(flowConfig) {\n    var activeIds = {};\n    var contextId;\n    var node;\n    for (var id in contexts) {\n        if (contexts.hasOwnProperty(id)) {\n            var idParts = id.split(\":\");\n            if (!flowConfig.allNodes.hasOwnProperty(idParts[0])) {\n                delete contexts[id];\n            }\n        }\n    }\n}\nmodule.exports = {\n    init: function(settings) {\n        globalContext = createContext(\"global\",settings.functionGlobalContext || {});\n    },\n    get: getContext,\n    delete: deleteContext,\n    clean:clean\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/registry/deprecated.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n \nvar nodes = {\n    \"irc in\":     {module:\"node-red-node-irc\"},\n    \"irc out\":    {module:\"node-red-node-irc\"},\n    \"irc-server\": {module:\"node-red-node-irc\"},\n    \n    \"arduino in\":    {module:\"node-red-node-arduino\"},\n    \"arduino out\":   {module:\"node-red-node-arduino\"},\n    \"arduino-board\": {module:\"node-red-node-arduino\"},\n    \n    \"redis out\": {module:\"node-red-node-redis\"},\n    \n    \"mongodb\": {module:\"node-red-node-mongodb\"},\n    \"mongodb out\": {module:\"node-red-node-mongodb\"},\n    \n    \"serial in\": {module:\"node-red-node-serialport\"},\n    \"serial out\": {module:\"node-red-node-serialport\"},\n    \"serial-port\": {module:\"node-red-node-serialport\"},\n    \n    \"twitter-credentials\": {module:\"node-red-node-twitter\"},\n    \"twitter in\": {module:\"node-red-node-twitter\"},\n    \"twitter out\": {module:\"node-red-node-twitter\"},\n    \n    \"e-mail\": {module:\"node-red-node-email\"},\n    \"e-mail in\": {module:\"node-red-node-email\"},\n    \n    \"feedparse\": {module:\"node-red-node-feedparser\"}\n}\n\nmodule.exports = {\n    get: function(id) {\n        return nodes[id];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/nodes/Node.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar when = require(\"when\");\n\nvar redUtil = require(\"../util\");\nvar Log = require(\"../log\");\nvar context = require(\"./context\");\nvar flows = require(\"./flows\");\n\nfunction Node(n) {\n    this.id = n.id;\n    this.type = n.type;\n    this.z = n.z;\n    this._closeCallbacks = [];\n\n    if (n.name) {\n        this.name = n.name;\n    }\n    if (n._alias) {\n        this._alias = n._alias;\n    }\n    this.updateWires(n.wires);\n}\n\nutil.inherits(Node, EventEmitter);\n\nNode.prototype.updateWires = function(wires) {\n    //console.log(\"UPDATE\",this.id);\n    this.wires = wires || [];\n    delete this._wire;\n\n    var wc = 0;\n    this.wires.forEach(function(w) {\n        wc+=w.length;\n    });\n    this._wireCount = wc;\n    if (wc === 0) {\n        // With nothing wired to the node, no-op send\n        this.send = function(msg) {}\n    } else {\n        this.send = Node.prototype.send;\n        if (this.wires.length === 1 && this.wires[0].length === 1) {\n            // Single wire, so we can shortcut the send when\n            // a single message is sent\n            this._wire = this.wires[0][0];\n        }\n    }\n\n}\nNode.prototype.context = function() {\n    if (!this._context) {\n         this._context = context.get(this._alias||this.id,this.z);\n    }\n    return this._context;\n}\n\nNode.prototype._on = Node.prototype.on;\n\nNode.prototype.on = function(event, callback) {\n    var node = this;\n    if (event == \"close\") {\n        this._closeCallbacks.push(callback);\n    } else {\n        this._on(event, callback);\n    }\n};\n\nNode.prototype.close = function() {\n    var promises = [];\n    var node = this;\n    for (var i=0;i<this._closeCallbacks.length;i++) {\n        var callback = this._closeCallbacks[i];\n        if (callback.length == 1) {\n            promises.push(\n                when.promise(function(resolve) {\n                    callback.call(node, function() {\n                        resolve();\n                    });\n                })\n            );\n        } else {\n            callback.call(node);\n        }\n    }\n    if (promises.length > 0) {\n        return when.settle(promises).then(function() {\n            if (this._context) {\n                 context.delete(this._alias||this.id,this.z);\n            }\n        });\n    } else {\n        if (this._context) {\n             context.delete(this._alias||this.id,this.z);\n        }\n        return;\n    }\n};\n\nNode.prototype.send = function(msg) {\n    var msgSent = false;\n    var node;\n\n    if (msg === null || typeof msg === \"undefined\") {\n        return;\n    } else if (!util.isArray(msg)) {\n        if (this._wire) {\n            // A single message and a single wire on output 0\n            // TODO: pre-load flows.get calls - cannot do in constructor\n            //       as not all nodes are defined at that point\n            if (!msg._msgid) {\n                msg._msgid = redUtil.generateId();\n            }\n            this.metric(\"send\",msg);\n            node = flows.get(this._wire);\n            /* istanbul ignore else */\n            if (node) {\n                node.receive(msg);\n            }\n            return;\n        } else {\n            msg = [msg];\n        }\n    }\n\n    var numOutputs = this.wires.length;\n\n    // Build a list of send events so that all cloning is done before\n    // any calls to node.receive\n    var sendEvents = [];\n\n    var sentMessageId = null;\n\n    // for each output of node eg. [msgs to output 0, msgs to output 1, ...]\n    for (var i = 0; i < numOutputs; i++) {\n        var wires = this.wires[i]; // wires leaving output i\n        /* istanbul ignore else */\n        if (i < msg.length) {\n            var msgs = msg[i]; // msgs going to output i\n            if (msgs !== null && typeof msgs !== \"undefined\") {\n                if (!util.isArray(msgs)) {\n                    msgs = [msgs];\n                }\n                var k = 0;\n                // for each recipent node of that output\n                for (var j = 0; j < wires.length; j++) {\n                    node = flows.get(wires[j]); // node at end of wire j\n                    if (node) {\n                        // for each msg to send eg. [[m1, m2, ...], ...]\n                        for (k = 0; k < msgs.length; k++) {\n                            var m = msgs[k];\n                            if (m !== null && m !== undefined) {\n                                /* istanbul ignore else */\n                                if (!sentMessageId) {\n                                    sentMessageId = m._msgid;\n                                }\n                                if (msgSent) {\n                                    var clonedmsg = redUtil.cloneMessage(m);\n                                    sendEvents.push({n:node,m:clonedmsg});\n                                } else {\n                                    sendEvents.push({n:node,m:m});\n                                    msgSent = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /* istanbul ignore else */\n    if (!sentMessageId) {\n        sentMessageId = redUtil.generateId();\n    }\n    this.metric(\"send\",{_msgid:sentMessageId});\n\n    for (i=0;i<sendEvents.length;i++) {\n        var ev = sendEvents[i];\n        /* istanbul ignore else */\n        if (!ev.m._msgid) {\n            ev.m._msgid = sentMessageId;\n        }\n        ev.n.receive(ev.m);\n    }\n};\n\nNode.prototype.receive = function(msg) {\n    if (!msg) {\n        msg = {};\n    }\n    if (!msg._msgid) {\n        msg._msgid = redUtil.generateId();\n    }\n    this.metric(\"receive\",msg);\n    try {\n        this.emit(\"input\", msg);\n    } catch(err) {\n        this.error(err,msg);\n    }\n};\n\nfunction log_helper(self, level, msg) {\n    var o = {\n        level: level,\n        id: self.id,\n        type: self.type,\n        msg: msg\n    };\n    if (self.name) {\n        o.name = self.name;\n    }\n    Log.log(o);\n}\n\nNode.prototype.log = function(msg) {\n    log_helper(this, Log.INFO, msg);\n};\n\nNode.prototype.warn = function(msg) {\n    log_helper(this, Log.WARN, msg);\n};\n\nNode.prototype.error = function(logMessage,msg) {\n    if (typeof logMessage != 'boolean') {\n        logMessage = logMessage || \"\";\n    }\n    log_helper(this, Log.ERROR, logMessage);\n    /* istanbul ignore else */\n    if (msg) {\n        flows.handleError(this,logMessage,msg);\n    }\n};\n\n/**\n * If called with no args, returns whether metric collection is enabled\n */\nNode.prototype.metric = function(eventname, msg, metricValue) {\n    if (typeof eventname === \"undefined\") {\n        return Log.metric();\n    }\n    var metrics = {};\n    metrics.level = Log.METRIC;\n    metrics.nodeid = this.id;\n    metrics.event = \"node.\"+this.type+\".\"+eventname;\n    metrics.msgid = msg._msgid;\n    metrics.value = metricValue;\n    Log.log(metrics);\n}\n\n/**\n * status: { fill:\"red|green\", shape:\"dot|ring\", text:\"blah\" }\n */\nNode.prototype.status = function(status) {\n    flows.handleStatus(this,status);\n};\nmodule.exports = Node;\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/storage/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require('when');\nvar Path = require('path');\nvar crypto = require('crypto');\n\nvar log = require(\"../log\");\n\nvar runtime;\nvar storageModule;\nvar settingsAvailable;\nvar sessionsAvailable;\n\nfunction moduleSelector(aSettings) {\n    var toReturn;\n    if (aSettings.storageModule) {\n        if (typeof aSettings.storageModule === \"string\") {\n            // TODO: allow storage modules to be specified by absolute path\n            toReturn = require(\"./\"+aSettings.storageModule);\n        } else {\n            toReturn = aSettings.storageModule;\n        }\n    } else {\n        toReturn = require(\"./localfilesystem\");\n    }\n    return toReturn;\n}\n\nfunction is_malicious(path) {\n    return path.indexOf('../') != -1 || path.indexOf('..\\\\') != -1;\n}\n\nvar storageModuleInterface = {\n        init: function(_runtime) {\n            runtime = _runtime;\n            try {\n                storageModule = moduleSelector(runtime.settings);\n                settingsAvailable = storageModule.hasOwnProperty(\"getSettings\") && storageModule.hasOwnProperty(\"saveSettings\");\n                sessionsAvailable = storageModule.hasOwnProperty(\"getSessions\") && storageModule.hasOwnProperty(\"saveSessions\");\n            } catch (e) {\n                return when.reject(e);\n            }\n            return storageModule.init(runtime.settings);\n        },\n        getFlows: function() {\n            return storageModule.getFlows().then(function(flows) {\n                return storageModule.getCredentials().then(function(creds) {\n                    var result = {\n                        flows: flows,\n                        credentials: creds\n                    };\n                    result.rev = crypto.createHash('md5').update(JSON.stringify(result)).digest(\"hex\");\n                    return result;\n                })\n            });\n        },\n        saveFlows: function(config) {\n            var flows = config.flows;\n            var credentials = config.credentials;\n            var credentialSavePromise;\n            if (config.credentialsDirty) {\n                credentialSavePromise = storageModule.saveCredentials(credentials);\n            } else {\n                credentialSavePromise = when.resolve();\n            }\n            delete config.credentialsDirty;\n\n            return credentialSavePromise.then(function() {\n                return storageModule.saveFlows(flows).then(function() {\n                    return crypto.createHash('md5').update(JSON.stringify(config)).digest(\"hex\");\n                })\n            });\n        },\n        // getCredentials: function() {\n        //     return storageModule.getCredentials();\n        // },\n        // saveCredentials: function(credentials) {\n        //     return storageModule.saveCredentials(credentials);\n        // },\n        getSettings: function() {\n            if (settingsAvailable) {\n                return storageModule.getSettings();\n            } else {\n                return when.resolve(null);\n            }\n        },\n        saveSettings: function(settings) {\n            if (settingsAvailable) {\n                return storageModule.saveSettings(settings);\n            } else {\n                return when.resolve();\n            }\n        },\n        getSessions: function() {\n            if (sessionsAvailable) {\n                return storageModule.getSessions();\n            } else {\n                return when.resolve(null);\n            }\n        },\n        saveSessions: function(sessions) {\n            if (sessionsAvailable) {\n                return storageModule.saveSessions(sessions);\n            } else {\n                return when.resolve();\n            }\n        },\n\n        /* Library Functions */\n\n        getLibraryEntry: function(type, path) {\n            if (is_malicious(path)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            return storageModule.getLibraryEntry(type, path);\n        },\n        saveLibraryEntry: function(type, path, meta, body) {\n            if (is_malicious(path)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            return storageModule.saveLibraryEntry(type, path, meta, body);\n        },\n\n/* Deprecated functions */\n        getAllFlows: function() {\n            if (storageModule.hasOwnProperty(\"getAllFlows\")) {\n                return storageModule.getAllFlows();\n            } else {\n                return listFlows(\"/\");\n            }\n        },\n        getFlow: function(fn) {\n            if (is_malicious(fn)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            if (storageModule.hasOwnProperty(\"getFlow\")) {\n                return storageModule.getFlow(fn);\n            } else {\n                return storageModule.getLibraryEntry(\"flows\",fn);\n            }\n\n        },\n        saveFlow: function(fn, data) {\n            if (is_malicious(fn)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            if (storageModule.hasOwnProperty(\"saveFlow\")) {\n                return storageModule.saveFlow(fn, data);\n            } else {\n                return storageModule.saveLibraryEntry(\"flows\",fn,{},data);\n            }\n        }\n/* End deprecated functions */\n\n}\n\n\nfunction listFlows(path) {\n    return storageModule.getLibraryEntry(\"flows\",path).then(function(res) {\n        return when.promise(function(resolve) {\n            var promises = [];\n            res.forEach(function(r) {\n                if (typeof r === \"string\") {\n                    promises.push(listFlows(Path.join(path,r)));\n                } else {\n                    promises.push(when.resolve(r));\n                }\n            });\n            var i=0;\n            when.settle(promises).then(function(res2) {\n                var result = {};\n                res2.forEach(function(r) {\n                    // TODO: name||fn\n                    if (r.value.fn) {\n                        var name = r.value.name;\n                        if (!name) {\n                            name = r.value.fn.split(\".\")[0];\n                        }\n                        result.f = result.f || [];\n                        result.f.push(name);\n                    } else {\n                        result.d = result.d || {};\n                        result.d[res[i]] = r.value;\n                        //console.log(\">\",r.value);\n                    }\n                    i++;\n                });\n                resolve(result);\n            });\n        });\n    });\n}\n\n\n\nmodule.exports = storageModuleInterface;\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/settings.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar clone = require(\"clone\");\nvar assert = require(\"assert\");\nvar log = require(\"./log\");\n\nvar userSettings = null;\nvar globalSettings = null;\nvar storage = null;\n\nvar persistentSettings = {\n    init: function(settings) {\n        userSettings = settings;\n        for (var i in settings) {\n            /* istanbul ignore else */\n            if (settings.hasOwnProperty(i) && i !== 'load' && i !== 'get' && i !== 'set' && i !== 'available' && i !== 'reset') {\n                // Don't allow any of the core functions get replaced via settings\n                (function() {\n                    var j = i;\n                    persistentSettings.__defineGetter__(j,function() { return userSettings[j]; });\n                    persistentSettings.__defineSetter__(j,function() { throw new Error(\"Property '\"+j+\"' is read-only\"); });\n                })();\n            }\n        }\n        globalSettings = null;\n    },\n    load: function(_storage) {\n        storage = _storage;\n        return storage.getSettings().then(function(_settings) {\n            globalSettings = _settings;\n        });\n    },\n    get: function(prop) {\n        if (userSettings.hasOwnProperty(prop)) {\n            return clone(userSettings[prop]);\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        return clone(globalSettings[prop]);\n    },\n\n    set: function(prop,value) {\n        if (userSettings.hasOwnProperty(prop)) {\n            throw new Error(log._(\"settings.property-read-only\", {prop:prop}));\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        var current = globalSettings[prop];\n        globalSettings[prop] = value;\n        try {\n            assert.deepEqual(current,value);\n            return when.resolve();\n        } catch(err) {\n            return storage.saveSettings(globalSettings);\n        }\n    },\n    delete: function(prop) {\n        if (userSettings.hasOwnProperty(prop)) {\n            throw new Error(log._(\"settings.property-read-only\", {prop:prop}));\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        if (globalSettings.hasOwnProperty(prop)) {\n            delete globalSettings[prop];\n            return storage.saveSettings(globalSettings);\n        }\n        return when.resolve();\n    },\n\n    available: function() {\n        return (globalSettings !== null);\n    },\n\n    reset: function() {\n        for (var i in userSettings) {\n            /* istanbul ignore else */\n            if (userSettings.hasOwnProperty(i)) {\n                delete persistentSettings[i];\n            }\n        }\n        userSettings = null;\n        globalSettings = null;\n        storage = null;\n    }\n}\n\nmodule.exports = persistentSettings;\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar express = require(\"express\");\nvar bodyParser = require(\"body-parser\");\nvar util = require('util');\nvar path = require('path');\nvar passport = require('passport');\nvar when = require('when');\nvar cors = require('cors');\n\nvar ui = require(\"./ui\");\nvar nodes = require(\"./nodes\");\nvar flows = require(\"./flows\");\nvar flow = require(\"./flow\");\nvar library = require(\"./library\");\nvar info = require(\"./info\");\nvar theme = require(\"./theme\");\nvar locales = require(\"./locales\");\nvar credentials = require(\"./credentials\");\nvar comms = require(\"./comms\");\n\nvar auth = require(\"./auth\");\nvar needsPermission = auth.needsPermission;\n\nvar i18n;\nvar log;\nvar adminApp;\nvar server;\nvar runtime;\n\nvar errorHandler = function(err,req,res,next) {\n    if (err.message === \"request entity too large\") {\n        log.error(err);\n    } else {\n        console.log(err.stack);\n    }\n    log.audit({event: \"api.error\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n    res.status(400).json({error:\"unexpected_error\", message:err.toString()});\n};\n\nvar ensureRuntimeStarted = function(req,res,next) {\n    if (!runtime.isStarted()) {\n        log.error(\"Node-RED runtime not started\");\n        res.status(503).send(\"Not started\");\n    } else {\n        next();\n    }\n}\n\nfunction init(_server,_runtime) {\n    server = _server;\n    runtime = _runtime;\n    var settings = runtime.settings;\n    i18n = runtime.i18n;\n    log = runtime.log;\n    if (settings.httpAdminRoot !== false) {\n        comms.init(server,runtime);\n        adminApp = express();\n        auth.init(runtime);\n        credentials.init(runtime);\n        flows.init(runtime);\n        flow.init(runtime);\n        info.init(runtime);\n        library.init(adminApp,runtime);\n        locales.init(runtime);\n        nodes.init(runtime);\n\n        // Editor\n        if (!settings.disableEditor) {\n            ui.init(runtime);\n            var editorApp = express();\n            if (settings.requireHttps === true) {\n                editorApp.enable('trust proxy');\n                editorApp.use(function (req, res, next) {\n                    if (req.secure) {\n                        next();\n                    } else {\n                        res.redirect('https://' + req.headers.host + req.originalUrl);\n                    }\n                });\n            }\n            editorApp.get(\"/\",ensureRuntimeStarted,ui.ensureSlash,ui.editor);\n            editorApp.get(\"/icons/:icon\",ui.icon);\n            theme.init(runtime);\n            if (settings.editorTheme) {\n                editorApp.use(\"/theme\",theme.app());\n            }\n            editorApp.use(\"/\",ui.editorResources);\n            adminApp.use(editorApp);\n        }\n        var maxApiRequestSize = settings.apiMaxLength || '5mb';\n        adminApp.use(bodyParser.json({limit:maxApiRequestSize}));\n        adminApp.use(bodyParser.urlencoded({limit:maxApiRequestSize,extended:true}));\n\n        adminApp.get(\"/auth/login\",auth.login,errorHandler);\n\n        if (settings.adminAuth) {\n            //TODO: all passport references ought to be in ./auth\n            adminApp.use(passport.initialize());\n            adminApp.post(\"/auth/token\",\n                auth.ensureClientSecret,\n                auth.authenticateClient,\n                auth.getToken,\n                auth.errorHandler\n            );\n            adminApp.post(\"/auth/revoke\",needsPermission(\"\"),auth.revoke,errorHandler);\n        }\n        if (settings.httpAdminCors) {\n            var corsHandler = cors(settings.httpAdminCors);\n            adminApp.use(corsHandler);\n        }\n\n        // Flows\n        adminApp.get(\"/flows\",needsPermission(\"flows.read\"),flows.get,errorHandler);\n        adminApp.post(\"/flows\",needsPermission(\"flows.write\"),flows.post,errorHandler);\n\n        adminApp.get(\"/flow/:id\",needsPermission(\"flows.read\"),flow.get,errorHandler);\n        adminApp.post(\"/flow\",needsPermission(\"flows.write\"),flow.post,errorHandler);\n        adminApp.delete(\"/flow/:id\",needsPermission(\"flows.write\"),flow.delete,errorHandler);\n        adminApp.put(\"/flow/:id\",needsPermission(\"flows.write\"),flow.put,errorHandler);\n\n        // Nodes\n        adminApp.get(\"/nodes\",needsPermission(\"nodes.read\"),nodes.getAll,errorHandler);\n        adminApp.post(\"/nodes\",needsPermission(\"nodes.write\"),nodes.post,errorHandler);\n\n        adminApp.get(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.read\"),nodes.getModule,errorHandler);\n        adminApp.put(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.putModule,errorHandler);\n        adminApp.delete(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.delete,errorHandler);\n\n        adminApp.get(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)\\/([^\\/]+)$/,needsPermission(\"nodes.read\"),nodes.getSet,errorHandler);\n        adminApp.put(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)\\/([^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.putSet,errorHandler);\n\n        adminApp.get('/credentials/:type/:id', needsPermission(\"credentials.read\"),credentials.get,errorHandler);\n\n        adminApp.get(/locales\\/(.+)\\/?$/,locales.get,errorHandler);\n\n        // Library\n        adminApp.post(new RegExp(\"/library/flows\\/(.*)\"),needsPermission(\"library.write\"),library.post,errorHandler);\n        adminApp.get(\"/library/flows\",needsPermission(\"library.read\"),library.getAll,errorHandler);\n        adminApp.get(new RegExp(\"/library/flows\\/(.*)\"),needsPermission(\"library.read\"),library.get,errorHandler);\n\n        // Settings\n        adminApp.get(\"/settings\",needsPermission(\"settings.read\"),info.settings,errorHandler);\n\n        // Error Handler\n        //adminApp.use(errorHandler);\n    }\n}\nfunction start() {\n    var catalogPath = path.resolve(path.join(__dirname,\"locales\"));\n    return i18n.registerMessageCatalogs([\n        {namespace: \"editor\",   dir: catalogPath, file:\"editor.json\"},\n        {namespace: \"jsonata\",  dir: catalogPath, file:\"jsonata.json\"},\n        {namespace: \"infotips\", dir: catalogPath, file:\"infotips.json\"}\n    ]).then(function(){\n        comms.start();\n    });\n}\nfunction stop() {\n    comms.stop();\n    return when.resolve();\n}\nmodule.exports = {\n    init: init,\n    start: start,\n    stop: stop,\n    library: {\n        register: library.register\n    },\n    auth: {\n        needsPermission: auth.needsPermission\n    },\n    comms: {\n        publish: comms.publish\n    },\n    get adminApp() { return adminApp; },\n    get server() { return server; }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/ui.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar express = require('express');\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar theme = require(\"./theme\");\n\nvar Mustache = require(\"mustache\");\n\nvar icon_paths = [path.resolve(__dirname + '/../../public/icons')];\nvar iconCache = {};\n//TODO: create a default icon\nvar defaultIcon = path.resolve(__dirname + '/../../public/icons/arrow-in.png');\nvar templateDir = path.resolve(__dirname+\"/../../editor/templates\");\nvar editorTemplate;\n\nfunction nodeIconDir(dir) {\n    icon_paths.push(path.resolve(dir));\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        editorTemplate = fs.readFileSync(path.join(templateDir,\"index.mst\"),\"utf8\");\n        Mustache.parse(editorTemplate);\n        // TODO: this allows init to be called multiple times without\n        //       registering multiple instances of the listener.\n        //       It isn't.... ideal.\n        runtime.events.removeListener(\"node-icon-dir\",nodeIconDir);\n        runtime.events.on(\"node-icon-dir\",nodeIconDir);\n    },\n\n    ensureSlash: function(req,res,next) {\n        var parts = req.originalUrl.split(\"?\");\n        if (parts[0].slice(-1) != \"/\") {\n            parts[0] += \"/\";\n            var redirect = parts.join(\"?\");\n            res.redirect(301,redirect);\n        } else {\n            next();\n        }\n    },\n    icon: function(req,res) {\n        if (iconCache[req.params.icon]) {\n            res.sendFile(iconCache[req.params.icon]); // if not found, express prints this to the console and serves 404\n        } else {\n            for (var p=0;p<icon_paths.length;p++) {\n                var iconPath = path.join(icon_paths[p],req.params.icon);\n                try {\n                    fs.statSync(iconPath);\n                    res.sendFile(iconPath);\n                    iconCache[req.params.icon] = iconPath;\n                    return;\n                } catch(err) {\n                    // iconPath doesn't exist\n                }\n            }\n            res.sendFile(defaultIcon);\n        }\n    },\n    editor: function(req,res) {\n        res.send(Mustache.render(editorTemplate,theme.context()));\n    },\n    editorResources: express.static(__dirname + '/../../public')\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/theme.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar express = require(\"express\");\nvar util = require(\"util\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar clone = require(\"clone\");\n\nvar defaultContext = {\n    page: {\n        title: \"Node-RED\",\n        favicon: \"favicon.ico\",\n        tabicon: \"red/images/node-red-icon-black.svg\"\n    },\n    header: {\n        title: \"Node-RED\",\n        image: \"red/images/node-red.png\"\n    },\n    asset: {\n        red: (process.env.NODE_ENV == \"development\")? \"red/red.js\":\"red/red.min.js\",\n        main: (process.env.NODE_ENV == \"development\")? \"red/main.js\":\"red/main.min.js\",\n\n    }\n};\n\nvar theme = null;\nvar themeContext = clone(defaultContext);\nvar themeSettings = null;\nvar runtime = null;\n\nfunction serveFile(app,baseUrl,file) {\n    try {\n        var stats = fs.statSync(file);\n        var url = baseUrl+path.basename(file);\n        //console.log(url,\"->\",file);\n        app.get(url,function(req, res) {\n            res.sendFile(file);\n        });\n        return \"theme\"+url;\n    } catch(err) {\n        //TODO: log filenotfound\n        return null;\n    }\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        var settings = runtime.settings;\n        themeContext = clone(defaultContext);\n        if (runtime.version) {\n            themeContext.version = runtime.version();\n        }\n        themeSettings = null;\n        theme = settings.editorTheme;\n    },\n\n    app: function() {\n        var i;\n        var url;\n        themeSettings = {};\n\n        var themeApp = express();\n\n        if (theme.page) {\n            if (theme.page.css) {\n                var styles = theme.page.css;\n                if (!util.isArray(styles)) {\n                    styles = [styles];\n                }\n                themeContext.page.css = [];\n\n                for (i=0;i<styles.length;i++) {\n                    url = serveFile(themeApp,\"/css/\",styles[i]);\n                    if (url) {\n                        themeContext.page.css.push(url);\n                    }\n                }\n            }\n\n            if (theme.page.favicon) {\n                url = serveFile(themeApp,\"/favicon/\",theme.page.favicon)\n                if (url) {\n                    themeContext.page.favicon = url;\n                }\n            }\n\n            if (theme.page.tabicon) {\n                url = serveFile(themeApp,\"/tabicon/\",theme.page.tabicon)\n                if (url) {\n                    themeContext.page.tabicon = url;\n                }\n            }\n\n            themeContext.page.title = theme.page.title || themeContext.page.title;\n        }\n\n        if (theme.header) {\n\n            themeContext.header.title = theme.header.title || themeContext.header.title;\n\n            if (theme.header.hasOwnProperty(\"url\")) {\n                themeContext.header.url = theme.header.url;\n            }\n\n            if (theme.header.hasOwnProperty(\"image\")) {\n                if (theme.header.image) {\n                    url = serveFile(themeApp,\"/header/\",theme.header.image);\n                    if (url) {\n                        themeContext.header.image = url;\n                    }\n                } else {\n                    themeContext.header.image = null;\n                }\n            }\n        }\n\n        if (theme.deployButton) {\n            if (theme.deployButton.type == \"simple\") {\n                themeSettings.deployButton = {\n                    type: \"simple\"\n                }\n                if (theme.deployButton.label) {\n                    themeSettings.deployButton.label = theme.deployButton.label;\n                }\n                if (theme.deployButton.icon) {\n                    url = serveFile(themeApp,\"/deploy/\",theme.deployButton.icon);\n                    if (url) {\n                        themeSettings.deployButton.icon = url;\n                    }\n                }\n            }\n        }\n\n        if (theme.hasOwnProperty(\"userMenu\")) {\n            themeSettings.userMenu = theme.userMenu;\n        }\n\n        if (theme.login) {\n            if (theme.login.image) {\n                url = serveFile(themeApp,\"/login/\",theme.login.image);\n                if (url) {\n                    themeContext.login = {\n                        image: url\n                    }\n                }\n            }\n        }\n\n        if (theme.hasOwnProperty(\"menu\")) {\n            themeSettings.menu = theme.menu;\n        }\n\n        if (theme.hasOwnProperty(\"palette\")) {\n            themeSettings.palette = theme.palette;\n        }\n        return themeApp;\n    },\n    context: function() {\n        return themeContext;\n    },\n    settings: function() {\n        return themeSettings;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/nodes.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar comms = require(\"./comms\");\nvar locales = require(\"./locales\");\nvar redNodes;\nvar log;\nvar i18n;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        redNodes = runtime.nodes;\n        log = runtime.log;\n        i18n = runtime.i18n;\n        settings = runtime.settings;\n    },\n    getAll: function(req,res) {\n        if (req.get(\"accept\") == \"application/json\") {\n            log.audit({event: \"nodes.list.get\"},req);\n            res.json(redNodes.getNodeList());\n        } else {\n            var lang = locales.determineLangFromHeaders(req.acceptsLanguages());\n            log.audit({event: \"nodes.configs.get\"},req);\n            res.send(redNodes.getNodeConfigs(lang));\n        }\n    },\n\n    post: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.install\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var node = req.body;\n        var promise;\n        if (node.module) {\n            var module = redNodes.getModuleInfo(node.module);\n            if (module) {\n                log.audit({event: \"nodes.install\",module:node.module,error:\"module_already_loaded\"},req);\n                res.status(400).json({error:\"module_already_loaded\", message:\"Module already loaded\"});\n                return;\n            }\n            promise = redNodes.installModule(node.module);\n        } else {\n            log.audit({event: \"nodes.install\",module:node.module,error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        promise.then(function(info) {\n            comms.publish(\"node/added\",info.nodes,false);\n            if (node.module) {\n                log.audit({event: \"nodes.install\",module:node.module},req);\n                res.json(info);\n            }\n        }).otherwise(function(err) {\n            if (err.code === 404) {\n                log.audit({event: \"nodes.install\",module:node.module,error:\"not_found\"},req);\n                res.status(404).end();\n            } else if (err.code) {\n                log.audit({event: \"nodes.install\",module:node.module,error:err.code},req);\n                res.status(400).json({error:err.code, message:err.message});\n            } else {\n                log.audit({event: \"nodes.install\",module:node.module,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        });\n    },\n\n    delete: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.remove\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var mod = req.params[0];\n        try {\n            var promise = null;\n            var module = redNodes.getModuleInfo(mod);\n            if (!module) {\n                log.audit({event: \"nodes.remove\",module:mod,error:\"not_found\"},req);\n                res.status(404).end();\n                return;\n            } else {\n                promise = redNodes.uninstallModule(mod);\n            }\n\n            promise.then(function(list) {\n                comms.publish(\"node/removed\",list,false);\n                log.audit({event: \"nodes.remove\",module:mod},req);\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.audit({event: \"nodes.remove\",module:mod,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            });\n        } catch(err) {\n            log.audit({event: \"nodes.remove\",module:mod,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    },\n\n    getSet: function(req,res) {\n        var id = req.params[0] + \"/\" + req.params[2];\n        var result = null;\n        if (req.get(\"accept\") === \"application/json\") {\n            result = redNodes.getNodeInfo(id);\n            if (result) {\n                log.audit({event: \"nodes.info.get\",id:id},req);\n                delete result.loaded;\n                res.send(result);\n            } else {\n                log.audit({event: \"nodes.info.get\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            }\n        } else {\n            var lang = locales.determineLangFromHeaders(req.acceptsLanguages());\n            result = redNodes.getNodeConfig(id,lang);\n            if (result) {\n                log.audit({event: \"nodes.config.get\",id:id},req);\n                res.send(result);\n            } else {\n                log.audit({event: \"nodes.config.get\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            }\n        }\n    },\n\n    getModule: function(req,res) {\n        var module = req.params[0];\n        var result = redNodes.getModuleInfo(module);\n        if (result) {\n            log.audit({event: \"nodes.module.get\",module:module},req);\n            res.json(result);\n        } else {\n            log.audit({event: \"nodes.module.get\",module:module,error:\"not_found\"},req);\n            res.status(404).end();\n        }\n    },\n\n    putSet: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.info.set\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var body = req.body;\n        if (!body.hasOwnProperty(\"enabled\")) {\n            log.audit({event: \"nodes.info.set\",error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        var id = req.params[0] + \"/\" + req.params[2];\n        try {\n            var node = redNodes.getNodeInfo(id);\n            var info;\n            if (!node) {\n                log.audit({event: \"nodes.info.set\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                delete node.loaded;\n                putNode(node, body.enabled).then(function(result) {\n                    log.audit({event: \"nodes.info.set\",id:id,enabled:body.enabled},req);\n                    res.json(result);\n                });\n            }\n        } catch(err) {\n            log.audit({event: \"nodes.info.set\",id:id,enabled:body.enabled,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    },\n\n    putModule: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.module.set\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var body = req.body;\n        if (!body.hasOwnProperty(\"enabled\")) {\n            log.audit({event: \"nodes.module.set\",error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        var mod = req.params[0];\n        try {\n            var module = redNodes.getModuleInfo(mod);\n            if (!module) {\n                log.audit({event: \"nodes.module.set\",module:mod,error:\"not_found\"},req);\n                return res.status(404).end();\n            }\n\n            var nodes = module.nodes;\n            var promises = [];\n            for (var i = 0; i < nodes.length; ++i) {\n                promises.push(putNode(nodes[i],body.enabled));\n            }\n            when.settle(promises).then(function() {\n                res.json(redNodes.getModuleInfo(mod));\n            });\n        } catch(err) {\n            log.audit({event: \"nodes.module.set\",module:mod,enabled:body.enabled,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    }\n};\n\nfunction putNode(node, enabled) {\n    var info;\n    var promise;\n    if (!node.err && node.enabled === enabled) {\n        promise = when.resolve(node);\n    } else {\n        if (enabled) {\n            promise = redNodes.enableNode(node.id);\n        } else {\n            promise = redNodes.disableNode(node.id);\n        }\n\n        return promise.then(function(info) {\n            if (info.enabled === enabled && !info.err) {\n                comms.publish(\"node/\"+(enabled?\"enabled\":\"disabled\"),info,false);\n                log.info(\" \"+log._(\"api.nodes.\"+(enabled?\"enabled\":\"disabled\")));\n                for (var i=0;i<info.types.length;i++) {\n                    log.info(\" - \"+info.types[i]);\n                }\n            } else if (enabled && info.err) {\n            log.warn(log._(\"api.nodes.error-enable\"));\n                log.warn(\" - \"+info.name+\" : \"+info.err);\n            }\n            return info;\n        });\n    }\n\n    return promise;\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/comms.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar ws = require(\"ws\");\nvar log;\n\nvar server;\nvar settings;\n\nvar wsServer;\nvar pendingConnections = [];\nvar activeConnections = [];\n\nvar retained = {};\n\nvar heartbeatTimer;\nvar lastSentTime;\n\nfunction handleStatus(event) {\n    publish(\"status/\"+event.id,event.status,true);\n}\nfunction handleRuntimeEvent(event) {\n    publish(\"notification/\"+event.id,event,true);\n}\nfunction init(_server,runtime) {\n    server = _server;\n    settings = runtime.settings;\n    log = runtime.log;\n\n    runtime.events.removeListener(\"node-status\",handleStatus);\n    runtime.events.on(\"node-status\",handleStatus);\n\n    runtime.events.removeListener(\"runtime-event\",handleRuntimeEvent);\n    runtime.events.on(\"runtime-event\",handleRuntimeEvent);\n}\n\nfunction start() {\n    var Tokens = require(\"./auth/tokens\");\n    var Users = require(\"./auth/users\");\n    var Permissions = require(\"./auth/permissions\");\n    if (!settings.disableEditor) {\n        Users.default().then(function(anonymousUser) {\n            var webSocketKeepAliveTime = settings.webSocketKeepAliveTime || 15000;\n            var path = settings.httpAdminRoot || \"/\";\n            path = (path.slice(0,1) != \"/\" ? \"/\":\"\") + path + (path.slice(-1) == \"/\" ? \"\":\"/\") + \"comms\";\n            wsServer = new ws.Server({\n                server:server,\n                path:path,\n                // Disable the deflate option due to this issue\n                //  https://github.com/websockets/ws/pull/632\n                // that is fixed in the 1.x release of the ws module\n                // that we cannot currently pickup as it drops node 0.10 support\n                perMessageDeflate: false\n            });\n\n            wsServer.on('connection',function(ws) {\n                log.audit({event: \"comms.open\"});\n                var pendingAuth = (settings.adminAuth != null);\n                if (!pendingAuth) {\n                    activeConnections.push(ws);\n                } else {\n                    pendingConnections.push(ws);\n                }\n                ws.on('close',function() {\n                    log.audit({event: \"comms.close\",user:ws.user});\n                    removeActiveConnection(ws);\n                    removePendingConnection(ws);\n                });\n                ws.on('message', function(data,flags) {\n                    var msg = null;\n                    try {\n                        msg = JSON.parse(data);\n                    } catch(err) {\n                        log.trace(\"comms received malformed message : \"+err.toString());\n                        return;\n                    }\n                    if (!pendingAuth) {\n                        if (msg.subscribe) {\n                            handleRemoteSubscription(ws,msg.subscribe);\n                        }\n                    } else {\n                        var completeConnection = function(userScope,sendAck) {\n                            try {\n                                if (!userScope || !Permissions.hasPermission(userScope,\"status.read\")) {\n                                    ws.send(JSON.stringify({auth:\"fail\"}));\n                                    ws.close();\n                                } else {\n                                    pendingAuth = false;\n                                    removePendingConnection(ws);\n                                    activeConnections.push(ws);\n                                    if (sendAck) {\n                                        ws.send(JSON.stringify({auth:\"ok\"}));\n                                    }\n                                }\n                            } catch(err) {\n                                // Just in case the socket closes before we attempt\n                                // to send anything.\n                            }\n                        }\n                        if (msg.auth) {\n                            Tokens.get(msg.auth).then(function(client) {\n                                if (client) {\n                                    Users.get(client.user).then(function(user) {\n                                        if (user) {\n                                            ws.user = user;\n                                            log.audit({event: \"comms.auth\",user:ws.user});\n                                            completeConnection(client.scope,true);\n                                        } else {\n                                            log.audit({event: \"comms.auth.fail\"});\n                                            completeConnection(null,false);\n                                        }\n                                    });\n                                } else {\n                                    log.audit({event: \"comms.auth.fail\"});\n                                    completeConnection(null,false);\n                                }\n                            });\n                        } else {\n                            if (anonymousUser) {\n                                log.audit({event: \"comms.auth\",user:anonymousUser});\n                                completeConnection(anonymousUser.permissions,false);\n                            } else {\n                                log.audit({event: \"comms.auth.fail\"});\n                                completeConnection(null,false);\n                            }\n                            //TODO: duplicated code - pull non-auth message handling out\n                            if (msg.subscribe) {\n                                handleRemoteSubscription(ws,msg.subscribe);\n                            }\n                        }\n                    }\n                });\n                ws.on('error', function(err) {\n                    log.warn(log._(\"comms.error\",{message:err.toString()}));\n                });\n            });\n\n            wsServer.on('error', function(err) {\n                log.warn(log._(\"comms.error-server\",{message:err.toString()}));\n            });\n\n            lastSentTime = Date.now();\n\n            heartbeatTimer = setInterval(function() {\n                var now = Date.now();\n                if (now-lastSentTime > webSocketKeepAliveTime) {\n                    publish(\"hb\",lastSentTime);\n                }\n            }, webSocketKeepAliveTime);\n        });\n    }\n}\n\nfunction stop() {\n    if (heartbeatTimer) {\n        clearInterval(heartbeatTimer);\n        heartbeatTimer = null;\n    }\n    if (wsServer) {\n        wsServer.close();\n        wsServer = null;\n    }\n}\n\nfunction publish(topic,data,retain) {\n    if (server) {\n        if (retain) {\n            retained[topic] = data;\n        } else {\n            delete retained[topic];\n        }\n        lastSentTime = Date.now();\n        activeConnections.forEach(function(conn) {\n            publishTo(conn,topic,data);\n        });\n    }\n}\n\nfunction publishTo(ws,topic,data) {\n    var msg = JSON.stringify({topic:topic,data:data});\n    try {\n        ws.send(msg);\n    } catch(err) {\n        removeActiveConnection(ws);\n        removePendingConnection(ws);\n        log.warn(log._(\"comms.error-send\",{message:err.toString()}));\n    }\n}\n\nfunction handleRemoteSubscription(ws,topic) {\n    var re = new RegExp(\"^\"+topic.replace(/([\\[\\]\\?\\(\\)\\\\\\\\$\\^\\*\\.|])/g,\"\\\\$1\").replace(/\\+/g,\"[^/]+\").replace(/\\/#$/,\"(\\/.*)?\")+\"$\");\n    for (var t in retained) {\n        if (re.test(t)) {\n            publishTo(ws,t,retained[t]);\n        }\n    }\n}\n\nfunction removeActiveConnection(ws) {\n    for (var i=0;i<activeConnections.length;i++) {\n        if (activeConnections[i] === ws) {\n            activeConnections.splice(i,1);\n            break;\n        }\n    }\n}\nfunction removePendingConnection(ws) {\n    for (var i=0;i<pendingConnections.length;i++) {\n        if (pendingConnections[i] === ws) {\n            pendingConnections.splice(i,1);\n            break;\n        }\n    }\n}\n\nmodule.exports = {\n    init:init,\n    start:start,\n    stop:stop,\n    publish:publish\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/locales.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar fs = require('fs');\nvar path = require('path');\nvar i18n;\nvar supportedLangs = [];\n\nvar apiLocalDir = path.resolve(path.join(__dirname,\"locales\"));\n\nvar initSupportedLangs = function() {\n    fs.readdir(apiLocalDir, function(err,files) {\n        if(!err) {\n            supportedLangs = files;\n        }\n    });\n}\n\nfunction determineLangFromHeaders(acceptedLanguages){\n    var lang = i18n.defaultLang;\n    acceptedLanguages = acceptedLanguages || [];\n    for (var i=0;i<acceptedLanguages.length;i++){\n        if (supportedLangs.indexOf(acceptedLanguages[i]) !== -1){\n            lang = acceptedLanguages[i];\n            break;\n        // check the language without the country code\n        } else if (supportedLangs.indexOf(acceptedLanguages[i].split(\"-\")[0]) !== -1) {\n            lang = acceptedLanguages[i].split(\"-\")[0];\n            break;\n        }\n    }\n    return lang;\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        i18n = runtime.i18n;\n        initSupportedLangs();\n    },\n    get: function(req,res) {\n        var namespace = req.params[0];\n        namespace = namespace.replace(/\\.json$/,\"\");\n        var lang = determineLangFromHeaders(req.acceptsLanguages() || []);\n        var prevLang = i18n.i.lng();\n        i18n.i.setLng(lang, function(){\n            var catalog = i18n.catalog(namespace,lang);\n            res.json(catalog||{});\n        });\n        i18n.i.setLng(prevLang);\n    },\n    determineLangFromHeaders: determineLangFromHeaders\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/flows.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar redNodes;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        settings = runtime.settings;\n        redNodes = runtime.nodes;\n        log = runtime.log;\n    },\n    get: function(req,res) {\n        var version = req.get(\"Node-RED-API-Version\")||\"v1\";\n        if (version === \"v1\") {\n            log.audit({event: \"flows.get\",version:\"v1\"},req);\n            res.json(redNodes.getFlows().flows);\n        } else if (version === \"v2\") {\n            log.audit({event: \"flows.get\",version:\"v2\"},req);\n            res.json(redNodes.getFlows());\n        } else {\n            log.audit({event: \"flows.get\",version:version,error:\"invalid_api_version\"},req);\n            res.status(400).json({code:\"invalid_api_version\", message:\"Invalid API Version requested\"});\n        }\n    },\n    post: function(req,res) {\n        var version = req.get(\"Node-RED-API-Version\")||\"v1\";\n        var flows = req.body;\n        var deploymentType = req.get(\"Node-RED-Deployment-Type\")||\"full\";\n        log.audit({event: \"flows.set\",type:deploymentType,version:version},req);\n        if (deploymentType === 'reload') {\n            redNodes.loadFlows().then(function() {\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.flows.error-reload\",{message:err.message}));\n                log.warn(err.stack);\n                res.status(500).json({error:\"unexpected_error\", message:err.message});\n            });\n        } else {\n            var flowConfig = flows;\n            if (version === \"v2\") {\n                flowConfig = flows.flows;\n                if (flows.hasOwnProperty('rev')) {\n                    var currentVersion = redNodes.getFlows().rev;\n                    if (currentVersion !== flows.rev) {\n                        //TODO: log warning\n                        return res.status(409).json({code:\"version_mismatch\"});\n                    }\n                }\n            } else if (version !== 'v1') {\n                log.audit({event: \"flows.set\",version:version,error:\"invalid_api_version\"},req);\n                res.status(400).json({code:\"invalid_api_version\", message:\"Invalid API Version requested\"});\n            }\n            redNodes.setFlows(flowConfig,deploymentType).then(function(flowId) {\n                if (version === \"v1\") {\n                    res.status(204).end();\n                } else if (version === \"v2\") {\n                    res.json({rev:flowId});\n                } else {\n                    // TODO: invalid version\n                }\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.flows.error-save\",{message:err.message}));\n                log.warn(err.stack);\n                res.status(500).json({error:\"unexpected_error\", message:err.message});\n            });\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/flow.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar redNodes;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        settings = runtime.settings;\n        redNodes = runtime.nodes;\n        log = runtime.log;\n    },\n    get: function(req,res) {\n        var id = req.params.id;\n        var flow = redNodes.getFlow(id);\n        if (flow) {\n            log.audit({event: \"flow.get\",id:id},req);\n            res.json(flow);\n        } else {\n            log.audit({event: \"flow.get\",id:id,error:\"not_found\"},req);\n            res.status(404).end();\n        }\n    },\n    post: function(req,res) {\n        var flow = req.body;\n        redNodes.addFlow(flow).then(function(id) {\n            log.audit({event: \"flow.add\",id:id},req);\n            res.json({id:id});\n        }).otherwise(function(err) {\n            log.audit({event: \"flow.add\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        })\n\n    },\n    put: function(req,res) {\n        var id = req.params.id;\n        var flow = req.body;\n        try {\n            redNodes.updateFlow(id,flow).then(function() {\n                log.audit({event: \"flow.update\",id:id},req);\n                res.json({id:id});\n            }).otherwise(function(err) {\n                log.audit({event: \"flow.update\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            })\n        } catch(err) {\n            if (err.code === 404) {\n                log.audit({event: \"flow.update\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                log.audit({event: \"flow.update\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        }\n    },\n    delete: function(req,res) {\n        var id = req.params.id;\n        try {\n            redNodes.removeFlow(id).then(function() {\n                log.audit({event: \"flow.remove\",id:id},req);\n                res.status(204).end();\n            })\n        } catch(err) {\n            if (err.code === 404) {\n                log.audit({event: \"flow.remove\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                log.audit({event: \"flow.remove\",id:id,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/library.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar fs = require('fs');\nvar fspath = require('path');\nvar when = require('when');\n\nvar redApp = null;\nvar storage;\nvar log;\nvar needsPermission = require(\"./auth\").needsPermission;\n\nfunction createLibrary(type) {\n    if (redApp) {\n        redApp.get(new RegExp(\"/library/\"+type+\"($|\\/(.*))\"),needsPermission(\"library.read\"),function(req,res) {\n            var path = req.params[1]||\"\";\n            storage.getLibraryEntry(type,path).then(function(result) {\n                log.audit({event: \"library.get\",type:type},req);\n                if (typeof result === \"string\") {\n                    res.writeHead(200, {'Content-Type': 'text/plain'});\n                    res.write(result);\n                    res.end();\n                } else {\n                    res.json(result);\n                }\n            }).otherwise(function(err) {\n                if (err) {\n                    log.warn(log._(\"api.library.error-load-entry\",{path:path,message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                        log.audit({event: \"library.get\",type:type,error:\"forbidden\"},req);\n                        res.status(403).end();\n                        return;\n                    }\n                }\n                log.audit({event: \"library.get\",type:type,error:\"not_found\"},req);\n                res.status(404).end();\n            });\n        });\n\n        redApp.post(new RegExp(\"/library/\"+type+\"\\/(.*)\"),needsPermission(\"library.write\"),function(req,res) {\n            var path = req.params[0];\n            var meta = req.body;\n            var text = meta.text;\n            delete meta.text;\n\n            storage.saveLibraryEntry(type,path,meta,text).then(function() {\n                log.audit({event: \"library.set\",type:type},req);\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.library.error-save-entry\",{path:path,message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                    log.audit({event: \"library.set\",type:type,error:\"forbidden\"},req);\n                    res.status(403).end();\n                    return;\n                }\n                log.audit({event: \"library.set\",type:type,error:\"unexpected_error\",message:err.toString()},req);\n                res.status(500).json({error:\"unexpected_error\", message:err.toString()});\n            });\n        });\n    }\n}\n\nvar exampleRoots = {};\nvar exampleFlows = {d:{}};\nvar exampleCount = 0;\n\nfunction getFlowsFromPath(path) {\n    return when.promise(function(resolve,reject) {\n        var result = {};\n        fs.readdir(path,function(err,files) {\n            var promises = [];\n            var validFiles = [];\n            files.forEach(function(file) {\n                var fullPath = fspath.join(path,file);\n                var stats = fs.lstatSync(fullPath);\n                if (stats.isDirectory()) {\n                    validFiles.push(file);\n                    promises.push(getFlowsFromPath(fullPath));\n                } else if (/\\.json$/.test(file)){\n                    validFiles.push(file);\n                    exampleCount++;\n                    promises.push(when.resolve(file.split(\".\")[0]))\n                }\n            })\n            var i=0;\n            when.all(promises).then(function(results) {\n                results.forEach(function(r) {\n                    if (typeof r === 'string') {\n                        result.f = result.f||[];\n                        result.f.push(r);\n                    } else {\n                        result.d = result.d||{};\n                        result.d[validFiles[i]] = r;\n                    }\n                    i++;\n                })\n\n                resolve(result);\n            })\n        });\n    })\n}\n\nfunction addNodeExamplesDir(module) {\n    exampleRoots[module.name] = module.path;\n    getFlowsFromPath(module.path).then(function(result) {\n        exampleFlows.d[module.name] = result;\n    });\n}\nfunction removeNodeExamplesDir(module) {\n    delete exampleRoots[module];\n    delete exampleFlows.d[module];\n}\n\nmodule.exports = {\n    init: function(app,runtime) {\n        redApp = app;\n        log = runtime.log;\n        storage = runtime.storage;\n        // TODO: this allows init to be called multiple times without\n        //       registering multiple instances of the listener.\n        //       It isn't.... ideal.\n        runtime.events.removeListener(\"node-examples-dir\",addNodeExamplesDir);\n        runtime.events.on(\"node-examples-dir\",addNodeExamplesDir);\n        runtime.events.removeListener(\"node-module-uninstalled\",removeNodeExamplesDir);\n        runtime.events.on(\"node-module-uninstalled\",removeNodeExamplesDir);\n\n    },\n    register: createLibrary,\n\n    getAll: function(req,res) {\n        storage.getAllFlows().then(function(flows) {\n            log.audit({event: \"library.get.all\",type:\"flow\"},req);\n            if (exampleCount > 0) {\n                flows.d = flows.d||{};\n                flows.d._examples_ = exampleFlows;\n            }\n            res.json(flows);\n        });\n    },\n    get: function(req,res) {\n        if (req.params[0].indexOf(\"_examples_/\") === 0) {\n            var m = /^_examples_\\/([^\\/]+)\\/(.*)$/.exec(req.params[0]);\n            if (m) {\n                var module = m[1];\n                var path = m[2]+\".json\";\n                if (exampleRoots[module]) {\n                    var fullPath = fspath.join(exampleRoots[module],path);\n                    try {\n                        fs.statSync(fullPath);\n                        log.audit({event: \"library.get\",type:\"flow\",path:req.params[0]},req);\n                        return res.sendFile(fullPath,{\n                            headers:{\n                                'Content-Type': 'application/json'\n                            }\n                        })\n                    } catch(err) {\n                        console.log(err);\n                    }\n                }\n            }\n            // IF we get here, we didn't find the file\n            log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"not_found\"},req);\n            return res.status(404).end();\n        } else {\n            storage.getFlow(req.params[0]).then(function(data) {\n                // data is already a JSON string\n                log.audit({event: \"library.get\",type:\"flow\",path:req.params[0]},req);\n                res.set('Content-Type', 'application/json');\n                res.send(data);\n            }).otherwise(function(err) {\n                if (err) {\n                    log.warn(log._(\"api.library.error-load-flow\",{path:req.params[0],message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                        log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n                        res.status(403).end();\n                        return;\n                    }\n                }\n                log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"not_found\"},req);\n                res.status(404).end();\n            });\n        }\n    },\n    post: function(req,res) {\n        // if (req.params[0].indexOf(\"_examples_/\") === 0) {\n        //     log.warn(log._(\"api.library.error-save-flow\",{path:req.params[0],message:\"forbidden\"}));\n        //     log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n        //     return res.status(403).send({error:\"unexpected_error\", message:\"forbidden\"});\n        // }\n        var flow = JSON.stringify(req.body);\n        storage.saveFlow(req.params[0],flow).then(function() {\n            log.audit({event: \"library.set\",type:\"flow\",path:req.params[0]},req);\n            res.status(204).end();\n        }).otherwise(function(err) {\n            log.warn(log._(\"api.library.error-save-flow\",{path:req.params[0],message:err.toString()}));\n            if (err.code === 'forbidden') {\n                log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n                res.status(403).end();\n                return;\n            }\n            log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"unexpected_error\",message:err.toString()},req);\n            res.status(500).send({error:\"unexpected_error\", message:err.toString()});\n        });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar passport = require(\"passport\");\nvar oauth2orize = require(\"oauth2orize\");\n\nvar strategies = require(\"./strategies\");\nvar Tokens = require(\"./tokens\");\nvar Users = require(\"./users\");\nvar permissions = require(\"./permissions\");\n\nvar theme = require(\"../theme\");\n\nvar settings = null;\nvar log = null\n\n\npassport.use(strategies.bearerStrategy.BearerStrategy);\npassport.use(strategies.clientPasswordStrategy.ClientPasswordStrategy);\npassport.use(strategies.anonymousStrategy);\n\nvar server = oauth2orize.createServer();\n\nserver.exchange(oauth2orize.exchange.password(strategies.passwordTokenExchange));\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    log = runtime.log;\n    if (settings.adminAuth) {\n        Users.init(settings.adminAuth);\n        Tokens.init(settings.adminAuth,runtime.storage);\n        strategies.init(runtime);\n    }\n}\n\nfunction needsPermission(permission) {\n    return function(req,res,next) {\n        if (settings && settings.adminAuth) {\n            return passport.authenticate(['bearer','anon'],{ session: false })(req,res,function() {\n                if (!req.user) {\n                    return next();\n                }\n                if (permissions.hasPermission(req.authInfo.scope,permission)) {\n                    return next();\n                }\n                log.audit({event: \"permission.fail\", permissions: permission},req);\n                return res.status(401).end();\n            });\n        } else {\n            next();\n        }\n    }\n}\n\nfunction ensureClientSecret(req,res,next) {\n    if (!req.body.client_secret) {\n        req.body.client_secret = 'not_available';\n    }\n    next();\n}\nfunction authenticateClient(req,res,next) {\n    return passport.authenticate(['oauth2-client-password'], {session: false})(req,res,next);\n}\nfunction getToken(req,res,next) {\n    return server.token()(req,res,next);\n}\n\nfunction login(req,res) {\n    var response = {};\n    if (settings.adminAuth) {\n        response = {\n            \"type\":\"credentials\",\n            \"prompts\":[{id:\"username\",type:\"text\",label:\"Username\"},{id:\"password\",type:\"password\",label:\"Password\"}]\n        }\n        if (theme.context().login && theme.context().login.image) {\n            response.image = theme.context().login.image;\n        }\n    }\n    res.json(response);\n}\n\nfunction revoke(req,res) {\n    var token = req.body.token;\n    // TODO: audit log\n    Tokens.revoke(token).then(function() {\n        log.audit({event: \"auth.login.revoke\"},req);\n        res.status(200).end();\n    });\n}\n\nmodule.exports = {\n    init: init,\n    needsPermission: needsPermission,\n    ensureClientSecret: ensureClientSecret,\n    authenticateClient: authenticateClient,\n    getToken: getToken,\n    errorHandler: function(err,req,res,next) {\n        //TODO: audit log statment\n        //console.log(err.stack);\n        //log.log({level:\"audit\",type:\"auth\",msg:err.toString()});\n        return server.errorHandler()(err,req,res,next);\n    },\n    login: login,\n    revoke: revoke\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/strategies.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar BearerStrategy = require('passport-http-bearer').Strategy;\nvar ClientPasswordStrategy = require('passport-oauth2-client-password').Strategy;\n\nvar passport = require(\"passport\");\nvar crypto = require(\"crypto\");\nvar util = require(\"util\");\n\nvar Tokens = require(\"./tokens\");\nvar Users = require(\"./users\");\nvar Clients = require(\"./clients\");\nvar permissions = require(\"./permissions\");\n\nvar log;\n\nvar bearerStrategy = function (accessToken, done) {\n    // is this a valid token?\n    Tokens.get(accessToken).then(function(token) {\n        if (token) {\n            Users.get(token.user).then(function(user) {\n                if (user) {\n                    done(null,user,{scope:token.scope});\n                } else {\n                    log.audit({event: \"auth.invalid-token\"});\n                    done(null,false);\n                }\n            });\n        } else {\n            log.audit({event: \"auth.invalid-token\"});\n            done(null,false);\n        }\n    });\n}\nbearerStrategy.BearerStrategy = new BearerStrategy(bearerStrategy);\n\nvar clientPasswordStrategy = function(clientId, clientSecret, done) {\n    Clients.get(clientId).then(function(client) {\n        if (client && client.secret == clientSecret) {\n            done(null,client);\n        } else {\n            log.audit({event: \"auth.invalid-client\",client:clientId});\n            done(null,false);\n        }\n    });\n}\nclientPasswordStrategy.ClientPasswordStrategy = new ClientPasswordStrategy(clientPasswordStrategy);\n\nvar loginAttempts = [];\nvar loginSignInWindow = 600000; // 10 minutes\n\n\nvar passwordTokenExchange = function(client, username, password, scope, done) {\n    var now = Date.now();\n    loginAttempts = loginAttempts.filter(function(logEntry) {\n        return logEntry.time + loginSignInWindow > now;\n    });\n    loginAttempts.push({time:now, user:username});\n    var attemptCount = 0;\n    loginAttempts.forEach(function(logEntry) {\n        /* istanbul ignore else */\n        if (logEntry.user == username) {\n            attemptCount++;\n        }\n    });\n    if (attemptCount > 5) {\n        log.audit({event: \"auth.login.fail.too-many-attempts\",username:username,client:client.id});\n        done(new Error(\"Too many login attempts. Wait 10 minutes and try again\"),false);\n        return;\n    }\n\n    Users.authenticate(username,password).then(function(user) {\n        if (user) {\n            if (scope === \"\") {\n                scope = user.permissions;\n            }\n            if (permissions.hasPermission(user.permissions,scope)) {\n                loginAttempts = loginAttempts.filter(function(logEntry) {\n                    return logEntry.user !== username;\n                });\n                Tokens.create(username,client.id,scope).then(function(tokens) {\n                    log.audit({event: \"auth.login\",username:username,client:client.id,scope:scope});\n                    done(null,tokens.accessToken,null,{expires_in:tokens.expires_in});\n                });\n            } else {\n                log.audit({event: \"auth.login.fail.permissions\",username:username,client:client.id,scope:scope});\n                done(null,false);\n            }\n        } else {\n            log.audit({event: \"auth.login.fail.credentials\",username:username,client:client.id,scope:scope});\n            done(null,false);\n        }\n    });\n}\n\nfunction AnonymousStrategy() {\n  passport.Strategy.call(this);\n  this.name = 'anon';\n}\nutil.inherits(AnonymousStrategy, passport.Strategy);\nAnonymousStrategy.prototype.authenticate = function(req) {\n    var self = this;\n    Users.default().then(function(anon) {\n        if (anon) {\n            self.success(anon,{scope:anon.permissions});\n        } else {\n            self.fail(401);\n        }\n    });\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n    },\n    bearerStrategy: bearerStrategy,\n    clientPasswordStrategy: clientPasswordStrategy,\n    passwordTokenExchange: passwordTokenExchange,\n    anonymousStrategy: new AnonymousStrategy()\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/tokens.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\n\nfunction generateToken(length) {\n    var c = \"ABCDEFGHIJKLMNOPQRSTUZWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n    var token = [];\n    for (var i=0;i<length;i++) {\n        token.push(c[Math.floor(Math.random()*c.length)]);\n    }\n    return token.join(\"\");\n}\n\n\nvar storage;\n\nvar sessionExpiryTime\n\nvar sessions = {};\n\nvar loadedSessions = null;\n\nfunction expireSessions() {\n    var now = Date.now();\n    var modified = false;\n    for (var t in sessions) {\n        if (sessions.hasOwnProperty(t)) {\n            var session = sessions[t];\n            if (!session.hasOwnProperty(\"expires\") || session.expires < now) {\n                delete sessions[t];\n                modified = true;\n            }\n        }\n    }\n    if (modified) {\n        return storage.saveSessions(sessions);\n    } else {\n        return when.resolve();\n    }\n}\nfunction loadSessions() {\n    if (loadedSessions === null) {\n        loadedSessions = storage.getSessions().then(function(_sessions) {\n             sessions = _sessions||{};\n             return expireSessions();\n        });\n    }\n    return loadedSessions;\n}\n\nmodule.exports = {\n    init: function(adminAuthSettings, _storage) {\n        storage = _storage;\n        sessionExpiryTime = adminAuthSettings.sessionExpiryTime || 604800; // 1 week in seconds\n        // At this point, storage will not have been initialised, so defer loading\n        // the sessions until there's a request for them.\n        loadedSessions = null;\n        return when.resolve();\n    },\n    get: function(token) {\n        return loadSessions().then(function() {\n            if (sessions[token]) {\n                if (sessions[token].expires < Date.now()) {\n                    return expireSessions().then(function() { return null });\n                }\n            }\n            return when.resolve(sessions[token]);\n        });\n    },\n    create: function(user,client,scope) {\n        return loadSessions().then(function() {\n            var accessToken = generateToken(128);\n\n            var accessTokenExpiresAt = Date.now() + (sessionExpiryTime*1000);\n\n            var session = {\n                user:user,\n                client:client,\n                scope:scope,\n                accessToken: accessToken,\n                expires: accessTokenExpiresAt\n            };\n            sessions[accessToken] = session;\n            return storage.saveSessions(sessions).then(function() {\n                return {\n                    accessToken: accessToken,\n                    expires_in: sessionExpiryTime\n                }\n            });\n        });\n    },\n    revoke: function(token) {\n        return loadSessions().then(function() {\n            delete sessions[token];\n            return storage.saveSessions(sessions);\n        });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/users.js":"/**\n* Copyright JS Foundation and other contributors, http://js.foundation\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nvar when = require(\"when\");\nvar util = require(\"util\");\nvar bcrypt;\ntry { bcrypt = require('bcrypt'); }\ncatch(e) { bcrypt = require('bcryptjs'); }\nvar users = {};\nvar passwords = {};\nvar defaultUser = null;\n\nfunction authenticate(username,password) {\n    var user = users[username];\n    if (user) {\n        return when.promise(function(resolve,reject) {\n            bcrypt.compare(password, passwords[username], function(err, res) {\n                resolve(res?user:null);\n            });\n        });\n    }\n    return when.resolve(null);\n}\nfunction get(username) {\n    return when.resolve(users[username]);\n}\nfunction getDefaultUser() {\n    return when.resolve(null);\n}\n\nvar api = {\n    get: get,\n    authenticate: authenticate,\n    default: getDefaultUser\n}\n\nfunction init(config) {\n    users = {};\n    passwords = {};\n    defaultUser = null;\n    if (config.type == \"credentials\") {\n        if (config.users) {\n            if (typeof config.users === \"function\") {\n                api.get = config.users;\n            } else {\n                var us = config.users;\n                /* istanbul ignore else */\n                if (!util.isArray(us)) {\n                    us = [us];\n                }\n                for (var i=0;i<us.length;i++) {\n                    var u = us[i];\n                    users[u.username] = {\n                        \"username\":u.username,\n                        \"permissions\":u.permissions\n                    };\n                    passwords[u.username] = u.password;\n                }\n            }\n        }\n        if (config.authenticate && typeof config.authenticate === \"function\") {\n            api.authenticate = config.authenticate;\n        } else {\n            api.authenticate = authenticate;\n        }\n    }\n    if (config.default) {\n        if (typeof config.default === \"function\") {\n            api.default = config.default;\n        } else {\n            api.default = function() {\n                return when.resolve({\n                    \"anonymous\": true,\n                    \"permissions\":config.default.permissions\n                });\n            }\n        }\n    } else {\n        api.default = getDefaultUser;\n    }\n}\n\nmodule.exports = {\n    init: init,\n    get: function(username) { return api.get(username) },\n    authenticate: function(username,password) { return api.authenticate(username,password) },\n    default: function() { return api.default(); }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/clients.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n \nvar when = require(\"when\");\n\nvar clients = [\n    {id:\"node-red-editor\",secret:\"not_available\"},\n    {id:\"node-red-admin\",secret:\"not_available\"}\n];\n\nmodule.exports = {\n    get: function(id) {\n        for (var i=0;i<clients.length;i++) {\n            if (clients[i].id == id) {\n                return when.resolve(clients[i]);\n            }\n        }\n        return when.resolve(null);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/auth/permissions.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require('util');\n\nvar readRE = /^((.+)\\.)?read$/\nvar writeRE = /^((.+)\\.)?write$/\n\nfunction hasPermission(userScope,permission) {\n    if (permission === \"\") {\n        return true;\n    }\n    var i;\n\n    if (util.isArray(permission)) {\n        // Multiple permissions requested - check each one\n        for (i=0;i<permission.length;i++) {\n            if (!hasPermission(userScope,permission[i])) {\n                return false;\n            }\n        }\n        // All permissions check out\n        return true;\n    }\n\n    if (util.isArray(userScope)) {\n        if (userScope.length === 0) {\n            return false;\n        }\n        for (i=0;i<userScope.length;i++) {\n            if (hasPermission(userScope[i],permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    if (userScope === \"*\" || userScope === permission) {\n        return true;\n    }\n\n    if (userScope === \"read\" || userScope === \"*.read\") {\n        return readRE.test(permission);\n    } else if (userScope === \"write\" || userScope === \"*.write\") {\n        return writeRE.test(permission);\n    }\n    return false;\n}\n\nmodule.exports = {\n    hasPermission: hasPermission,\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/info.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar theme = require(\"./theme\");\nvar util = require('util');\nvar runtime;\nvar settings;\n\nmodule.exports = {\n    init: function(_runtime) {\n        runtime = _runtime;\n        settings = runtime.settings;\n    },\n    settings: function(req,res) {\n        var safeSettings = {\n            httpNodeRoot: settings.httpNodeRoot||\"/\",\n            version: settings.version,\n            user: req.user\n        }\n\n        var themeSettings = theme.settings();\n        if (themeSettings) {\n            safeSettings.editorTheme = themeSettings;\n        }\n\n        if (util.isArray(settings.paletteCategories)) {\n            safeSettings.paletteCategories = settings.paletteCategories;\n        }\n\n        if (settings.flowFilePretty) {\n            safeSettings.flowFilePretty = settings.flowFilePretty;\n        }\n\n        if (!runtime.nodes.paletteEditorEnabled()) {\n            safeSettings.editorTheme = safeSettings.editorTheme || {};\n            safeSettings.editorTheme.palette = safeSettings.editorTheme.palette || {};\n            safeSettings.editorTheme.palette.editable = false;\n        }\n\n        res.json(safeSettings);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/api/credentials.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar api;\n\nmodule.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n        api = runtime.nodes;\n    },\n    get: function (req, res) {\n        // TODO: It should verify the given node id is of the type specified -\n        //       but that would add a dependency from this module to the\n        //       registry module that knows about node types.\n        var nodeType = req.params.type;\n        var nodeID = req.params.id;\n        log.audit({event: \"credentials.get\",type:nodeType,id:nodeID},req);\n        var credentials = api.getCredentials(nodeID);\n        if (!credentials) {\n            res.json({});\n            return;\n        }\n        var definition = api.getCredentialDefinition(nodeType);\n\n        var sendCredentials = {};\n        for (var cred in definition) {\n            if (definition.hasOwnProperty(cred)) {\n                if (definition[cred].type == \"password\") {\n                    var key = 'has_' + cred;\n                    sendCredentials[key] = credentials[cred] != null && credentials[cred] !== '';\n                    continue;\n                }\n                sendCredentials[cred] = credentials[cred] || '';\n            }\n        }\n        res.json(sendCredentials);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red.js":"#!/usr/bin/env node\n/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar http = require('http');\nvar https = require('https');\nvar util = require(\"util\");\nvar express = require(\"express\");\nvar crypto = require(\"crypto\");\ntry { bcrypt = require('bcrypt'); }\ncatch(e) { bcrypt = require('bcryptjs'); }\nvar nopt = require(\"nopt\");\nvar path = require(\"path\");\nvar fs = require(\"fs-extra\");\nvar RED = require(\"./red/red.js\");\n\nvar server;\nvar app = express();\n\nvar settingsFile;\nvar flowFile;\n\nvar knownOpts = {\n    \"help\": Boolean,\n    \"port\": Number,\n    \"settings\": [path],\n    \"title\": String,\n    \"userDir\": [path],\n    \"verbose\": Boolean\n};\nvar shortHands = {\n    \"?\":[\"--help\"],\n    \"p\":[\"--port\"],\n    \"s\":[\"--settings\"],\n    // As we want to reserve -t for now, adding a shorthand to help so it\n    // doesn't get treated as --title\n    \"t\":[\"--help\"],\n    \"u\":[\"--userDir\"],\n    \"v\":[\"--verbose\"]\n};\nnopt.invalidHandler = function(k,v,t) {\n    // TODO: console.log(k,v,t);\n}\n\nvar parsedArgs = nopt(knownOpts,shortHands,process.argv,2)\n\nif (parsedArgs.help) {\n    console.log(\"Node-RED v\"+RED.version());\n    console.log(\"Usage: node-red [-v] [-?] [--settings settings.js] [--userDir DIR]\");\n    console.log(\"                [--port PORT] [--title TITLE] [flows.json]\");\n    console.log(\"\");\n    console.log(\"Options:\");\n    console.log(\"  -p, --port     PORT  port to listen on\");\n    console.log(\"  -s, --settings FILE  use specified settings file\");\n    console.log(\"      --title    TITLE process window title\");\n    console.log(\"  -u, --userDir  DIR   use specified user directory\");\n    console.log(\"  -v, --verbose        enable verbose output\");\n    console.log(\"  -?, --help           show this help\");\n    console.log(\"\");\n    console.log(\"Documentation can be found at http://nodered.org\");\n    process.exit();\n}\n\nif (parsedArgs.argv.remain.length > 0) {\n    flowFile = parsedArgs.argv.remain[0];\n}\n\nif (parsedArgs.settings) {\n    // User-specified settings file\n    settingsFile = parsedArgs.settings;\n} else if (parsedArgs.userDir && fs.existsSync(path.join(parsedArgs.userDir,\"settings.js\"))) {\n    // User-specified userDir that contains a settings.js\n    settingsFile = path.join(parsedArgs.userDir,\"settings.js\");\n} else {\n    if (fs.existsSync(path.join(process.env.NODE_RED_HOME,\".config.json\"))) {\n        // NODE_RED_HOME contains user data - use its settings.js\n        settingsFile = path.join(process.env.NODE_RED_HOME,\"settings.js\");\n    } else {\n        var userDir = parsedArgs.userDir || path.join(process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE,\".node-red\");\n        var userSettingsFile = path.join(userDir,\"settings.js\");\n        if (fs.existsSync(userSettingsFile)) {\n            // $HOME/.node-red/settings.js exists\n            settingsFile = userSettingsFile;\n        } else {\n            var defaultSettings = path.join(__dirname,\"settings.js\");\n            var settingsStat = fs.statSync(defaultSettings);\n            if (settingsStat.mtime.getTime() <= settingsStat.ctime.getTime()) {\n                // Default settings file has not been modified - safe to copy\n                fs.copySync(defaultSettings,userSettingsFile);\n                settingsFile = userSettingsFile;\n            } else {\n                // Use default settings.js as it has been modified\n                settingsFile = defaultSettings;\n            }\n        }\n    }\n}\n\ntry {\n    var settings = require(settingsFile);\n    settings.settingsFile = settingsFile;\n} catch(err) {\n    console.log(\"Error loading settings file: \"+settingsFile)\n    if (err.code == 'MODULE_NOT_FOUND') {\n        if (err.toString().indexOf(settingsFile) === -1) {\n            console.log(err.toString());\n        }\n    } else {\n        console.log(err);\n    }\n    process.exit();\n}\n\nif (parsedArgs.verbose) {\n    settings.verbose = true;\n}\n\nif (settings.https) {\n    server = https.createServer(settings.https,function(req,res) {app(req,res);});\n} else {\n    server = http.createServer(function(req,res) {app(req,res);});\n}\nserver.setMaxListeners(0);\n\nfunction formatRoot(root) {\n    if (root[0] != \"/\") {\n        root = \"/\" + root;\n    }\n    if (root.slice(-1) != \"/\") {\n        root = root + \"/\";\n    }\n    return root;\n}\n\nif (settings.httpRoot === false) {\n    settings.httpAdminRoot = false;\n    settings.httpNodeRoot = false;\n} else {\n    settings.httpRoot = settings.httpRoot||\"/\";\n    settings.disableEditor = settings.disableEditor||false;\n}\n\nif (settings.httpAdminRoot !== false) {\n    settings.httpAdminRoot = formatRoot(settings.httpAdminRoot || settings.httpRoot || \"/\");\n    settings.httpAdminAuth = settings.httpAdminAuth || settings.httpAuth;\n} else {\n    settings.disableEditor = true;\n}\n\nif (settings.httpNodeRoot !== false) {\n    settings.httpNodeRoot = formatRoot(settings.httpNodeRoot || settings.httpRoot || \"/\");\n    settings.httpNodeAuth = settings.httpNodeAuth || settings.httpAuth;\n}\n\nsettings.uiPort = parsedArgs.port||settings.uiPort||1880;\nsettings.uiHost = settings.uiHost||\"0.0.0.0\";\n\nif (flowFile) {\n    settings.flowFile = flowFile;\n}\nif (parsedArgs.userDir) {\n    settings.userDir = parsedArgs.userDir;\n}\n\ntry {\n    RED.init(server,settings);\n} catch(err) {\n    if (err.code == \"unsupported_version\") {\n        console.log(\"Unsupported version of node.js:\",process.version);\n        console.log(\"Node-RED requires node.js v4 or later\");\n    } else if  (err.code == \"not_built\") {\n        console.log(\"Node-RED has not been built. See README.md for details\");\n    } else {\n        console.log(\"Failed to start server:\");\n        if (err.stack) {\n            console.log(err.stack);\n        } else {\n            console.log(err);\n        }\n    }\n    process.exit(1);\n}\n\nfunction basicAuthMiddleware(user,pass) {\n    var basicAuth = require('basic-auth');\n    var checkPassword;\n    if (pass.length == \"32\") {\n        // Assume its a legacy md5 password\n        checkPassword = function(p) {\n            return crypto.createHash('md5').update(p,'utf8').digest('hex') === pass;\n        }\n    } else {\n        checkPassword = function(p) {\n            return bcrypt.compareSync(p,pass);\n        }\n    }\n\n    return function(req,res,next) {\n        if (req.method === 'OPTIONS') {\n            return next();\n        }\n        var requestUser = basicAuth(req);\n        if (!requestUser || requestUser.name !== user || !checkPassword(requestUser.pass)) {\n            res.set('WWW-Authenticate', 'Basic realm=Authorization Required');\n            return res.sendStatus(401);\n        }\n        next();\n    }\n}\n\nif (settings.httpAdminRoot !== false && settings.httpAdminAuth) {\n    RED.log.warn(RED.log._(\"server.httpadminauth-deprecated\"));\n    app.use(settings.httpAdminRoot, basicAuthMiddleware(settings.httpAdminAuth.user,settings.httpAdminAuth.pass));\n}\n\nif (settings.httpAdminRoot !== false) {\n    app.use(settings.httpAdminRoot,RED.httpAdmin);\n}\nif (settings.httpNodeRoot !== false && settings.httpNodeAuth) {\n    app.use(settings.httpNodeRoot,basicAuthMiddleware(settings.httpNodeAuth.user,settings.httpNodeAuth.pass));\n}\nif (settings.httpNodeRoot !== false) {\n    app.use(settings.httpNodeRoot,RED.httpNode);\n}\nif (settings.httpStatic) {\n    settings.httpStaticAuth = settings.httpStaticAuth || settings.httpAuth;\n    if (settings.httpStaticAuth) {\n        app.use(\"/\",basicAuthMiddleware(settings.httpStaticAuth.user,settings.httpStaticAuth.pass));\n    }\n    app.use(\"/\",express.static(settings.httpStatic));\n}\n\nfunction getListenPath() {\n    var listenPath = 'http'+(settings.https?'s':'')+'://'+\n                    (settings.uiHost == '0.0.0.0'?'127.0.0.1':settings.uiHost)+\n                    ':'+settings.uiPort;\n    if (settings.httpAdminRoot !== false) {\n        listenPath += settings.httpAdminRoot;\n    } else if (settings.httpStatic) {\n        listenPath += \"/\";\n    }\n    return listenPath;\n}\n\nRED.start().then(function() {\n    if (settings.httpAdminRoot !== false || settings.httpNodeRoot !== false || settings.httpStatic) {\n        server.on('error', function(err) {\n            if (err.errno === \"EADDRINUSE\") {\n                RED.log.error(RED.log._(\"server.unable-to-listen\", {listenpath:getListenPath()}));\n                RED.log.error(RED.log._(\"server.port-in-use\"));\n            } else {\n                RED.log.error(RED.log._(\"server.uncaught-exception\"));\n                if (err.stack) {\n                    RED.log.error(err.stack);\n                } else {\n                    RED.log.error(err);\n                }\n            }\n            process.exit(1);\n        });\n        server.listen(settings.uiPort,settings.uiHost,function() {\n            if (settings.httpAdminRoot === false) {\n                RED.log.info(RED.log._(\"server.admin-ui-disabled\"));\n            }\n            process.title = parsedArgs.title || 'node-red';\n            RED.log.info(RED.log._(\"server.now-running\", {listenpath:getListenPath()}));\n        });\n    } else {\n        RED.log.info(RED.log._(\"server.headless-mode\"));\n    }\n}).otherwise(function(err) {\n    RED.log.error(RED.log._(\"server.failed-to-start\"));\n    if (err.stack) {\n        RED.log.error(err.stack);\n    } else {\n        RED.log.error(err);\n    }\n});\n\nprocess.on('uncaughtException',function(err) {\n    util.log('[red] Uncaught Exception:');\n    if (err.stack) {\n        util.log(err.stack);\n    } else {\n        util.log(err);\n    }\n    process.exit(1);\n});\n\nprocess.on('SIGINT', function () {\n    RED.stop();\n    // TODO: need to allow nodes to close asynchronously before terminating the\n    // process - ie, promises\n    process.exit();\n});\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/settings.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n// The `https` setting requires the `fs` module. Uncomment the following\n// to make it available:\n//var fs = require(\"fs\");\n\nmodule.exports = {\n    // the tcp port that the Node-RED web server is listening on\n    uiPort: process.env.PORT || 1880,\n\n    // By default, the Node-RED UI accepts connections on all IPv4 interfaces.\n    // The following property can be used to listen on a specific interface. For\n    // example, the following would only allow connections from the local machine.\n    //uiHost: \"127.0.0.1\",\n\n    // Retry time in milliseconds for MQTT connections\n    mqttReconnectTime: 15000,\n\n    // Retry time in milliseconds for Serial port connections\n    serialReconnectTime: 15000,\n\n    // Retry time in milliseconds for TCP socket connections\n    //socketReconnectTime: 10000,\n\n    // Timeout in milliseconds for TCP server socket connections\n    //  defaults to no timeout\n    //socketTimeout: 120000,\n\n    // Timeout in milliseconds for HTTP request connections\n    //  defaults to 120 seconds\n    //httpRequestTimeout: 120000,\n\n    // The maximum length, in characters, of any message sent to the debug sidebar tab\n    debugMaxLength: 1000,\n\n    // Colourise the console output of the debug node\n    //debugUseColors: true,\n\n    // The file containing the flows. If not set, it defaults to flows_<hostname>.json\n    //flowFile: 'flows.json',\n\n    // To enabled pretty-printing of the flow within the flow file, set the following\n    //  property to true:\n    //flowFilePretty: true,\n\n    // By default, credentials are encrypted in storage using a generated key. To\n    // specify your own secret, set the following property.\n    // If you want to disable encryption of credentials, set this property to false.\n    // Note: once you set this property, do not change it - doing so will prevent\n    // node-red from being able to decrypt your existing credentials and they will be\n    // lost.\n    //credentialSecret: \"a-secret-key\",\n\n    // By default, all user data is stored in the Node-RED install directory. To\n    // use a different location, the following property can be used\n    //userDir: '/home/nol/.node-red/',\n\n    // Node-RED scans the `nodes` directory in the install directory to find nodes.\n    // The following property can be used to specify an additional directory to scan.\n    //nodesDir: '/home/nol/.node-red/nodes',\n\n    // By default, the Node-RED UI is available at http://localhost:1880/\n    // The following property can be used to specifiy a different root path.\n    // If set to false, this is disabled.\n    //httpAdminRoot: '/admin',\n\n    // Some nodes, such as HTTP In, can be used to listen for incoming http requests.\n    // By default, these are served relative to '/'. The following property\n    // can be used to specifiy a different root path. If set to false, this is\n    // disabled.\n    //httpNodeRoot: '/red-nodes',\n\n    // The following property can be used in place of 'httpAdminRoot' and 'httpNodeRoot',\n    // to apply the same root to both parts.\n    //httpRoot: '/red',\n\n    // When httpAdminRoot is used to move the UI to a different root path, the\n    // following property can be used to identify a directory of static content\n    // that should be served at http://localhost:1880/.\n    //httpStatic: '/home/nol/node-red-static/',\n\n    // The maximum size of HTTP request that will be accepted by the runtime api.\n    // Default: 5mb\n    //apiMaxLength: '5mb',\n\n    // If you installed the optional node-red-dashboard you can set it's path\n    // relative to httpRoot\n    //ui: { path: \"ui\" },\n\n    // Securing Node-RED\n    // -----------------\n    // To password protect the Node-RED editor and admin API, the following\n    // property can be used. See http://nodered.org/docs/security.html for details.\n    //adminAuth: {\n    //    type: \"credentials\",\n    //    users: [{\n    //        username: \"admin\",\n    //        password: \"$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.\",\n    //        permissions: \"*\"\n    //    }]\n    //},\n\n    // To password protect the node-defined HTTP endpoints (httpNodeRoot), or\n    // the static content (httpStatic), the following properties can be used.\n    // The pass field is a bcrypt hash of the password.\n    // See http://nodered.org/docs/security.html#generating-the-password-hash\n    //httpNodeAuth: {user:\"user\",pass:\"$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.\"},\n    //httpStaticAuth: {user:\"user\",pass:\"$2a$08$zZWtXTja0fB1pzD4sHCMyOCMYz2Z6dNbM6tl8sJogENOMcxWV9DN.\"},\n\n    // The following property can be used to enable HTTPS\n    // See http://nodejs.org/api/https.html#https_https_createserver_options_requestlistener\n    // for details on its contents.\n    // See the comment at the top of this file on how to load the `fs` module used by\n    // this setting.\n    //\n    //https: {\n    //    key: fs.readFileSync('privatekey.pem'),\n    //    cert: fs.readFileSync('certificate.pem')\n    //},\n\n    // The following property can be used to cause insecure HTTP connections to\n    // be redirected to HTTPS.\n    //requireHttps: true\n\n    // The following property can be used to disable the editor. The admin API\n    // is not affected by this option. To disable both the editor and the admin\n    // API, use either the httpRoot or httpAdminRoot properties\n    //disableEditor: false,\n\n    // The following property can be used to configure cross-origin resource sharing\n    // in the HTTP nodes.\n    // See https://github.com/troygoode/node-cors#configuration-options for\n    // details on its contents. The following is a basic permissive set of options:\n    //httpNodeCors: {\n    //    origin: \"*\",\n    //    methods: \"GET,PUT,POST,DELETE\"\n    //},\n\n    // If you need to set an http proxy please set an environment variable\n    // called http_proxy (or HTTP_PROXY) outside of Node-RED in the operating system.\n    // For example - http_proxy=http://myproxy.com:8080\n    // (Setting it here will have no effect)\n    // You may also specify no_proxy (or NO_PROXY) to supply a comma separated\n    // list of domains to not proxy, eg - no_proxy=.acme.co,.acme.co.uk\n\n    // The following property can be used to add a custom middleware function\n    // in front of all http in nodes. This allows custom authentication to be\n    // applied to all http in nodes, or any other sort of common request processing.\n    //httpNodeMiddleware: function(req,res,next) {\n    //    // Handle/reject the request, or pass it on to the http in node by calling next();\n    //    // Optionally skip our rawBodyParser by setting this to true;\n    //    //req.skipRawBodyParser = true;\n    //    next();\n    //},\n\n    // Anything in this hash is globally available to all functions.\n    // It is accessed as context.global.\n    // eg:\n    //    functionGlobalContext: { os:require('os') }\n    // can be accessed in a function block as:\n    //    context.global.os\n\n    functionGlobalContext: {\n        // os:require('os'),\n        // octalbonescript:require('octalbonescript'),\n        // jfive:require(\"johnny-five\"),\n        // j5board:require(\"johnny-five\").Board({repl:false})\n    },\n\n    // The following property can be used to order the categories in the editor\n    // palette. If a node's category is not in the list, the category will get\n    // added to the end of the palette.\n    // If not set, the following default order is used:\n    //paletteCategories: ['subflows', 'input', 'output', 'function', 'social', 'mobile', 'storage', 'analysis', 'advanced'],\n\n    // Configure the logging output\n    logging: {\n        // Only console logging is currently supported\n        console: {\n            // Level of logging to be recorded. Options are:\n            // fatal - only those errors which make the application unusable should be recorded\n            // error - record errors which are deemed fatal for a particular request + fatal errors\n            // warn - record problems which are non fatal + errors + fatal errors\n            // info - record information about the general running of the application + warn + error + fatal errors\n            // debug - record information which is more verbose than info + info + warn + error + fatal errors\n            // trace - record very detailed logging + debug + info + warn + error + fatal errors\n            level: \"info\",\n            // Whether or not to include metric events in the log output\n            metrics: false,\n            // Whether or not to include audit events in the log output\n            audit: false\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/public/red/main.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n(function() {\n\n    function loadNodeList() {\n        $.ajax({\n            headers: {\n                \"Accept\":\"application/json\"\n            },\n            cache: false,\n            url: 'nodes',\n            success: function(data) {\n                RED.nodes.setNodeList(data);\n\n                var nsCount = 0;\n                for (var i=0;i<data.length;i++) {\n                    var ns = data[i];\n                    if (ns.module != \"node-red\") {\n                        nsCount++;\n                        RED.i18n.loadCatalog(ns.id, function() {\n                            nsCount--;\n                            if (nsCount === 0) {\n                                loadNodes();\n                            }\n                        });\n                    }\n                }\n                if (nsCount === 0) {\n                    loadNodes();\n                }\n            }\n        });\n    }\n\n    function loadNodes() {\n        $.ajax({\n            headers: {\n                \"Accept\":\"text/html\"\n            },\n            cache: false,\n            url: 'nodes',\n            success: function(data) {\n                $(\"body\").append(data);\n                $(\"body\").i18n();\n                $(\"#palette > .palette-spinner\").hide();\n                $(\".palette-scroll\").removeClass(\"hide\");\n                $(\"#palette-search\").removeClass(\"hide\");\n                loadFlows();\n            }\n        });\n    }\n\n    function loadFlows() {\n        $.ajax({\n            headers: {\n                \"Accept\":\"application/json\",\n            },\n            cache: false,\n            url: 'flows',\n            success: function(nodes) {\n                var currentHash = window.location.hash;\n                RED.nodes.version(nodes.rev);\n                RED.nodes.import(nodes.flows);\n                RED.nodes.dirty(false);\n                RED.view.redraw(true);\n                if (/^#flow\\/.+$/.test(currentHash)) {\n                    RED.workspaces.show(currentHash.substring(6));\n                }\n\n                var persistentNotifications = {};\n                RED.comms.subscribe(\"notification/#\",function(topic,msg) {\n                    var parts = topic.split(\"/\");\n                    var notificationId = parts[1];\n                    if (msg.text) {\n                        var text = RED._(msg.text,{default:msg.text});\n                        if (!persistentNotifications.hasOwnProperty(notificationId)) {\n                            persistentNotifications[notificationId] = RED.notify(text,msg.type,msg.timeout === undefined,msg.timeout);\n                        } else {\n                            persistentNotifications[notificationId].update(text,msg.timeout);\n                        }\n                    } else if (persistentNotifications.hasOwnProperty(notificationId)) {\n                        persistentNotifications[notificationId].close();\n                        delete persistentNotifications[notificationId];\n                    }\n                });\n                RED.comms.subscribe(\"status/#\",function(topic,msg) {\n                    var parts = topic.split(\"/\");\n                    var node = RED.nodes.node(parts[1]);\n                    if (node) {\n                        if (msg.hasOwnProperty(\"text\")) {\n                            msg.text = node._(msg.text.toString(),{defaultValue:msg.text.toString()});\n                        }\n                        node.status = msg;\n                        node.dirty = true;\n                        RED.view.redraw();\n                    }\n                });\n                RED.comms.subscribe(\"node/#\",function(topic,msg) {\n                    var i,m;\n                    var typeList;\n                    var info;\n                    if (topic == \"node/added\") {\n                        var addedTypes = [];\n                        msg.forEach(function(m) {\n                            var id = m.id;\n                            RED.nodes.addNodeSet(m);\n                            addedTypes = addedTypes.concat(m.types);\n                            RED.i18n.loadCatalog(id, function() {\n                                $.get('nodes/'+id, function(data) {\n                                    $(\"body\").append(data);\n                                });\n                            });\n                        });\n                        if (addedTypes.length) {\n                            typeList = \"<ul><li>\"+addedTypes.join(\"</li><li>\")+\"</li></ul>\";\n                            RED.notify(RED._(\"palette.event.nodeAdded\", {count:addedTypes.length})+typeList,\"success\");\n                        }\n                    } else if (topic == \"node/removed\") {\n                        for (i=0;i<msg.length;i++) {\n                            m = msg[i];\n                            info = RED.nodes.removeNodeSet(m.id);\n                            if (info.added) {\n                                typeList = \"<ul><li>\"+m.types.join(\"</li><li>\")+\"</li></ul>\";\n                                RED.notify(RED._(\"palette.event.nodeRemoved\", {count:m.types.length})+typeList,\"success\");\n                            }\n                        }\n                    } else if (topic == \"node/enabled\") {\n                        if (msg.types) {\n                            info = RED.nodes.getNodeSet(msg.id);\n                            if (info.added) {\n                                RED.nodes.enableNodeSet(msg.id);\n                                typeList = \"<ul><li>\"+msg.types.join(\"</li><li>\")+\"</li></ul>\";\n                                RED.notify(RED._(\"palette.event.nodeEnabled\", {count:msg.types.length})+typeList,\"success\");\n                            } else {\n                                $.get('nodes/'+msg.id, function(data) {\n                                    $(\"body\").append(data);\n                                    typeList = \"<ul><li>\"+msg.types.join(\"</li><li>\")+\"</li></ul>\";\n                                    RED.notify(RED._(\"palette.event.nodeAdded\", {count:msg.types.length})+typeList,\"success\");\n                                });\n                            }\n                        }\n                    } else if (topic == \"node/disabled\") {\n                        if (msg.types) {\n                            RED.nodes.disableNodeSet(msg.id);\n                            typeList = \"<ul><li>\"+msg.types.join(\"</li><li>\")+\"</li></ul>\";\n                            RED.notify(RED._(\"palette.event.nodeDisabled\", {count:msg.types.length})+typeList,\"success\");\n                        }\n                    }\n                    // Refresh flow library to ensure any examples are updated\n                    RED.library.loadFlowLibrary();\n                });\n            }\n        });\n    }\n\n    function showAbout() {\n        $.get('red/about', function(data) {\n            var aboutHeader = '<div style=\"text-align:center;\">'+\n                                '<img width=\"50px\" src=\"red/images/node-red-icon.svg\" />'+\n                              '</div>';\n\n            RED.sidebar.info.set(aboutHeader+marked(data));\n            RED.sidebar.info.show();\n        });\n    }\n\n    function loadEditor() {\n        var menuOptions = [];\n        menuOptions.push({id:\"menu-item-view-menu\",label:RED._(\"menu.label.view.view\"),options:[\n            {id:\"menu-item-view-show-grid\",label:RED._(\"menu.label.view.showGrid\"),toggle:true,onselect:\"core:toggle-show-grid\"},\n            {id:\"menu-item-view-snap-grid\",label:RED._(\"menu.label.view.snapGrid\"),toggle:true,onselect:\"core:toggle-snap-grid\"},\n            {id:\"menu-item-status\",label:RED._(\"menu.label.displayStatus\"),toggle:true,onselect:\"core:toggle-status\", selected: true},\n            null,\n            // {id:\"menu-item-bidi\",label:RED._(\"menu.label.view.textDir\"),options:[\n            //     {id:\"menu-item-bidi-default\",toggle:\"text-direction\",label:RED._(\"menu.label.view.defaultDir\"),selected: true, onselect:function(s) { if(s){RED.text.bidi.setTextDirection(\"\")}}},\n            //     {id:\"menu-item-bidi-ltr\",toggle:\"text-direction\",label:RED._(\"menu.label.view.ltr\"), onselect:function(s) { if(s){RED.text.bidi.setTextDirection(\"ltr\")}}},\n            //     {id:\"menu-item-bidi-rtl\",toggle:\"text-direction\",label:RED._(\"menu.label.view.rtl\"), onselect:function(s) { if(s){RED.text.bidi.setTextDirection(\"rtl\")}}},\n            //     {id:\"menu-item-bidi-auto\",toggle:\"text-direction\",label:RED._(\"menu.label.view.auto\"), onselect:function(s) { if(s){RED.text.bidi.setTextDirection(\"auto\")}}}\n            // ]},\n            // null,\n            {id:\"menu-item-sidebar\",label:RED._(\"menu.label.sidebar.show\"),toggle:true,onselect:\"core:toggle-sidebar\", selected: true}\n        ]});\n        menuOptions.push(null);\n        menuOptions.push({id:\"menu-item-import\",label:RED._(\"menu.label.import\"),options:[\n            {id:\"menu-item-import-clipboard\",label:RED._(\"menu.label.clipboard\"),onselect:\"core:show-import-dialog\"},\n            {id:\"menu-item-import-library\",label:RED._(\"menu.label.library\"),options:[]}\n        ]});\n        menuOptions.push({id:\"menu-item-export\",label:RED._(\"menu.label.export\"),disabled:true,options:[\n            {id:\"menu-item-export-clipboard\",label:RED._(\"menu.label.clipboard\"),disabled:true,onselect:\"core:show-export-dialog\"},\n            {id:\"menu-item-export-library\",label:RED._(\"menu.label.library\"),disabled:true,onselect:\"core:library-export\"}\n        ]});\n        menuOptions.push(null);\n        menuOptions.push({id:\"menu-item-search\",label:RED._(\"menu.label.search\"),onselect:\"core:search\"});\n        menuOptions.push(null);\n        menuOptions.push({id:\"menu-item-config-nodes\",label:RED._(\"menu.label.displayConfig\"),onselect:\"core:show-config-tab\"});\n        menuOptions.push({id:\"menu-item-workspace\",label:RED._(\"menu.label.flows\"),options:[\n            {id:\"menu-item-workspace-add\",label:RED._(\"menu.label.add\"),onselect:\"core:add-flow\"},\n            {id:\"menu-item-workspace-edit\",label:RED._(\"menu.label.rename\"),onselect:\"core:edit-flow\"},\n            {id:\"menu-item-workspace-delete\",label:RED._(\"menu.label.delete\"),onselect:\"core:remove-flow\"}\n        ]});\n        menuOptions.push({id:\"menu-item-subflow\",label:RED._(\"menu.label.subflows\"), options: [\n            {id:\"menu-item-subflow-create\",label:RED._(\"menu.label.createSubflow\"),onselect:\"core:create-subflow\"},\n            {id:\"menu-item-subflow-convert\",label:RED._(\"menu.label.selectionToSubflow\"),disabled:true,onselect:\"core:convert-to-subflow\"},\n        ]});\n        menuOptions.push(null);\n        if (RED.settings.theme('palette.editable') !== false) {\n            RED.palette.editor.init();\n            menuOptions.push({id:\"menu-item-edit-palette\",label:RED._(\"menu.label.editPalette\"),onselect:\"core:manage-palette\"});\n            menuOptions.push(null);\n        }\n\n        menuOptions.push({id:\"menu-item-keyboard-shortcuts\",label:RED._(\"menu.label.keyboardShortcuts\"),onselect:\"core:show-help\"});\n        menuOptions.push({id:\"menu-item-show-tips\",label:RED._(\"menu.label.showTips\"),toggle:true,selected:true,onselect:\"core:toggle-show-tips\"});\n        menuOptions.push({id:\"menu-item-help\",\n            label: RED.settings.theme(\"menu.menu-item-help.label\",\"Node-RED website\"),\n            href: RED.settings.theme(\"menu.menu-item-help.url\",\"http://nodered.org/docs\")\n        });\n        menuOptions.push({id:\"menu-item-node-red-version\", label:\"v\"+RED.settings.version, onselect: \"core:show-about\" });\n\n\n        RED.user.init();\n        RED.library.init();\n        RED.palette.init();\n        RED.sidebar.init();\n        RED.subflow.init();\n        RED.workspaces.init();\n        RED.clipboard.init();\n        RED.search.init();\n        RED.view.init();\n        RED.editor.init();\n        RED.keyboard.init();\n        RED.diff.init();\n\n        RED.menu.init({id:\"btn-sidemenu\",options: menuOptions});\n\n        RED.deploy.init(RED.settings.theme(\"deployButton\",null));\n\n        RED.actions.add(\"core:show-about\", showAbout);\n\n        RED.comms.connect();\n\n        $(\"#main-container\").show();\n        $(\".header-toolbar\").show();\n\n\n        loadNodeList();\n    }\n\n    $(function() {\n\n        if ((window.location.hostname !== \"localhost\") && (window.location.hostname !== \"127.0.0.1\")) {\n            document.title = document.title+\" : \"+window.location.hostname;\n        }\n\n        ace.require(\"ace/ext/language_tools\");\n\n        RED.i18n.init(function() {\n            RED.settings.init(loadEditor);\n        })\n    });\n})();\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/analysis/72-sentiment.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var sentiment = require('sentiment');\n\n    function SentimentNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                sentiment(msg.payload, msg.overrides || null, function (err, result) {\n                    msg.sentiment = result;\n                    node.send(msg);\n                });\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"sentiment\",SentimentNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/20-inject.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var cron = require(\"cron\");\n\n    function InjectNode(n) {\n        RED.nodes.createNode(this,n);\n        this.topic = n.topic;\n        this.payload = n.payload;\n        this.payloadType = n.payloadType;\n        this.repeat = n.repeat;\n        this.crontab = n.crontab;\n        this.once = n.once;\n        var node = this;\n        this.interval_id = null;\n        this.cronjob = null;\n\n        if (this.repeat && !isNaN(this.repeat) && this.repeat > 0) {\n            this.repeat = this.repeat * 1000;\n            if (RED.settings.verbose) { this.log(RED._(\"inject.repeat\",this)); }\n            this.interval_id = setInterval( function() {\n                node.emit(\"input\",{});\n            }, this.repeat );\n        } else if (this.crontab) {\n            if (RED.settings.verbose) { this.log(RED._(\"inject.crontab\",this)); }\n            this.cronjob = new cron.CronJob(this.crontab,\n                function() {\n                    node.emit(\"input\",{});\n                },\n                null,true);\n        }\n\n        if (this.once) {\n            setTimeout( function() { node.emit(\"input\",{}); }, 100 );\n        }\n\n        this.on(\"input\",function(msg) {\n            try {\n                msg.topic = this.topic;\n                if ( (this.payloadType == null && this.payload === \"\") || this.payloadType === \"date\") {\n                    msg.payload = Date.now();\n                } else if (this.payloadType == null) {\n                    msg.payload = this.payload;\n                } else if (this.payloadType == 'none') {\n                    msg.payload = \"\";\n                } else {\n                    msg.payload = RED.util.evaluateNodeProperty(this.payload,this.payloadType,this,msg);\n                }\n                this.send(msg);\n                msg = null;\n            } catch(err) {\n                this.error(err,msg);\n            }\n        });\n    }\n\n    RED.nodes.registerType(\"inject\",InjectNode);\n\n    InjectNode.prototype.close = function() {\n        if (this.interval_id != null) {\n            clearInterval(this.interval_id);\n            if (RED.settings.verbose) { this.log(RED._(\"inject.stopped\")); }\n        } else if (this.cronjob != null) {\n            this.cronjob.stop();\n            if (RED.settings.verbose) { this.log(RED._(\"inject.stopped\")); }\n            delete this.cronjob;\n        }\n    }\n\n    RED.httpAdmin.post(\"/inject/:id\", RED.auth.needsPermission(\"inject.write\"), function(req,res) {\n        var node = RED.nodes.getNode(req.params.id);\n        if (node != null) {\n            try {\n                node.receive();\n                res.sendStatus(200);\n            } catch(err) {\n                res.sendStatus(500);\n                node.error(RED._(\"inject.failed\",{error:err.toString()}));\n            }\n        } else {\n            res.sendStatus(404);\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/25-catch.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function CatchNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.scope = n.scope;\n        this.on(\"input\",function(msg) {\n            this.send(msg);\n        });\n    }\n\n    RED.nodes.registerType(\"catch\",CatchNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/25-status.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function StatusNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.scope = n.scope;\n        this.on(\"input\", function(msg) {\n            this.send(msg);\n        });\n    }\n\n    RED.nodes.registerType(\"status\",StatusNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/58-debug.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var util = require(\"util\");\n    var events = require(\"events\");\n    var path = require(\"path\");\n    var safeJSONStringify = require(\"json-stringify-safe\");\n    var debuglength = RED.settings.debugMaxLength||1000;\n    var useColors = RED.settings.debugUseColors || false;\n    util.inspect.styles.boolean = \"red\";\n\n    function DebugNode(n) {\n        RED.nodes.createNode(this,n);\n        this.name = n.name;\n        this.complete = (n.complete||\"payload\").toString();\n\n        if (this.complete === \"false\") {\n            this.complete = \"payload\";\n        }\n\n        this.console = n.console;\n        this.active = (n.active === null || typeof n.active === \"undefined\") || n.active;\n        var node = this;\n\n        this.on(\"input\",function(msg) {\n            if (this.complete === \"true\") {\n            // debug complete msg object\n                if (this.console === \"true\") {\n                    node.log(\"\\n\"+util.inspect(msg, {colors:useColors, depth:10}));\n                }\n                if (this.active) {\n                    sendDebug({id:this.id,name:this.name,topic:msg.topic,msg:msg,_path:msg._path});\n                }\n            } else {\n            // debug user defined msg property\n                var property = \"payload\";\n                var output = msg[property];\n                if (this.complete !== \"false\" && typeof this.complete !== \"undefined\") {\n                    property = this.complete;\n                    try {\n                        output = RED.util.getMessageProperty(msg,this.complete);\n                    } catch(err) {\n                        output = undefined;\n                    }\n                }\n                if (this.console === \"true\") {\n                    if (typeof output === \"string\") {\n                        node.log((output.indexOf(\"\\n\") !== -1 ? \"\\n\" : \"\") + output);\n                    } else if (typeof output === \"object\") {\n                        node.log(\"\\n\"+util.inspect(output, {colors:useColors, depth:10}));\n                    } else {\n                        node.log(util.inspect(output, {colors:useColors}));\n                    }\n                }\n                if (this.active) {\n                    sendDebug({id:this.id,z:this.z,name:this.name,topic:msg.topic,property:property,msg:output,_path:msg._path});\n                }\n            }\n        });\n    }\n\n    RED.nodes.registerType(\"debug\",DebugNode);\n\n    function sendDebug(msg) {\n        if (msg.msg instanceof Error) {\n            msg.format = \"error\";\n            var errorMsg = {};\n            if (msg.msg.name) {\n                errorMsg.name = msg.msg.name;\n            }\n            if (msg.msg.hasOwnProperty('message')) {\n                errorMsg.message = msg.msg.message;\n            } else {\n                errorMsg.message = msg.msg.toString();\n            }\n            msg.msg = JSON.stringify(errorMsg);\n        } else if (msg.msg instanceof Buffer) {\n            msg.format = \"buffer[\"+msg.msg.length+\"]\";\n            msg.msg = msg.msg.toString('hex');\n            if (msg.msg.length > debuglength) {\n                msg.msg = msg.msg.substring(0,debuglength);\n            }\n        } else if (msg.msg && typeof msg.msg === 'object') {\n            var seen = [];\n            var seenAts = [];\n            try {\n                msg.format = msg.msg.constructor.name || \"Object\";\n            } catch(err) {\n                msg.format = \"Object\";\n            }\n            if (/error/i.test(msg.format)) {\n                msg.msg = JSON.stringify({\n                    name: msg.msg.name,\n                    message: msg.msg.message\n                });\n            } else {\n                var isArray = util.isArray(msg.msg);\n                if (isArray) {\n                    msg.format = \"array[\"+msg.msg.length+\"]\";\n                    if (msg.msg.length > debuglength) {\n                        msg.msg = msg.msg.slice(0,debuglength);\n                    }\n                }\n                if (isArray || (msg.format === \"Object\")) {\n                    msg.msg = safeJSONStringify(msg.msg, function(key, value) {\n                        if (key === '_req' || key === '_res') {\n                            return \"[internal]\"\n                        }\n                        if (value instanceof Error) {\n                            return value.toString()\n                        }\n                        if (util.isArray(value) && value.length > debuglength) {\n                            value = {\n                                __encoded__: true,\n                                type: \"array\",\n                                data: value.slice(0,debuglength),\n                                length: value.length\n                            }\n                        }\n                        if (typeof value === 'string') {\n                            if (value.length > debuglength) {\n                                return value.substring(0,debuglength)+\"...\";\n                            }\n                        }\n                        return value;\n                    },\" \");\n                } else {\n                    try { msg.msg = msg.msg.toString(); }\n                    catch(e) { msg.msg = \"[Type not printable]\"; }\n                }\n            }\n            seen = null;\n        } else if (typeof msg.msg === \"boolean\") {\n            msg.format = \"boolean\";\n            msg.msg = msg.msg.toString();\n        } else if (typeof msg.msg === \"number\") {\n            msg.format = \"number\";\n            msg.msg = msg.msg.toString();\n        } else if (msg.msg === 0) {\n            msg.format = \"number\";\n            msg.msg = \"0\";\n        } else if (msg.msg === null || typeof msg.msg === \"undefined\") {\n            msg.format = (msg.msg === null)?\"null\":\"undefined\";\n            msg.msg = \"(undefined)\";\n        } else {\n            msg.format = \"string[\"+msg.msg.length+\"]\";\n            if (msg.msg.length > debuglength) {\n                msg.msg = msg.msg.substring(0,debuglength)+\"...\";\n            }\n        }\n        // if (msg.msg.length > debuglength) {\n        //     msg.msg = msg.msg.substr(0,debuglength) +\" ....\";\n        // }\n        RED.comms.publish(\"debug\",msg);\n    }\n\n    DebugNode.logHandler = new events.EventEmitter();\n    DebugNode.logHandler.on(\"log\",function(msg) {\n        if (msg.level === RED.log.WARN || msg.level === RED.log.ERROR) {\n            sendDebug(msg);\n        }\n    });\n    RED.log.addHandler(DebugNode.logHandler);\n\n    RED.httpAdmin.post(\"/debug/:id/:state\", RED.auth.needsPermission(\"debug.write\"), function(req,res) {\n        var node = RED.nodes.getNode(req.params.id);\n        var state = req.params.state;\n        if (node !== null && typeof node !== \"undefined\" ) {\n            if (state === \"enable\") {\n                node.active = true;\n                res.sendStatus(200);\n            } else if (state === \"disable\") {\n                node.active = false;\n                res.sendStatus(201);\n            } else {\n                res.sendStatus(404);\n            }\n        } else {\n            res.sendStatus(404);\n        }\n    });\n\n    // As debug/view/debug-utils.js is loaded via <script> tag, it won't get\n    // the auth header attached. So do not use RED.auth.needsPermission here.\n    RED.httpAdmin.get(\"/debug/view/*\",function(req,res) {\n        var options = {\n            root: __dirname + '/lib/debug/',\n            dotfiles: 'deny'\n        };\n        res.sendFile(req.params[0], options);\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/60-link.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function LinkInNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        var event = \"node:\"+n.id;\n        var handler = function(msg) {\n            msg._event = n.event;\n            node.receive(msg);\n        }\n        RED.events.on(event,handler);\n        this.on(\"input\", function(msg) {\n            this.send(msg);\n        });\n        this.on(\"close\",function() {\n            RED.events.removeListener(event,handler);\n        });\n    }\n\n    RED.nodes.registerType(\"link in\",LinkInNode);\n\n    function LinkOutNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        var event = \"node:\"+n.id;\n        this.on(\"input\", function(msg) {\n            msg._event = event;\n            RED.events.emit(event,msg)\n            this.send(msg);\n        });\n    }\n    RED.nodes.registerType(\"link out\",LinkOutNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/75-exec.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var spawn = require('child_process').spawn;\n    var exec = require('child_process').exec;\n    var isUtf8 = require('is-utf8');\n\n    function ExecNode(n) {\n        RED.nodes.createNode(this,n);\n        this.cmd = (n.command || \"\").trim();\n        if (n.addpay === undefined) { n.addpay = true; }\n        this.addpay = n.addpay;\n        this.append = (n.append || \"\").trim();\n        this.useSpawn = n.useSpawn;\n        this.timer = Number(n.timer || 0)*1000;\n        this.activeProcesses = {};\n        var node = this;\n\n        var cleanup = function(p) {\n            node.activeProcesses[p].kill();\n            node.status({fill:\"red\",shape:\"dot\",text:\"timeout\"});\n            node.error(\"Exec node timeout\");\n        }\n\n        this.on(\"input\", function(msg) {\n            var child;\n            node.status({fill:\"blue\",shape:\"dot\",text:\" \"});\n            if (this.useSpawn === true) {\n                // make the extra args into an array\n                // then prepend with the msg.payload\n                var arg = node.cmd;\n                if ((node.addpay === true) && msg.hasOwnProperty(\"payload\")) { arg += \" \"+msg.payload; }\n                if (node.append.trim() !== \"\") { arg += \" \"+node.append; }\n                // slice whole line by spaces (trying to honour quotes);\n                arg = arg.match(/(?:[^\\s\"]+|\"[^\"]*\")+/g);\n                var cmd = arg.shift();\n                if (/^\".*\"$/.test(cmd)) { cmd = cmd.slice(1,-1); }\n                /* istanbul ignore else  */\n                if (RED.settings.verbose) { node.log(cmd+\" [\"+arg+\"]\"); }\n                child = spawn(cmd,arg);\n                var unknownCommand = (child.pid === undefined);\n                if (node.timer !== 0) {\n                    child.tout = setTimeout(function() { cleanup(child.pid); }, node.timer);\n                }\n                node.activeProcesses[child.pid] = child;\n                child.stdout.on('data', function (data) {\n                    if (node.activeProcesses.hasOwnProperty(child.pid) && node.activeProcesses[child.pid] !== null) {\n                        // console.log('[exec] stdout: ' + data,child.pid);\n                        if (isUtf8(data)) { msg.payload = data.toString(); }\n                        else { msg.payload = data; }\n                        node.send([RED.util.cloneMessage(msg),null,null]);\n                    }\n                });\n                child.stderr.on('data', function (data) {\n                    if (node.activeProcesses.hasOwnProperty(child.pid) && node.activeProcesses[child.pid] !== null) {\n                        if (isUtf8(data)) { msg.payload = data.toString(); }\n                        else { msg.payload = new Buffer(data); }\n                        node.send([null,RED.util.cloneMessage(msg),null]);\n                    }\n                });\n                child.on('close', function (code) {\n                    if (unknownCommand || (node.activeProcesses.hasOwnProperty(child.pid) && node.activeProcesses[child.pid] !== null)) {\n                        delete node.activeProcesses[child.pid];\n                        if (child.tout) { clearTimeout(child.tout); }\n                        msg.payload = code;\n                        if (code === 0) { node.status({}); }\n                        if (code === null) { node.status({fill:\"red\",shape:\"dot\",text:\"timeout\"}); }\n                        else if (code < 0) { node.status({fill:\"red\",shape:\"dot\",text:\"rc: \"+code}); }\n                        else { node.status({fill:\"yellow\",shape:\"dot\",text:\"rc: \"+code}); }\n                        node.send([null,null,RED.util.cloneMessage(msg)]);\n                    }\n                });\n                child.on('error', function (code) {\n                    if (child.tout) { clearTimeout(child.tout); }\n                    delete node.activeProcesses[child.pid];\n                    if (node.activeProcesses.hasOwnProperty(child.pid) && node.activeProcesses[child.pid] !== null) {\n                        node.error(code,RED.util.cloneMessage(msg));\n                    }\n                });\n            }\n            else {\n                var cl = node.cmd;\n                if ((node.addpay === true) && msg.hasOwnProperty(\"payload\")) { cl += \" \"+msg.payload; }\n                if (node.append.trim() !== \"\") { cl += \" \"+node.append; }\n                /* istanbul ignore else  */\n                if (RED.settings.verbose) { node.log(cl); }\n                child = exec(cl, {encoding: 'binary', maxBuffer:10000000}, function (error, stdout, stderr) {\n                    msg.payload = new Buffer(stdout,\"binary\");\n                    if (isUtf8(msg.payload)) { msg.payload = msg.payload.toString(); }\n                    var msg2 = {payload:stderr};\n                    var msg3 = null;\n                    //console.log('[exec] stdout: ' + stdout);\n                    //console.log('[exec] stderr: ' + stderr);\n                    if (error !== null) {\n                        msg3 = {payload:error};\n                        //console.log('[exec] error: ' + error);\n                    }\n                    node.status({});\n                    node.send([msg,msg2,msg3]);\n                    if (child.tout) { clearTimeout(child.tout); }\n                    delete node.activeProcesses[child.pid];\n                });\n                child.on('error',function() {});\n                if (node.timer !== 0) {\n                    child.tout = setTimeout(function() { cleanup(child.pid); }, node.timer);\n                }\n                node.activeProcesses[child.pid] = child;\n            }\n        });\n        this.on('close',function() {\n            for (var pid in node.activeProcesses) {\n                /* istanbul ignore else  */\n                if (node.activeProcesses.hasOwnProperty(pid)) {\n                    if (node.activeProcesses[pid].tout) { clearTimeout(node.activeProcesses[pid].tout); }\n                    // console.log(\"KILLLING\",pid);\n                    var process = node.activeProcesses[pid];\n                    node.activeProcesses[pid] = null;\n                    process.kill();\n                }\n            }\n            node.activeProcesses = {};\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"exec\",ExecNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/80-function.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var util = require(\"util\");\n    var vm = require(\"vm\");\n\n    function sendResults(node,_msgid,msgs) {\n        if (msgs == null) {\n            return;\n        } else if (!util.isArray(msgs)) {\n            msgs = [msgs];\n        }\n        var msgCount = 0;\n        for (var m=0;m<msgs.length;m++) {\n            if (msgs[m]) {\n                if (util.isArray(msgs[m])) {\n                    for (var n=0; n < msgs[m].length; n++) {\n                        if (msgs[m][n] !== null && msgs[m][n] !== undefined) {\n                            msgs[m][n]._msgid = _msgid;\n                            msgCount++;\n                        }\n                    }\n                } else {\n                    if (msgs[m] !== null && msgs[m] !== undefined) {\n                        msgs[m]._msgid = _msgid;\n                        msgCount++;\n                    }\n                }\n            }\n        }\n        if (msgCount>0) {\n            node.send(msgs);\n        }\n    }\n\n    function FunctionNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.name = n.name;\n        this.func = n.func;\n        var functionText = \"var results = null;\"+\n                           \"results = (function(msg){ \"+\n                              \"var __msgid__ = msg._msgid;\"+\n                              \"var node = {\"+\n                                 \"log:__node__.log,\"+\n                                 \"error:__node__.error,\"+\n                                 \"warn:__node__.warn,\"+\n                                 \"on:__node__.on,\"+\n                                 \"status:__node__.status,\"+\n                                 \"send:function(msgs){ __node__.send(__msgid__,msgs);}\"+\n                              \"};\\n\"+\n                              this.func+\"\\n\"+\n                           \"})(msg);\";\n        this.topic = n.topic;\n        this.outstandingTimers = [];\n        this.outstandingIntervals = [];\n        var sandbox = {\n            console:console,\n            util:util,\n            Buffer:Buffer,\n            RED: {\n                util: RED.util\n            },\n            __node__: {\n                log: function() {\n                    node.log.apply(node, arguments);\n                },\n                error: function() {\n                    node.error.apply(node, arguments);\n                },\n                warn: function() {\n                    node.warn.apply(node, arguments);\n                },\n                send: function(id, msgs) {\n                    sendResults(node, id, msgs);\n                },\n                on: function() {\n                    if (arguments[0] === \"input\") {\n                        throw new Error(RED._(\"function.error.inputListener\"));\n                    }\n                    node.on.apply(node, arguments);\n                },\n                status: function() {\n                    node.status.apply(node, arguments);\n                }\n            },\n            context: {\n                set: function() {\n                    node.context().set.apply(node,arguments);\n                },\n                get: function() {\n                    return node.context().get.apply(node,arguments);\n                },\n                get global() {\n                    return node.context().global;\n                },\n                get flow() {\n                    return node.context().flow;\n                }\n            },\n            flow: {\n                set: function() {\n                    node.context().flow.set.apply(node,arguments);\n                },\n                get: function() {\n                    return node.context().flow.get.apply(node,arguments);\n                }\n            },\n            global: {\n                set: function() {\n                    node.context().global.set.apply(node,arguments);\n                },\n                get: function() {\n                    return node.context().global.get.apply(node,arguments);\n                }\n            },\n            setTimeout: function () {\n                var func = arguments[0];\n                var timerId;\n                arguments[0] = function() {\n                    sandbox.clearTimeout(timerId);\n                    try {\n                        func.apply(this,arguments);\n                    } catch(err) {\n                        node.error(err,{});\n                    }\n                };\n                timerId = setTimeout.apply(this,arguments);\n                node.outstandingTimers.push(timerId);\n                return timerId;\n            },\n            clearTimeout: function(id) {\n                clearTimeout(id);\n                var index = node.outstandingTimers.indexOf(id);\n                if (index > -1) {\n                    node.outstandingTimers.splice(index,1);\n                }\n            },\n            setInterval: function() {\n                var func = arguments[0];\n                var timerId;\n                arguments[0] = function() {\n                    try {\n                        func.apply(this,arguments);\n                    } catch(err) {\n                        node.error(err,{});\n                    }\n                };\n                timerId = setInterval.apply(this,arguments);\n                node.outstandingIntervals.push(timerId);\n                return timerId;\n            },\n            clearInterval: function(id) {\n                clearInterval(id);\n                var index = node.outstandingIntervals.indexOf(id);\n                if (index > -1) {\n                    node.outstandingIntervals.splice(index,1);\n                }\n            }\n        };\n        var context = vm.createContext(sandbox);\n        try {\n            this.script = vm.createScript(functionText);\n            this.on(\"input\", function(msg) {\n                try {\n                    var start = process.hrtime();\n                    context.msg = msg;\n                    this.script.runInContext(context);\n                    sendResults(this,msg._msgid,context.results);\n\n                    var duration = process.hrtime(start);\n                    var converted = Math.floor((duration[0] * 1e9 + duration[1])/10000)/100;\n                    this.metric(\"duration\", msg, converted);\n                    if (process.env.NODE_RED_FUNCTION_TIME) {\n                        this.status({fill:\"yellow\",shape:\"dot\",text:\"\"+converted});\n                    }\n                } catch(err) {\n\n                    var line = 0;\n                    var errorMessage;\n                    var stack = err.stack.split(/\\r?\\n/);\n                    if (stack.length > 0) {\n                        while (line < stack.length && stack[line].indexOf(\"ReferenceError\") !== 0) {\n                            line++;\n                        }\n\n                        if (line < stack.length) {\n                            errorMessage = stack[line];\n                            var m = /:(\\d+):(\\d+)$/.exec(stack[line+1]);\n                            if (m) {\n                                var lineno = Number(m[1])-1;\n                                var cha = m[2];\n                                errorMessage += \" (line \"+lineno+\", col \"+cha+\")\";\n                            }\n                        }\n                    }\n                    if (!errorMessage) {\n                        errorMessage = err.toString();\n                    }\n                    this.error(errorMessage, msg);\n                }\n            });\n            this.on(\"close\", function() {\n                while (node.outstandingTimers.length > 0) {\n                    clearTimeout(node.outstandingTimers.pop())\n                }\n                while (node.outstandingIntervals.length > 0) {\n                    clearInterval(node.outstandingIntervals.pop())\n                }\n                this.status({});\n            })\n        } catch(err) {\n            // eg SyntaxError - which v8 doesn't include line number information\n            // so we can't do better than this\n            this.error(err);\n        }\n    }\n    RED.nodes.registerType(\"function\",FunctionNode);\n    RED.library.register(\"functions\");\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/80-template.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var mustache = require(\"mustache\");\n\n    /**\n     * Custom Mustache Context capable to resolve message property and node\n     * flow and global context\n     */\n    function NodeContext(msg, nodeContext,parent) {\n        this.msgContext = new mustache.Context(msg,parent);\n        this.nodeContext = nodeContext;\n    }\n\n    NodeContext.prototype = new mustache.Context();\n\n    NodeContext.prototype.lookup = function (name) {\n        // try message first:\n        try {\n            var value = this.msgContext.lookup(name);\n            if (value !== undefined) {\n                return value;\n            }\n\n            // try node context:\n            var dot = name.indexOf(\".\");\n            if (dot > 0) {\n                var contextName = name.substr(0, dot);\n                var variableName = name.substr(dot + 1);\n\n                if (contextName === \"flow\" && this.nodeContext.flow) {\n                    return this.nodeContext.flow.get(variableName);\n                }\n                else if (contextName === \"global\" && this.nodeContext.global) {\n                    return this.nodeContext.global.get(variableName);\n                }\n            }\n        }catch(err) {\n            throw err;\n        }\n    }\n\n    NodeContext.prototype.push = function push (view) {\n        return new NodeContext(view, this.nodeContext,this.msgContext);\n    };\n\n    function TemplateNode(n) {\n        RED.nodes.createNode(this,n);\n        this.name = n.name;\n        this.field = n.field || \"payload\";\n        this.template = n.template;\n        this.syntax = n.syntax || \"mustache\";\n        this.fieldType = n.fieldType || \"msg\";\n\n        var node = this;\n        node.on(\"input\", function(msg) {\n            try {\n                var value;\n                if (node.syntax === \"mustache\") {\n                    value = mustache.render(node.template,new NodeContext(msg, node.context()));\n                } else {\n                    value = node.template;\n                }\n                if (node.fieldType === 'msg') {\n                    RED.util.setMessageProperty(msg,node.field,value);\n                } else if (node.fieldType === 'flow') {\n                    node.context().flow.set(node.field,value);\n                } else if (node.fieldType === 'global') {\n                    node.context().global.set(node.field,value);\n                }\n                node.send(msg);\n            } catch(err) {\n                node.error(err.message);\n            }\n        });\n    }\n\n    RED.nodes.registerType(\"template\",TemplateNode);\n    RED.library.register(\"templates\");\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/89-delay.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n//Simple node to introduce a pause into a flow\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    var MILLIS_TO_NANOS = 1000000;\n    var SECONDS_TO_NANOS = 1000000000;\n\n    function DelayNode(n) {\n        RED.nodes.createNode(this,n);\n\n        this.pauseType = n.pauseType;\n        this.timeoutUnits = n.timeoutUnits;\n        this.randomUnits = n.randomUnits;\n        this.rateUnits = n.rateUnits;\n\n        if (n.timeoutUnits === \"milliseconds\") {\n            this.timeout = n.timeout;\n        } else if (n.timeoutUnits === \"minutes\") {\n            this.timeout = n.timeout * (60 * 1000);\n        } else if (n.timeoutUnits === \"hours\") {\n            this.timeout = n.timeout * (60 * 60 * 1000);\n        } else if (n.timeoutUnits === \"days\") {\n            this.timeout = n.timeout * (24 * 60 * 60 * 1000);\n        } else {   // Default to seconds\n            this.timeout = n.timeout * 1000;\n        }\n\n        if (n.rateUnits === \"minute\") {\n            this.rate = (60 * 1000)/n.rate;\n        } else if (n.rateUnits === \"hour\") {\n            this.rate = (60 * 60 * 1000)/n.rate;\n        } else if (n.rateUnits === \"day\") {\n            this.rate = (24 * 60 * 60 * 1000)/n.rate;\n        } else {  // Default to seconds\n            this.rate = 1000/n.rate;\n        }\n\n        this.rate *= (n.nbRateUnits > 0 ? n.nbRateUnits : 1);\n\n        if (n.randomUnits === \"milliseconds\") {\n            this.randomFirst = n.randomFirst * 1;\n            this.randomLast = n.randomLast * 1;\n        } else if (n.randomUnits === \"minutes\") {\n            this.randomFirst = n.randomFirst * (60 * 1000);\n            this.randomLast = n.randomLast * (60 * 1000);\n        } else if (n.randomUnits === \"hours\") {\n            this.randomFirst = n.randomFirst * (60 * 60 * 1000);\n            this.randomLast = n.randomLast * (60 * 60 * 1000);\n        } else if (n.randomUnits === \"days\") {\n            this.randomFirst = n.randomFirst * (24 * 60 * 60 * 1000);\n            this.randomLast = n.randomLast * (24 * 60 * 60 * 1000);\n        } else {  // Default to seconds\n            this.randomFirst = n.randomFirst * 1000;\n            this.randomLast = n.randomLast * 1000;\n        }\n\n        this.diff = this.randomLast - this.randomFirst;\n        this.name = n.name;\n        this.idList = [];\n        this.buffer = [];\n        this.intervalID = -1;\n        this.randomID = -1;\n        this.lastSent = null;\n        this.drop = n.drop;\n        var node = this;\n\n        if (node.pauseType === \"delay\") {\n            node.on(\"input\", function(msg) {\n                var id;\n                id = setTimeout(function() {\n                    node.idList.splice(node.idList.indexOf(id),1);\n                    if (node.idList.length === 0) { node.status({}); }\n                    node.send(msg);\n                }, node.timeout);\n                node.idList.push(id);\n                if ((node.timeout > 1000) && (node.idList.length !== 0)) {\n                    node.status({fill:\"blue\",shape:\"dot\",text:\" \"});\n                }\n            });\n\n            node.on(\"close\", function() {\n                for (var i=0; i<node.idList.length; i++ ) {\n                    clearTimeout(node.idList[i]);\n                }\n                node.idList = [];\n                node.status({});\n            });\n\n        } else if (node.pauseType === \"rate\") {\n            var olddepth = 0;\n            node.on(\"input\", function(msg) {\n                if (!node.drop) {\n                    if ( node.intervalID !== -1) {\n                        node.buffer.push(msg);\n                        if (node.buffer.length > 0) {\n                            node.status({text:node.buffer.length});\n                        }\n                        if ((node.buffer.length > 1000) && (olddepth < 1000)) {\n                            olddepth = 1000;\n                            node.warn(node.name + \" \" + RED._(\"delay.error.buffer\"));\n                        }\n                        if ((node.buffer.length > 10000) && (olddepth < 10000)) {\n                            olddepth = 10000;\n                            node.warn(node.name + \" \" + RED._(\"delay.error.buffer1\"));\n                        }\n                    } else {\n                        node.send(msg);\n                        node.intervalID = setInterval(function() {\n                            if (node.buffer.length === 0) {\n                                clearInterval(node.intervalID);\n                                node.intervalID = -1;\n                                node.status({});\n                            }\n                            if (node.buffer.length > 0) {\n                                node.send(node.buffer.shift());\n                                if (node.buffer.length < 1000) { olddepth = 0; }\n                                node.status({text:node.buffer.length});\n                            }\n                        },node.rate);\n                    }\n                } else {\n                    var timeSinceLast;\n                    if (node.lastSent) {\n                        timeSinceLast = process.hrtime(node.lastSent);\n                    }\n                    if (!node.lastSent) { // ensuring that we always send the first message\n                        node.lastSent = process.hrtime();\n                        node.send(msg);\n                    } else if ( ( (timeSinceLast[0] * SECONDS_TO_NANOS) + timeSinceLast[1] ) > (node.rate * MILLIS_TO_NANOS) ) {\n                        node.lastSent = process.hrtime();\n                        node.send(msg);\n                    }\n                }\n            });\n\n            node.on(\"close\", function() {\n                clearInterval(node.intervalID);\n                node.buffer = [];\n                node.status({});\n            });\n\n        } else if ((node.pauseType === \"queue\") || (node.pauseType === \"timed\")) {\n            node.intervalID = setInterval(function() {\n                if (node.pauseType === \"queue\") {\n                    if (node.buffer.length > 0) {\n                        node.send(node.buffer.shift()); // send the first on the queue\n                    }\n                }\n                else {\n                    while (node.buffer.length > 0) {    // send the whole queue\n                        node.send(node.buffer.shift());\n                    }\n                }\n                node.status({text:node.buffer.length});\n            },node.rate);\n\n            node.on(\"input\", function(msg) {\n                if (!msg.hasOwnProperty(\"topic\")) { msg.topic = \"_none_\"; }\n                var hit = false;\n                for (var b in node.buffer) { // check if already in queue\n                    if (msg.topic === node.buffer[b].topic) {\n                        node.buffer[b] = msg; // if so - replace existing entry\n                        hit = true;\n                    }\n                }\n                if (!hit) { node.buffer.push(msg); } // if not add to end of queue\n                node.status({text:node.buffer.length});\n            });\n\n            node.on(\"close\", function() {\n                clearInterval(node.intervalID);\n                node.buffer = [];\n                node.status({});\n            });\n\n        } else if (node.pauseType === \"random\") {\n            node.on(\"input\", function(msg) {\n                var wait = node.randomFirst + (node.diff * Math.random());\n                var id = setTimeout(function() {\n                    node.idList.splice(node.idList.indexOf(id),1);\n                    node.send(msg);\n                }, wait);\n                node.idList.push(id);\n            });\n            \n            node.on(\"close\", function() {\n                for (var i=0; i<node.idList.length; i++ ) {\n                    clearTimeout(node.idList[i]);\n                }\n                node.idList = [];\n            });\n        }\n    }\n    RED.nodes.registerType(\"delay\",DelayNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/89-trigger.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var mustache = require(\"mustache\");\n    function TriggerNode(n) {\n        RED.nodes.createNode(this,n);\n        this.op1 = n.op1 || \"1\";\n        this.op2 = n.op2 || \"0\";\n        this.op1type = n.op1type || \"str\";\n        this.op2type = n.op2type || \"str\";\n\n        if (this.op1type === 'val') {\n            if (this.op1 === 'true' || this.op1 === 'false') {\n                this.op1type = 'bool'\n            } else if (this.op1 === 'null') {\n                this.op1type = 'null';\n                this.op1 = null;\n            } else {\n                this.op1type = 'str';\n            }\n        }\n        if (this.op2type === 'val') {\n            if (this.op2 === 'true' || this.op2 === 'false') {\n                this.op2type = 'bool'\n            } else if (this.op2 === 'null') {\n                this.op2type = 'null';\n                this.op2 = null;\n            } else {\n                this.op2type = 'str';\n            }\n        }\n        this.extend = n.extend || \"false\";\n        this.units = n.units || \"ms\";\n        this.reset = n.reset || '';\n        this.duration = n.duration || 250;\n        if (this.duration <= 0) { this.duration = 0; }\n        else {\n            if (this.units == \"s\") { this.duration = this.duration * 1000; }\n            if (this.units == \"min\") { this.duration = this.duration * 1000 * 60; }\n            if (this.units == \"hr\") { this.duration = this.duration * 1000 *60 * 60; }\n        }\n        this.op1Templated = (this.op1type === 'str' && this.op1.indexOf(\"{{\") != -1);\n        this.op2Templated = (this.op2type === 'str' && this.op2.indexOf(\"{{\") != -1);\n        if ((this.op1type === \"num\") && (!isNaN(this.op1))) { this.op1 = Number(this.op1); }\n        if ((this.op2type === \"num\") && (!isNaN(this.op2))) { this.op2 = Number(this.op2); }\n        if (this.op1 == \"null\") { this.op1 = null; }\n        if (this.op2 == \"null\") { this.op2 = null; }\n        //try { this.op1 = JSON.parse(this.op1); }\n        //catch(e) { this.op1 = this.op1; }\n        //try { this.op2 = JSON.parse(this.op2); }\n        //catch(e) { this.op2 = this.op2; }\n\n        var node = this;\n        var tout = null;\n        var m2;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"reset\") || ((node.reset !== '')&&(msg.payload == node.reset)) ) {\n                clearTimeout(tout);\n                tout = null;\n                node.status({});\n            }\n            else {\n                if ((!tout) && (tout !== 0)) {\n                    if (node.op2type === \"pay\" || node.op2type === \"payl\") { m2 = msg.payload; }\n                    else if (node.op2Templated) { m2 = mustache.render(node.op2,msg); }\n                    else if (node.op2type !== \"nul\") {\n                        m2 = RED.util.evaluateNodeProperty(node.op2,node.op2type,node,msg);\n                    }\n\n                    if (node.op1type === \"pay\") { }\n                    else if (node.op1Templated) { msg.payload = mustache.render(node.op1,msg); }\n                    else if (node.op1type !== \"nul\") {\n                        msg.payload = RED.util.evaluateNodeProperty(node.op1,node.op1type,node,msg);\n                    }\n\n                    if (node.op1type !== \"nul\") { node.send(msg); }\n\n                    if (node.duration === 0) { tout = 0; }\n                    else {\n                        tout = setTimeout(function() {\n                            if (node.op2type !== \"nul\") {\n                                var msg2 = RED.util.cloneMessage(msg);\n                                if (node.op2type === \"flow\" || node.op2type === \"global\") {\n                                    m2 = RED.util.evaluateNodeProperty(node.op2,node.op2type,node,msg);\n                                }\n                                msg2.payload = m2;\n                                node.send(msg2);\n                            }\n                            tout = null;\n                            node.status({});\n                        },node.duration);\n                    }\n                    node.status({fill:\"blue\",shape:\"dot\",text:\" \"});\n                }\n                else if ((node.extend === \"true\" || node.extend === true) && (node.duration > 0)) {\n                    clearTimeout(tout);\n                    if (node.op2type === \"payl\") { m2 = msg.payload; }\n                    tout = setTimeout(function() {\n                        if (node.op2type !== \"nul\") {\n                            var msg2 = RED.util.cloneMessage(msg);\n                            if (node.op2type === \"flow\" || node.op2type === \"global\") {\n                                m2 = RED.util.evaluateNodeProperty(node.op2,node.op2type,node,msg);\n                            }\n                            msg2.payload = m2;\n                            node.send(msg2);\n                        }\n                        tout = null;\n                        node.status({});\n                    },node.duration);\n                } else {\n                    if (node.op2type === \"payl\") { m2 = msg.payload; }\n                }\n            }\n        });\n        this.on(\"close\", function() {\n            if (tout) {\n                clearTimeout(tout);\n            }\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"trigger\",TriggerNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/90-comment.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    function CommentNode(n) {\n        RED.nodes.createNode(this,n);\n    }\n    RED.nodes.registerType(\"comment\",CommentNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/core/98-unknown.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    function UnknownNode(n) {\n        RED.nodes.createNode(this,n);\n    }\n    RED.nodes.registerType(\"unknown\",UnknownNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/hardware/36-rpi-gpio.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var exec = require('child_process').exec;\n    var spawn = require('child_process').spawn;\n    var fs = require('fs');\n\n    var gpioCommand = __dirname+'/nrgpio';\n\n    try {\n        var cpuinfo = fs.readFileSync(\"/proc/cpuinfo\").toString();\n        if (cpuinfo.indexOf(\": BCM\") === -1) { throw \"Info : \"+RED._(\"rpi-gpio.errors.ignorenode\"); }\n    } catch(err) {\n        throw \"Info : \"+RED._(\"rpi-gpio.errors.ignorenode\");\n    }\n\n    try {\n        fs.statSync(\"/usr/share/doc/python-rpi.gpio\"); // test on Raspbian\n        // /usr/lib/python2.7/dist-packages/RPi/GPIO\n    } catch(err) {\n        try {\n            fs.statSync(\"/usr/lib/python2.7/site-packages/RPi/GPIO\"); // test on Arch\n        }\n        catch(err) {\n            RED.log.warn(RED._(\"rpi-gpio.errors.libnotfound\"));\n            throw \"Warning : \"+RED._(\"rpi-gpio.errors.libnotfound\");\n        }\n    }\n\n    if ( !(1 & parseInt((fs.statSync(gpioCommand).mode & parseInt(\"777\", 8)).toString(8)[0]) )) {\n        RED.log.error(RED._(\"rpi-gpio.errors.needtobeexecutable\",{command:gpioCommand}));\n        throw \"Error : \"+RED._(\"rpi-gpio.errors.mustbeexecutable\");\n    }\n\n    // the magic to make python print stuff immediately\n    process.env.PYTHONUNBUFFERED = 1;\n\n    var pinsInUse = {};\n    var pinTypes = {\"out\":RED._(\"rpi-gpio.types.digout\"), \"tri\":RED._(\"rpi-gpio.types.input\"), \"up\":RED._(\"rpi-gpio.types.pullup\"), \"down\":RED._(\"rpi-gpio.types.pulldown\"), \"pwm\":RED._(\"rpi-gpio.types.pwmout\")};\n\n    function GPIOInNode(n) {\n        RED.nodes.createNode(this,n);\n        this.buttonState = -1;\n        this.pin = n.pin;\n        this.intype = n.intype;\n        this.read = n.read || false;\n        this.debounce = Number(n.debounce || 25);\n        if (this.read) { this.buttonState = -2; }\n        var node = this;\n        if (!pinsInUse.hasOwnProperty(this.pin)) {\n            pinsInUse[this.pin] = this.intype;\n        }\n        else {\n            if ((pinsInUse[this.pin] !== this.intype)||(pinsInUse[this.pin] === \"pwm\")) {\n                node.warn(RED._(\"rpi-gpio.errors.alreadyset\",{pin:this.pin,type:pinTypes[pinsInUse[this.pin]]}));\n            }\n        }\n\n        if (node.pin !== undefined) {\n            node.child = spawn(gpioCommand, [\"in\",node.pin,node.intype,node.debounce]);\n            node.running = true;\n            node.status({fill:\"green\",shape:\"dot\",text:\"common.status.ok\"});\n\n            node.child.stdout.on('data', function (data) {\n                var d = data.toString().trim().split(\"\\n\");\n                for (var i = 0; i < d.length; i++) {\n                    if (node.running && node.buttonState !== -1 && !isNaN(Number(d[i]))) {\n                        node.send({ topic:\"pi/\"+node.pin, payload:Number(d[i]) });\n                    }\n                    node.buttonState = d[i];\n                    node.status({fill:\"green\",shape:\"dot\",text:d[i]});\n                    if (RED.settings.verbose) { node.log(\"out: \"+d[i]+\" :\"); }\n                }\n            });\n\n            node.child.stderr.on('data', function (data) {\n                if (RED.settings.verbose) { node.log(\"err: \"+data+\" :\"); }\n            });\n\n            node.child.on('close', function (code) {\n                node.running = false;\n                node.child = null;\n                if (RED.settings.verbose) { node.log(RED._(\"rpi-gpio.status.closed\")); }\n                if (node.done) {\n                    node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n                    node.done();\n                }\n                else { node.status({fill:\"red\",shape:\"ring\",text:\"rpi-gpio.status.stopped\"}); }\n            });\n\n            node.child.on('error', function (err) {\n                if (err.errno === \"ENOENT\") { node.error(RED._(\"rpi-gpio.errors.commandnotfound\")); }\n                else if (err.errno === \"EACCES\") { node.error(RED._(\"rpi-gpio.errors.commandnotexecutable\")); }\n                else { node.error(RED._(\"rpi-gpio.errors.error\",{error:err.errno})) }\n            });\n\n        }\n        else {\n            node.warn(RED._(\"rpi-gpio.errors.invalidpin\")+\": \"+node.pin);\n        }\n\n        node.on(\"close\", function(done) {\n            node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n            delete pinsInUse[node.pin];\n            if (node.child != null) {\n                node.done = done;\n                node.child.stdin.write(\"close \"+node.pin);\n                node.child.kill('SIGKILL');\n            }\n            else { done(); }\n        });\n    }\n    RED.nodes.registerType(\"rpi-gpio in\",GPIOInNode);\n\n    function GPIOOutNode(n) {\n        RED.nodes.createNode(this,n);\n        this.pin = n.pin;\n        this.set = n.set || false;\n        this.level = n.level || 0;\n        this.out = n.out || \"out\";\n        var node = this;\n        if (!pinsInUse.hasOwnProperty(this.pin)) {\n            pinsInUse[this.pin] = this.out;\n        }\n        else {\n            if ((pinsInUse[this.pin] !== this.out)||(pinsInUse[this.pin] === \"pwm\")) {\n                node.warn(RED._(\"rpi-gpio.errors.alreadyset\",{pin:this.pin,type:pinTypes[pinsInUse[this.pin]]}));\n            }\n        }\n\n        function inputlistener(msg) {\n            if (msg.payload === \"true\") { msg.payload = true; }\n            if (msg.payload === \"false\") { msg.payload = false; }\n            var out = Number(msg.payload);\n            var limit = 1;\n            if (node.out === \"pwm\") { limit = 100; }\n            if ((out >= 0) && (out <= limit)) {\n                if (RED.settings.verbose) { node.log(\"out: \"+msg.payload); }\n                if (node.child !== null) {\n                    node.child.stdin.write(msg.payload+\"\\n\");\n                    node.status({fill:\"green\",shape:\"dot\",text:msg.payload.toString()});\n                }\n                else {\n                    node.error(RED._(\"rpi-gpio.errors.pythoncommandnotfound\"),msg);\n                    node.status({fill:\"red\",shape:\"ring\",text:\"rpi-gpio.status.not-running\"});\n                }\n            }\n            else { node.warn(RED._(\"rpi-gpio.errors.invalidinput\")+\": \"+out); }\n        }\n\n        if (node.pin !== undefined) {\n            if (node.set && (node.out === \"out\")) {\n                node.child = spawn(gpioCommand, [node.out,node.pin,node.level]);\n                node.status({fill:\"green\",shape:\"dot\",text:node.level});\n            } else {\n                node.child = spawn(gpioCommand, [node.out,node.pin]);\n                node.status({fill:\"green\",shape:\"dot\",text:\"common.status.ok\"});\n            }\n            node.running = true;\n\n            node.on(\"input\", inputlistener);\n\n            node.child.stdout.on('data', function (data) {\n                if (RED.settings.verbose) { node.log(\"out: \"+data+\" :\"); }\n            });\n\n            node.child.stderr.on('data', function (data) {\n                if (RED.settings.verbose) { node.log(\"err: \"+data+\" :\"); }\n            });\n\n            node.child.on('close', function (code) {\n                node.child = null;\n                node.running = false;\n                if (RED.settings.verbose) { node.log(RED._(\"rpi-gpio.status.closed\")); }\n                if (node.done) {\n                    node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n                    node.done();\n                }\n                else { node.status({fill:\"red\",shape:\"ring\",text:\"rpi-gpio.status.stopped\"}); }\n            });\n\n            node.child.on('error', function (err) {\n                if (err.errno === \"ENOENT\") { node.error(RED._(\"rpi-gpio.errors.commandnotfound\")); }\n                else if (err.errno === \"EACCES\") { node.error(RED._(\"rpi-gpio.errors.commandnotexecutable\")); }\n                else { node.error(RED._(\"rpi-gpio.errors.error\")+': ' + err.errno); }\n            });\n\n        }\n        else {\n            node.warn(RED._(\"rpi-gpio.errors.invalidpin\")+\": \"+node.pin);\n        }\n\n        node.on(\"close\", function(done) {\n            node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n            delete pinsInUse[node.pin];\n            if (node.child != null) {\n                node.done = done;\n                node.child.stdin.write(\"close \"+node.pin);\n                node.child.kill('SIGKILL');\n            }\n            else { done(); }\n        });\n\n    }\n    RED.nodes.registerType(\"rpi-gpio out\",GPIOOutNode);\n\n    function PiMouseNode(n) {\n        RED.nodes.createNode(this,n);\n        this.butt = n.butt || 7;\n        var node = this;\n\n        node.child = spawn(gpioCommand+\".py\", [\"mouse\",node.butt]);\n        node.status({fill:\"green\",shape:\"dot\",text:\"common.status.ok\"});\n\n        node.child.stdout.on('data', function (data) {\n            data = Number(data);\n            if (data === 1) { node.send({ topic:\"pi/mouse\", button:data, payload:1 }); }\n            else { node.send({ topic:\"pi/mouse\", button:data, payload:0 }); }\n        });\n\n        node.child.stderr.on('data', function (data) {\n            if (RED.settings.verbose) { node.log(\"err: \"+data+\" :\"); }\n        });\n\n        node.child.on('close', function (code) {\n            node.child = null;\n            node.running = false;\n            if (RED.settings.verbose) { node.log(RED._(\"rpi-gpio.status.closed\")); }\n            if (node.done) {\n                node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n                node.done();\n            }\n            else { node.status({fill:\"red\",shape:\"ring\",text:\"rpi-gpio.status.stopped\"}); }\n        });\n\n        node.child.on('error', function (err) {\n            if (err.errno === \"ENOENT\") { node.error(RED._(\"rpi-gpio.errors.commandnotfound\")); }\n            else if (err.errno === \"EACCES\") { node.error(RED._(\"rpi-gpio.errors.commandnotexecutable\")); }\n            else { node.error(RED._(\"rpi-gpio.errors.error\")+': ' + err.errno); }\n        });\n\n        node.on(\"close\", function(done) {\n            node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n            if (node.child != null) {\n                node.done = done;\n                node.child.kill('SIGINT');\n                node.child = null;\n            }\n            else { done(); }\n        });\n    }\n    RED.nodes.registerType(\"rpi-mouse\",PiMouseNode);\n\n    function PiKeyboardNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n\n        node.child = spawn(gpioCommand+\".py\", [\"kbd\",\"0\"]);\n        node.status({fill:\"green\",shape:\"dot\",text:\"common.status.ok\"});\n\n        node.child.stdout.on('data', function (data) {\n            var b = data.toString().trim().split(\",\");\n            var act = \"up\";\n            if (b[1] === \"1\") { act = \"down\"; }\n            if (b[1] === \"2\") { act = \"repeat\"; }\n            node.send({ topic:\"pi/key\", payload:Number(b[0]), action:act });\n        });\n\n        node.child.stderr.on('data', function (data) {\n            if (RED.settings.verbose) { node.log(\"err: \"+data+\" :\"); }\n        });\n\n        node.child.on('close', function (code) {\n            node.running = false;\n            node.child = null;\n            if (RED.settings.verbose) { node.log(RED._(\"rpi-gpio.status.closed\")); }\n            if (node.done) {\n                node.status({fill:\"grey\",shape:\"ring\",text:\"rpi-gpio.status.closed\"});\n                node.done();\n            }\n            else { node.status({fill:\"red\",shape:\"ring\",text:\"rpi-gpio.status.stopped\"}); }\n        });\n\n        node.child.on('error', function (err) {\n            if (err.errno === \"ENOENT\") { node.error(RED._(\"rpi-gpio.errors.commandnotfound\")); }\n            else if (err.errno === \"EACCES\") { node.error(RED._(\"rpi-gpio.errors.commandnotexecutable\")); }\n            else { node.error(RED._(\"rpi-gpio.errors.error\")+': ' + err.errno); }\n        });\n\n        node.on(\"close\", function(done) {\n            node.status({});\n            if (node.child != null) {\n                node.done = done;\n                node.child.kill('SIGINT');\n                node.child = null;\n            }\n            else { done(); }\n        });\n    }\n    RED.nodes.registerType(\"rpi-keyboard\",PiKeyboardNode);\n\n    var pitype = { type:\"\" };\n    exec(gpioCommand+\" info\", function(err,stdout,stderr) {\n        if (err) {\n            RED.log.info(RED._(\"rpi-gpio.errors.version\"));\n        }\n        else {\n            try {\n                var info = JSON.parse( stdout.trim().replace(/\\'/g,\"\\\"\") );\n                pitype.type = info[\"TYPE\"];\n            }\n            catch(e) {\n                RED.log.info(RED._(\"rpi-gpio.errors.sawpitype\"),stdout.trim());\n            }\n        }\n    });\n\n    RED.httpAdmin.get('/rpi-gpio/:id', RED.auth.needsPermission('rpi-gpio.read'), function(req,res) {\n        res.json(pitype);\n    });\n\n    RED.httpAdmin.get('/rpi-pins/:id', RED.auth.needsPermission('rpi-gpio.read'), function(req,res) {\n        res.json(pinsInUse);\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/05-tls.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require('fs');\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function TLSConfig(n) {\n        RED.nodes.createNode(this,n);\n        this.valid = true;\n        var certPath = n.cert.trim();\n        var keyPath = n.key.trim();\n        var caPath = n.ca.trim();\n\n        if ( (certPath.length > 0) !== (keyPath.length > 0)) {\n            this.valid = false;\n            this.error(RED._(\"tls.error.missing-file\"));\n            return;\n        }\n        this.verifyservercert = n.verifyservercert;\n\n        try {\n            if (certPath) {\n                this.cert = fs.readFileSync(certPath);\n            }\n            if (keyPath) {\n                this.key = fs.readFileSync(keyPath);\n            }\n            if (caPath) {\n                this.ca = fs.readFileSync(caPath);\n            }\n        } catch(err) {\n            this.valid = false;\n            this.error(err.toString());\n            return;\n        }\n    }\n    RED.nodes.registerType(\"tls-config\",TLSConfig);\n\n    TLSConfig.prototype.addTLSOptions = function(opts) {\n        if (this.valid) {\n            if (this.key) {\n                opts.key = this.key;\n            }\n            if (this.cert) {\n                opts.cert = this.cert;\n            }\n            if (this.ca) {\n                opts.ca = this.ca;\n            }\n            opts.rejectUnauthorized = this.verifyservercert;\n        }\n        return opts;\n    }\n\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/10-mqtt.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var mqtt = require(\"mqtt\");\n    var util = require(\"util\");\n    var isUtf8 = require('is-utf8');\n\n    function matchTopic(ts,t) {\n        if (ts == \"#\") {\n            return true;\n        }\n        var re = new RegExp(\"^\"+ts.replace(/([\\[\\]\\?\\(\\)\\\\\\\\$\\^\\*\\.|])/g,\"\\\\$1\").replace(/\\+/g,\"[^/]+\").replace(/\\/#$/,\"(\\/.*)?\")+\"$\");\n        return re.test(t);\n    }\n\n    function MQTTBrokerNode(n) {\n        RED.nodes.createNode(this,n);\n\n        // Configuration options passed by Node Red\n        this.broker = n.broker;\n        this.port = n.port;\n        this.clientid = n.clientid;\n        this.usetls = n.usetls;\n        this.verifyservercert = n.verifyservercert;\n        this.compatmode = n.compatmode;\n        this.keepalive = n.keepalive;\n        this.cleansession = n.cleansession;\n\n        // Config node state\n        this.brokerurl = \"\";\n        this.connected = false;\n        this.connecting = false;\n        this.closing = false;\n        this.options = {};\n        this.queue = [];\n        this.subscriptions = {};\n\n        if (n.birthTopic) {\n            this.birthMessage = {\n                topic: n.birthTopic,\n                payload: n.birthPayload || \"\",\n                qos: Number(n.birthQos||0),\n                retain: n.birthRetain==\"true\"|| n.birthRetain===true\n            };\n        }\n\n        if (this.credentials) {\n            this.username = this.credentials.user;\n            this.password = this.credentials.password;\n        }\n\n        // If the config node is missing certain options (it was probably deployed prior to an update to the node code),\n        // select/generate sensible options for the new fields\n        if (typeof this.usetls === 'undefined'){\n            this.usetls = false;\n        }\n        if (typeof this.compatmode === 'undefined'){\n            this.compatmode = true;\n        }\n        if (typeof this.verifyservercert === 'undefined'){\n            this.verifyservercert = false;\n        }\n        if (typeof this.keepalive === 'undefined'){\n            this.keepalive = 60;\n        } else if (typeof this.keepalive === 'string') {\n            this.keepalive = Number(this.keepalive);\n        }\n        if (typeof this.cleansession === 'undefined') {\n            this.cleansession = true;\n        }\n\n        // Create the URL to pass in to the MQTT.js library\n        if (this.brokerurl === \"\") {\n            if (this.usetls) {\n                this.brokerurl=\"mqtts://\";\n            } else {\n                this.brokerurl=\"mqtt://\";\n            }\n            if (this.broker !== \"\") {\n                this.brokerurl = this.brokerurl+this.broker+\":\"+this.port;\n            } else {\n                this.brokerurl = this.brokerurl+\"localhost:1883\";\n            }\n        }\n\n        if (!this.cleansession && !this.clientid) {\n            this.cleansession = true;\n            this.warn(RED._(\"mqtt.errors.nonclean-missingclientid\"));\n        }\n\n        // Build options for passing to the MQTT.js API\n        this.options.clientId = this.clientid || 'mqtt_' + (1+Math.random()*4294967295).toString(16);\n        this.options.username = this.username;\n        this.options.password = this.password;\n        this.options.keepalive = this.keepalive;\n        this.options.clean = this.cleansession;\n        this.options.reconnectPeriod = RED.settings.mqttReconnectTime||5000;\n        if (this.compatmode == \"true\" || this.compatmode === true){\n            this.options.protocolId = 'MQIsdp';\n            this.options.protocolVersion = 3;\n        }\n        if (this.usetls && n.tls) {\n            var tlsNode = RED.nodes.getNode(n.tls);\n            if (tlsNode) {\n                tlsNode.addTLSOptions(this.options);\n            }\n        }\n        // If there's no rejectUnauthorized already, then this could be an\n        // old config where this option was provided on the broker node and\n        // not the tls node\n        if (typeof this.options.rejectUnauthorized === 'undefined') {\n            this.options.rejectUnauthorized = (this.verifyservercert == \"true\" || this.verifyservercert === true);\n        }\n\n        if (n.willTopic) {\n            this.options.will = {\n                topic: n.willTopic,\n                payload: n.willPayload || \"\",\n                qos: Number(n.willQos||0),\n                retain: n.willRetain==\"true\"|| n.willRetain===true\n            };\n        }\n\n        // Define functions called by MQTT in and out nodes\n        var node = this;\n        this.users = {};\n\n        this.register = function(mqttNode){\n            node.users[mqttNode.id] = mqttNode;\n            if (Object.keys(node.users).length === 1) {\n                node.connect();\n            }\n        };\n\n        this.deregister = function(mqttNode,done){\n            delete node.users[mqttNode.id];\n            if (node.closing) {\n                return done();\n            }\n            if (Object.keys(node.users).length === 0) {\n                if (node.client && node.client.connected) {\n                    return node.client.end(done);\n                } else {\n                    node.client.end();\n                    return done();\n                }\n            }\n            done();\n        };\n\n        this.connect = function () {\n            if (!node.connected && !node.connecting) {\n                node.connecting = true;\n                node.client = mqtt.connect(node.brokerurl ,node.options);\n                node.client.setMaxListeners(0);\n                // Register successful connect or reconnect handler\n                node.client.on('connect', function () {\n                    node.connecting = false;\n                    node.connected = true;\n                    node.log(RED._(\"mqtt.state.connected\",{broker:(node.clientid?node.clientid+\"@\":\"\")+node.brokerurl}));\n                    for (var id in node.users) {\n                        if (node.users.hasOwnProperty(id)) {\n                            node.users[id].status({fill:\"green\",shape:\"dot\",text:\"node-red:common.status.connected\"});\n                        }\n                    }\n                    // Remove any existing listeners before resubscribing to avoid duplicates in the event of a re-connection\n                    node.client.removeAllListeners('message');\n\n                    // Re-subscribe to stored topics\n                    for (var s in node.subscriptions) {\n                        if (node.subscriptions.hasOwnProperty(s)) {\n                            var topic = s;\n                            var qos = 0;\n                            for (var r in node.subscriptions[s]) {\n                                if (node.subscriptions[s].hasOwnProperty(r)) {\n                                    qos = Math.max(qos,node.subscriptions[s][r].qos);\n                                    node.client.on('message',node.subscriptions[s][r].handler);\n                                }\n                            }\n                            var options = {qos: qos};\n                            node.client.subscribe(topic, options);\n                        }\n                    }\n\n                    // Send any birth message\n                    if (node.birthMessage) {\n                        node.publish(node.birthMessage);\n                    }\n                });\n                node.client.on(\"reconnect\", function() {\n                    for (var id in node.users) {\n                        if (node.users.hasOwnProperty(id)) {\n                            node.users[id].status({fill:\"yellow\",shape:\"ring\",text:\"node-red:common.status.connecting\"});\n                        }\n                    }\n                })\n                // Register disconnect handlers\n                node.client.on('close', function () {\n                    if (node.connected) {\n                        node.connected = false;\n                        node.log(RED._(\"mqtt.state.disconnected\",{broker:(node.clientid?node.clientid+\"@\":\"\")+node.brokerurl}));\n                        for (var id in node.users) {\n                            if (node.users.hasOwnProperty(id)) {\n                                node.users[id].status({fill:\"red\",shape:\"ring\",text:\"node-red:common.status.disconnected\"});\n                            }\n                        }\n                    } else if (node.connecting) {\n                        node.log(RED._(\"mqtt.state.connect-failed\",{broker:(node.clientid?node.clientid+\"@\":\"\")+node.brokerurl}));\n                    }\n                });\n\n                // Register connect error handler\n                node.client.on('error', function (error) {\n                    if (node.connecting) {\n                        node.client.end();\n                        node.connecting = false;\n                    }\n                });\n            }\n        };\n\n        this.subscribe = function (topic,qos,callback,ref) {\n            ref = ref||0;\n            node.subscriptions[topic] = node.subscriptions[topic]||{};\n            var sub = {\n                topic:topic,\n                qos:qos,\n                handler:function(mtopic,mpayload, mpacket) {\n                    if (matchTopic(topic,mtopic)) {\n                        callback(mtopic,mpayload, mpacket);\n                    }\n                },\n                ref: ref\n            };\n            node.subscriptions[topic][ref] = sub;\n            if (node.connected) {\n                node.client.on('message',sub.handler);\n                var options = {};\n                options.qos = qos;\n                node.client.subscribe(topic, options);\n            }\n        };\n\n        this.unsubscribe = function (topic, ref) {\n            ref = ref||0;\n            var sub = node.subscriptions[topic];\n            if (sub) {\n                if (sub[ref]) {\n                    node.client.removeListener('message',sub[ref].handler);\n                    delete sub[ref];\n                }\n                if (Object.keys(sub).length === 0) {\n                    delete node.subscriptions[topic];\n                    if (node.connected){\n                        node.client.unsubscribe(topic);\n                    }\n                }\n            }\n        };\n\n        this.publish = function (msg) {\n            if (node.connected) {\n                if (!Buffer.isBuffer(msg.payload)) {\n                    if (typeof msg.payload === \"object\") {\n                        msg.payload = JSON.stringify(msg.payload);\n                    } else if (typeof msg.payload !== \"string\") {\n                        msg.payload = \"\" + msg.payload;\n                    }\n                }\n\n                var options = {\n                    qos: msg.qos || 0,\n                    retain: msg.retain || false\n                };\n                node.client.publish(msg.topic, msg.payload, options, function (err){return});\n            }\n        };\n\n        this.on('close', function(done) {\n            this.closing = true;\n            if (this.connected) {\n                this.client.once('close', function() {\n                    done();\n                });\n                this.client.end();\n            } else if (this.connecting) {\n                node.client.end();\n                done();\n            } else {\n                done();\n            }\n        });\n\n    }\n\n    RED.nodes.registerType(\"mqtt-broker\",MQTTBrokerNode,{\n        credentials: {\n            user: {type:\"text\"},\n            password: {type: \"password\"}\n        }\n    });\n\n    function MQTTInNode(n) {\n        RED.nodes.createNode(this,n);\n        this.topic = n.topic;\n        this.qos = parseInt(n.qos);\n        if (isNaN(this.qos) || this.qos < 0 || this.qos > 2) {\n            this.qos = 2;\n        }\n        this.broker = n.broker;\n        this.brokerConn = RED.nodes.getNode(this.broker);\n        if (!/^(#$|(\\+|[^+#]*)(\\/(\\+|[^+#]*))*(\\/(\\+|#|[^+#]*))?$)/.test(this.topic)) {\n            return this.warn(RED._(\"mqtt.errors.invalid-topic\"));\n        }\n        var node = this;\n        if (this.brokerConn) {\n            this.status({fill:\"red\",shape:\"ring\",text:\"node-red:common.status.disconnected\"});\n            if (this.topic) {\n                node.brokerConn.register(this);\n                this.brokerConn.subscribe(this.topic,this.qos,function(topic,payload,packet) {\n                    if (isUtf8(payload)) { payload = payload.toString(); }\n                    var msg = {topic:topic,payload:payload, qos: packet.qos, retain: packet.retain};\n                    if ((node.brokerConn.broker === \"localhost\")||(node.brokerConn.broker === \"127.0.0.1\")) {\n                        msg._topic = topic;\n                    }\n                    node.send(msg);\n                }, this.id);\n                if (this.brokerConn.connected) {\n                    node.status({fill:\"green\",shape:\"dot\",text:\"node-red:common.status.connected\"});\n                }\n            }\n            else {\n                this.error(RED._(\"mqtt.errors.not-defined\"));\n            }\n            this.on('close', function(done) {\n                if (node.brokerConn) {\n                    node.brokerConn.unsubscribe(node.topic,node.id);\n                    node.brokerConn.deregister(node,done);\n                }\n            });\n        } else {\n            this.error(RED._(\"mqtt.errors.missing-config\"));\n        }\n    }\n    RED.nodes.registerType(\"mqtt in\",MQTTInNode);\n\n    function MQTTOutNode(n) {\n        RED.nodes.createNode(this,n);\n        this.topic = n.topic;\n        this.qos = n.qos || null;\n        this.retain = n.retain;\n        this.broker = n.broker;\n        this.brokerConn = RED.nodes.getNode(this.broker);\n        var node = this;\n\n        if (this.brokerConn) {\n            this.status({fill:\"red\",shape:\"ring\",text:\"node-red:common.status.disconnected\"});\n            this.on(\"input\",function(msg) {\n                if (msg.qos) {\n                    msg.qos = parseInt(msg.qos);\n                    if ((msg.qos !== 0) && (msg.qos !== 1) && (msg.qos !== 2)) {\n                        msg.qos = null;\n                    }\n                }\n                msg.qos = Number(node.qos || msg.qos || 0);\n                msg.retain = node.retain || msg.retain || false;\n                msg.retain = ((msg.retain === true) || (msg.retain === \"true\")) || false;\n                if (node.topic) {\n                    msg.topic = node.topic;\n                }\n                if ( msg.hasOwnProperty(\"payload\")) {\n                    if (msg.hasOwnProperty(\"topic\") && (typeof msg.topic === \"string\") && (msg.topic !== \"\")) { // topic must exist\n                        this.brokerConn.publish(msg);  // send the message\n                    }\n                    else { node.warn(RED._(\"mqtt.errors.invalid-topic\")); }\n                }\n            });\n            if (this.brokerConn.connected) {\n                node.status({fill:\"green\",shape:\"dot\",text:\"node-red:common.status.connected\"});\n            }\n            node.brokerConn.register(node);\n            this.on('close', function(done) {\n                node.brokerConn.deregister(node,done);\n            });\n        } else {\n            this.error(RED._(\"mqtt.errors.missing-config\"));\n        }\n    }\n    RED.nodes.registerType(\"mqtt out\",MQTTOutNode);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/21-httpin.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var bodyParser = require(\"body-parser\");\n    var cookieParser = require(\"cookie-parser\");\n    var getBody = require('raw-body');\n    var cors = require('cors');\n    var jsonParser = bodyParser.json();\n    var urlencParser = bodyParser.urlencoded({extended:true});\n    var onHeaders = require('on-headers');\n    var typer = require('media-typer');\n    var isUtf8 = require('is-utf8');\n\n    function rawBodyParser(req, res, next) {\n        if (req.skipRawBodyParser) { next(); } // don't parse this if told to skip\n        if (req._body) { return next(); }\n        req.body = \"\";\n        req._body = true;\n\n        var isText = true;\n        var checkUTF = false;\n\n        if (req.headers['content-type']) {\n            var parsedType = typer.parse(req.headers['content-type'])\n            if (parsedType.type === \"text\") {\n                isText = true;\n            } else if (parsedType.subtype === \"xml\" || parsedType.suffix === \"xml\") {\n                isText = true;\n            } else if (parsedType.type !== \"application\") {\n                isText = false;\n            } else if (parsedType.subtype !== \"octet-stream\") {\n                checkUTF = true;\n            } else {\n                // applicatino/octet-stream\n                isText = false;\n            }\n        }\n\n        getBody(req, {\n            length: req.headers['content-length'],\n            encoding: isText ? \"utf8\" : null\n        }, function (err, buf) {\n            if (err) { return next(err); }\n            if (!isText && checkUTF && isUtf8(buf)) {\n                buf = buf.toString()\n            }\n            req.body = buf;\n            next();\n        });\n    }\n\n    var corsSetup = false;\n\n    function createRequestWrapper(node,req) {\n        // This misses a bunch of properties (eg headers). Before we use this function\n        // need to ensure it captures everything documented by Express and HTTP modules.\n        var wrapper = {\n            _req: req\n        };\n        var toWrap = [\n            \"param\",\n            \"get\",\n            \"is\",\n            \"acceptsCharset\",\n            \"acceptsLanguage\",\n            \"app\",\n            \"baseUrl\",\n            \"body\",\n            \"cookies\",\n            \"fresh\",\n            \"hostname\",\n            \"ip\",\n            \"ips\",\n            \"originalUrl\",\n            \"params\",\n            \"path\",\n            \"protocol\",\n            \"query\",\n            \"route\",\n            \"secure\",\n            \"signedCookies\",\n            \"stale\",\n            \"subdomains\",\n            \"xhr\",\n            \"socket\" // TODO: tidy this up\n        ];\n        toWrap.forEach(function(f) {\n            if (typeof req[f] === \"function\") {\n                wrapper[f] = function() {\n                    node.warn(RED._(\"httpin.errors.deprecated-call\",{method:\"msg.req.\"+f}));\n                    var result = req[f].apply(req,arguments);\n                    if (result === req) {\n                        return wrapper;\n                    } else {\n                        return result;\n                    }\n                }\n            } else {\n                wrapper[f] = req[f];\n            }\n        });\n\n\n        return wrapper;\n    }\n    function createResponseWrapper(node,res) {\n        var wrapper = {\n            _res: res\n        };\n        var toWrap = [\n            \"append\",\n            \"attachment\",\n            \"cookie\",\n            \"clearCookie\",\n            \"download\",\n            \"end\",\n            \"format\",\n            \"get\",\n            \"json\",\n            \"jsonp\",\n            \"links\",\n            \"location\",\n            \"redirect\",\n            \"render\",\n            \"send\",\n            \"sendfile\",\n            \"sendFile\",\n            \"sendStatus\",\n            \"set\",\n            \"status\",\n            \"type\",\n            \"vary\"\n        ];\n        toWrap.forEach(function(f) {\n            wrapper[f] = function() {\n                node.warn(RED._(\"httpin.errors.deprecated-call\",{method:\"msg.res.\"+f}));\n                var result = res[f].apply(res,arguments);\n                if (result === res) {\n                    return wrapper;\n                } else {\n                    return result;\n                }\n            }\n        });\n        return wrapper;\n    }\n\n    var corsHandler = function(req,res,next) { next(); }\n\n    if (RED.settings.httpNodeCors) {\n        corsHandler = cors(RED.settings.httpNodeCors);\n        RED.httpNode.options(\"*\",corsHandler);\n    }\n\n    function HTTPIn(n) {\n        RED.nodes.createNode(this,n);\n        if (RED.settings.httpNodeRoot !== false) {\n\n            if (!n.url) {\n                this.warn(RED._(\"httpin.errors.missing-path\"));\n                return;\n            }\n            this.url = n.url;\n            this.method = n.method;\n            this.swaggerDoc = n.swaggerDoc;\n\n            var node = this;\n\n            this.errorHandler = function(err,req,res,next) {\n                node.warn(err);\n                res.sendStatus(500);\n            };\n\n            this.callback = function(req,res) {\n                var msgid = RED.util.generateId();\n                res._msgid = msgid;\n                if (node.method.match(/^(post|delete|put|options|patch)$/)) {\n                    node.send({_msgid:msgid,req:req,res:createResponseWrapper(node,res),payload:req.body});\n                } else if (node.method == \"get\") {\n                    node.send({_msgid:msgid,req:req,res:createResponseWrapper(node,res),payload:req.query});\n                } else {\n                    node.send({_msgid:msgid,req:req,res:createResponseWrapper(node,res)});\n                }\n            };\n\n            var httpMiddleware = function(req,res,next) { next(); }\n\n            if (RED.settings.httpNodeMiddleware) {\n                if (typeof RED.settings.httpNodeMiddleware === \"function\") {\n                    httpMiddleware = RED.settings.httpNodeMiddleware;\n                }\n            }\n\n            var metricsHandler = function(req,res,next) { next(); }\n            if (this.metric()) {\n                metricsHandler = function(req, res, next) {\n                    var startAt = process.hrtime();\n                    onHeaders(res, function() {\n                        if (res._msgid) {\n                            var diff = process.hrtime(startAt);\n                            var ms = diff[0] * 1e3 + diff[1] * 1e-6;\n                            var metricResponseTime = ms.toFixed(3);\n                            var metricContentLength = res._headers[\"content-length\"];\n                            //assuming that _id has been set for res._metrics in HttpOut node!\n                            node.metric(\"response.time.millis\", {_msgid:res._msgid} , metricResponseTime);\n                            node.metric(\"response.content-length.bytes\", {_msgid:res._msgid} , metricContentLength);\n                        }\n                    });\n                    next();\n                };\n            }\n\n            if (this.method == \"get\") {\n                RED.httpNode.get(this.url,cookieParser(),httpMiddleware,corsHandler,metricsHandler,this.callback,this.errorHandler);\n            } else if (this.method == \"post\") {\n                RED.httpNode.post(this.url,cookieParser(),httpMiddleware,corsHandler,metricsHandler,jsonParser,urlencParser,rawBodyParser,this.callback,this.errorHandler);\n            } else if (this.method == \"put\") {\n                RED.httpNode.put(this.url,cookieParser(),httpMiddleware,corsHandler,metricsHandler,jsonParser,urlencParser,rawBodyParser,this.callback,this.errorHandler);\n            } else if (this.method == \"patch\") {\n                RED.httpNode.patch(this.url,cookieParser(),httpMiddleware,corsHandler,metricsHandler,jsonParser,urlencParser,rawBodyParser,this.callback,this.errorHandler);\n            } else if (this.method == \"delete\") {\n                RED.httpNode.delete(this.url,cookieParser(),httpMiddleware,corsHandler,metricsHandler,jsonParser,urlencParser,rawBodyParser,this.callback,this.errorHandler);\n            }\n\n            this.on(\"close\",function() {\n                var node = this;\n                RED.httpNode._router.stack.forEach(function(route,i,routes) {\n                    if (route.route && route.route.path === node.url && route.route.methods[node.method]) {\n                        routes.splice(i,1);\n                    }\n                });\n            });\n        } else {\n            this.warn(RED._(\"httpin.errors.not-created\"));\n        }\n    }\n    RED.nodes.registerType(\"http in\",HTTPIn);\n\n\n    function HTTPOut(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.on(\"input\",function(msg) {\n            if (msg.res) {\n                if (msg.headers) {\n                    msg.res._res.set(msg.headers);\n                }\n                if (msg.cookies) {\n                    for (var name in msg.cookies) {\n                        if (msg.cookies.hasOwnProperty(name)) {\n                            if (msg.cookies[name] === null || msg.cookies[name].value === null) {\n                                if (msg.cookies[name]!==null) {\n                                    msg.res._res.clearCookie(name,msg.cookies[name]);\n                                } else {\n                                    msg.res._res.clearCookie(name);\n                                }\n                            } else if (typeof msg.cookies[name] === 'object') {\n                                msg.res._res.cookie(name,msg.cookies[name].value,msg.cookies[name]);\n                            } else {\n                                msg.res._res.cookie(name,msg.cookies[name]);\n                            }\n                        }\n                    }\n                }\n                var statusCode = msg.statusCode || 200;\n                if (typeof msg.payload == \"object\" && !Buffer.isBuffer(msg.payload)) {\n                    msg.res._res.status(statusCode).jsonp(msg.payload);\n                } else {\n                    if (msg.res._res.get('content-length') == null) {\n                        var len;\n                        if (msg.payload == null) {\n                            len = 0;\n                        } else if (Buffer.isBuffer(msg.payload)) {\n                            len = msg.payload.length;\n                        } else if (typeof msg.payload == \"number\") {\n                            len = Buffer.byteLength(\"\"+msg.payload);\n                        } else {\n                            len = Buffer.byteLength(msg.payload);\n                        }\n                        msg.res._res.set('content-length', len);\n                    }\n\n                    if (typeof msg.payload === \"number\") {\n                        msg.payload = \"\"+msg.payload;\n                    }\n                    msg.res._res.status(statusCode).send(msg.payload);\n                }\n            } else {\n                node.warn(RED._(\"httpin.errors.no-response\"));\n            }\n        });\n    }\n    RED.nodes.registerType(\"http response\",HTTPOut);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/21-httprequest.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var http = require(\"follow-redirects\").http;\n    var https = require(\"follow-redirects\").https;\n    var urllib = require(\"url\");\n    var mustache = require(\"mustache\");\n    var querystring = require(\"querystring\");\n\n    function HTTPRequest(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        var nodeUrl = n.url;\n        var isTemplatedUrl = (nodeUrl||\"\").indexOf(\"{{\") != -1;\n        var nodeMethod = n.method || \"GET\";\n        if (n.tls) {\n            var tlsNode = RED.nodes.getNode(n.tls);\n        }\n        this.ret = n.ret || \"txt\";\n        if (RED.settings.httpRequestTimeout) { this.reqTimeout = parseInt(RED.settings.httpRequestTimeout) || 120000; }\n        else { this.reqTimeout = 120000; }\n\n        var prox, noprox;\n        if (process.env.http_proxy != null) { prox = process.env.http_proxy; }\n        if (process.env.HTTP_PROXY != null) { prox = process.env.HTTP_PROXY; }\n        if (process.env.no_proxy != null) { noprox = process.env.no_proxy.split(\",\"); }\n        if (process.env.NO_PROXY != null) { noprox = process.env.NO_PROXY.split(\",\"); }\n\n        this.on(\"input\",function(msg) {\n            var preRequestTimestamp = process.hrtime();\n            node.status({fill:\"blue\",shape:\"dot\",text:\"httpin.status.requesting\"});\n            var url = nodeUrl || msg.url;\n            if (msg.url && nodeUrl && (nodeUrl !== msg.url)) {  // revert change below when warning is finally removed\n                node.warn(RED._(\"common.errors.nooverride\"));\n            }\n            if (isTemplatedUrl) {\n                url = mustache.render(nodeUrl,msg);\n            }\n            if (!url) {\n                node.error(RED._(\"httpin.errors.no-url\"),msg);\n                return;\n            }\n            // url must start http:// or https:// so assume http:// if not set\n            if (!((url.indexOf(\"http://\") === 0) || (url.indexOf(\"https://\") === 0))) {\n                if (tlsNode) {\n                    url = \"https://\"+url;\n                } else {\n                    url = \"http://\"+url;\n                }\n            }\n\n            var method = nodeMethod.toUpperCase() || \"GET\";\n            if (msg.method && n.method && (n.method !== \"use\")) {     // warn if override option not set\n                node.warn(RED._(\"common.errors.nooverride\"));\n            }\n            if (msg.method && n.method && (n.method === \"use\")) {\n                method = msg.method.toUpperCase();          // use the msg parameter\n            }\n            var opts = urllib.parse(url);\n            opts.method = method;\n            opts.headers = {};\n            var ctSet = \"Content-Type\"; // set default camel case\n            var clSet = \"Content-Length\";\n            if (msg.headers) {\n                for (var v in msg.headers) {\n                    if (msg.headers.hasOwnProperty(v)) {\n                        var name = v.toLowerCase();\n                        if (name !== \"content-type\" && name !== \"content-length\") {\n                            // only normalise the known headers used later in this\n                            // function. Otherwise leave them alone.\n                            name = v;\n                        }\n                        else if (name === 'content-type') { ctSet = v; }\n                        else { clSet = v; }\n                        opts.headers[name] = msg.headers[v];\n                    }\n                }\n            }\n            if (this.credentials && this.credentials.user) {\n                opts.auth = this.credentials.user+\":\"+(this.credentials.password||\"\");\n            }\n            var payload = null;\n\n            if (msg.payload && (method == \"POST\" || method == \"PUT\" || method == \"PATCH\" ) ) {\n                if (typeof msg.payload === \"string\" || Buffer.isBuffer(msg.payload)) {\n                    payload = msg.payload;\n                } else if (typeof msg.payload == \"number\") {\n                    payload = msg.payload+\"\";\n                } else {\n                    if (opts.headers['content-type'] == 'application/x-www-form-urlencoded') {\n                        payload = querystring.stringify(msg.payload);\n                    } else {\n                        payload = JSON.stringify(msg.payload);\n                        if (opts.headers['content-type'] == null) {\n                            opts.headers[ctSet] = \"application/json\";\n                        }\n                    }\n                }\n                if (opts.headers['content-length'] == null) {\n                    if (Buffer.isBuffer(payload)) {\n                        opts.headers[clSet] = payload.length;\n                    } else {\n                        opts.headers[clSet] = Buffer.byteLength(payload);\n                    }\n                }\n            }\n            // revert to user supplied Capitalisation if needed.\n            if (opts.headers.hasOwnProperty('content-type') && (ctSet !== 'content-type')) {\n                opts.headers[ctSet] = opts.headers['content-type'];\n                delete opts.headers['content-type'];\n            }\n            if (opts.headers.hasOwnProperty('content-length') && (clSet !== 'content-length')) {\n                opts.headers[clSet] = opts.headers['content-length'];\n                delete opts.headers['content-length'];\n            }\n            var urltotest = url;\n            var noproxy;\n            if (noprox) {\n                for (var i in noprox) {\n                    if (url.indexOf(noprox[i]) !== -1) { noproxy=true; }\n                }\n            }\n            if (prox && !noproxy) {\n                var match = prox.match(/^(http:\\/\\/)?(.+)?:([0-9]+)?/i);\n                if (match) {\n                    //opts.protocol = \"http:\";\n                    //opts.host = opts.hostname = match[2];\n                    //opts.port = (match[3] != null ? match[3] : 80);\n                    opts.headers['Host'] = opts.host;\n                    var heads = opts.headers;\n                    var path = opts.pathname = opts.href;\n                    opts = urllib.parse(prox);\n                    opts.path = opts.pathname = path;\n                    opts.headers = heads;\n                    opts.method = method;\n                    urltotest = match[0];\n                }\n                else { node.warn(\"Bad proxy url: \"+process.env.http_proxy); }\n            }\n            if (tlsNode) {\n                tlsNode.addTLSOptions(opts);\n            }\n            var req = ((/^https/.test(urltotest))?https:http).request(opts,function(res) {\n                (node.ret === \"bin\") ? res.setEncoding('binary') : res.setEncoding('utf8');\n                msg.statusCode = res.statusCode;\n                msg.headers = res.headers;\n                msg.responseUrl = res.responseUrl;\n                msg.payload = \"\";\n                // msg.url = url;   // revert when warning above finally removed\n                res.on('data',function(chunk) {\n                    msg.payload += chunk;\n                });\n                res.on('end',function() {\n                    if (node.metric()) {\n                        // Calculate request time\n                        var diff = process.hrtime(preRequestTimestamp);\n                        var ms = diff[0] * 1e3 + diff[1] * 1e-6;\n                        var metricRequestDurationMillis = ms.toFixed(3);\n                        node.metric(\"duration.millis\", msg, metricRequestDurationMillis);\n                        if (res.client && res.client.bytesRead) {\n                            node.metric(\"size.bytes\", msg, res.client.bytesRead);\n                        }\n                    }\n                    if (node.ret === \"bin\") {\n                        msg.payload = new Buffer(msg.payload,\"binary\");\n                    }\n                    else if (node.ret === \"obj\") {\n                        try { msg.payload = JSON.parse(msg.payload); }\n                        catch(e) { node.warn(RED._(\"httpin.errors.json-error\")); }\n                    }\n                    node.send(msg);\n                    node.status({});\n                });\n            });\n            req.setTimeout(node.reqTimeout, function() {\n                node.error(RED._(\"common.notification.errors.no-response\"),msg);\n                setTimeout(function() {\n                    node.status({fill:\"red\",shape:\"ring\",text:\"common.notification.errors.no-response\"});\n                },10);\n                req.abort();\n            });\n            req.on('error',function(err) {\n                node.error(err,msg);\n                msg.payload = err.toString() + \" : \" + url;\n                msg.statusCode = err.code;\n                node.send(msg);\n                node.status({fill:\"red\",shape:\"ring\",text:err.code});\n            });\n            if (payload) {\n                req.write(payload);\n            }\n            req.end();\n        });\n\n        this.on(\"close\",function() {\n            node.status({});\n        });\n    }\n\n    RED.nodes.registerType(\"http request\",HTTPRequest,{\n        credentials: {\n            user: {type:\"text\"},\n            password: {type: \"password\"}\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/22-websocket.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var ws = require(\"ws\");\n    var inspect = require(\"util\").inspect;\n\n    // A node red node that sets up a local websocket server\n    function WebSocketListenerNode(n) {\n        // Create a RED node\n        RED.nodes.createNode(this,n);\n        var node = this;\n\n        // Store local copies of the node configuration (as defined in the .html)\n        node.path = n.path;\n        node.wholemsg = (n.wholemsg === \"true\");\n\n        node._inputNodes = [];    // collection of nodes that want to receive events\n        node._clients = {};\n        // match absolute url\n        node.isServer = !/^ws{1,2}:\\/\\//i.test(node.path);\n        node.closing = false;\n\n        function startconn() {    // Connect to remote endpoint\n            node.tout = null;\n            var socket = new ws(node.path);\n            socket.setMaxListeners(0);\n            node.server = socket; // keep for closing\n            handleConnection(socket);\n        }\n\n        function handleConnection(/*socket*/socket) {\n            var id = (1+Math.random()*4294967295).toString(16);\n            if (node.isServer) { node._clients[id] = socket; node.emit('opened',Object.keys(node._clients).length); }\n            socket.on('open',function() {\n                if (!node.isServer) { node.emit('opened',''); }\n            });\n            socket.on('close',function() {\n                if (node.isServer) { delete node._clients[id]; node.emit('closed',Object.keys(node._clients).length); }\n                else { node.emit('closed'); }\n                if (!node.closing && !node.isServer) {\n                    clearTimeout(node.tout);\n                    node.tout = setTimeout(function() { startconn(); }, 3000); // try to reconnect every 3 secs... bit fast ?\n                }\n            });\n            socket.on('message',function(data,flags) {\n                node.handleEvent(id,socket,'message',data,flags);\n            });\n            socket.on('error', function(err) {\n                node.emit('erro');\n                if (!node.closing && !node.isServer) {\n                    clearTimeout(node.tout);\n                    node.tout = setTimeout(function() { startconn(); }, 3000); // try to reconnect every 3 secs... bit fast ?\n                }\n            });\n        }\n\n        if (node.isServer) {\n            var path = RED.settings.httpNodeRoot || \"/\";\n            path = path + (path.slice(-1) == \"/\" ? \"\":\"/\") + (node.path.charAt(0) == \"/\" ? node.path.substring(1) : node.path);\n\n            // Workaround https://github.com/einaros/ws/pull/253\n            // Listen for 'newListener' events from RED.server\n            node._serverListeners = {};\n\n            var storeListener = function(/*String*/event,/*function*/listener) {\n                if (event == \"error\" || event == \"upgrade\" || event == \"listening\") {\n                    node._serverListeners[event] = listener;\n                }\n            }\n\n            RED.server.addListener('newListener',storeListener);\n\n            // Create a WebSocket Server\n            node.server = new ws.Server({\n                server:RED.server,\n                path:path,\n                // Disable the deflate option due to this issue\n                //  https://github.com/websockets/ws/pull/632\n                // that is fixed in the 1.x release of the ws module\n                // that we cannot currently pickup as it drops node 0.10 support\n                perMessageDeflate: false\n            });\n\n            // Workaround https://github.com/einaros/ws/pull/253\n            // Stop listening for new listener events\n            RED.server.removeListener('newListener',storeListener);\n            node.server.setMaxListeners(0);\n            node.server.on('connection', handleConnection);\n        }\n        else {\n            node.closing = false;\n            startconn(); // start outbound connection\n        }\n\n        node.on(\"close\", function() {\n            // Workaround https://github.com/einaros/ws/pull/253\n            // Remove listeners from RED.server\n            if (node.isServer) {\n                var listener = null;\n                for (var event in node._serverListeners) {\n                    if (node._serverListeners.hasOwnProperty(event)) {\n                        listener = node._serverListeners[event];\n                        if (typeof listener === \"function\") {\n                            RED.server.removeListener(event,listener);\n                        }\n                    }\n                }\n                node._serverListeners = {};\n                node.server.close();\n                node._inputNodes = [];\n            }\n            else {\n                node.closing = true;\n                node.server.close();\n                if (node.tout) {\n                    clearTimeout(node.tout);\n                    node.tout = null;\n                }\n            }\n        });\n    }\n    RED.nodes.registerType(\"websocket-listener\",WebSocketListenerNode);\n    RED.nodes.registerType(\"websocket-client\",WebSocketListenerNode);\n\n    WebSocketListenerNode.prototype.registerInputNode = function(/*Node*/handler) {\n        this._inputNodes.push(handler);\n    }\n\n    WebSocketListenerNode.prototype.removeInputNode = function(/*Node*/handler) {\n        this._inputNodes.forEach(function(node, i, inputNodes) {\n            if (node === handler) {\n                inputNodes.splice(i, 1);\n            }\n        });\n    }\n\n    WebSocketListenerNode.prototype.handleEvent = function(id,/*socket*/socket,/*String*/event,/*Object*/data,/*Object*/flags) {\n        var msg;\n        if (this.wholemsg) {\n            try {\n                msg = JSON.parse(data);\n            }\n            catch(err) {\n                msg = { payload:data };\n            }\n        } else {\n            msg = {\n                payload:data\n            };\n        }\n        msg._session = {type:\"websocket\",id:id};\n        for (var i = 0; i < this._inputNodes.length; i++) {\n            this._inputNodes[i].send(msg);\n        }\n    }\n\n    WebSocketListenerNode.prototype.broadcast = function(data) {\n        var i;\n        try {\n            if (this.isServer) {\n                for (i = 0; i < this.server.clients.length; i++) {\n                    this.server.clients[i].send(data);\n                }\n            }\n            else {\n                this.server.send(data);\n            }\n        }\n        catch(e) { // swallow any errors\n            this.warn(\"ws:\"+i+\" : \"+e);\n        }\n    }\n\n    WebSocketListenerNode.prototype.reply = function(id,data) {\n        var session = this._clients[id];\n        if (session) {\n            try {\n                session.send(data);\n            }\n            catch(e) { // swallow any errors\n            }\n        }\n    }\n\n    function WebSocketInNode(n) {\n        RED.nodes.createNode(this,n);\n        this.server = (n.client)?n.client:n.server;\n        var node = this;\n        this.serverConfig = RED.nodes.getNode(this.server);\n        if (this.serverConfig) {\n            this.serverConfig.registerInputNode(this);\n            // TODO: nls\n            this.serverConfig.on('opened', function(n) { node.status({fill:\"green\",shape:\"dot\",text:\"connected \"+n}); });\n            this.serverConfig.on('erro', function() { node.status({fill:\"red\",shape:\"ring\",text:\"error\"}); });\n            this.serverConfig.on('closed', function() { node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"}); });\n        } else {\n            this.error(RED._(\"websocket.errors.missing-conf\"));\n        }\n        this.on('close', function() {\n            node.serverConfig.removeInputNode(node);\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"websocket in\",WebSocketInNode);\n\n    function WebSocketOutNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.server = (n.client)?n.client:n.server;\n        this.serverConfig = RED.nodes.getNode(this.server);\n        if (!this.serverConfig) {\n            this.error(RED._(\"websocket.errors.missing-conf\"));\n        }\n        else {\n            // TODO: nls\n            this.serverConfig.on('opened', function(n) { node.status({fill:\"green\",shape:\"dot\",text:\"connected \"+n}); });\n            this.serverConfig.on('erro', function() { node.status({fill:\"red\",shape:\"ring\",text:\"error\"}); });\n            this.serverConfig.on('closed', function() { node.status({fill:\"red\",shape:\"ring\",text:\"disconnected\"}); });\n        }\n        this.on(\"input\", function(msg) {\n            var payload;\n            if (this.serverConfig.wholemsg) {\n                delete msg._session;\n                payload = JSON.stringify(msg);\n            } else if (msg.hasOwnProperty(\"payload\")) {\n                if (!Buffer.isBuffer(msg.payload)) { // if it's not a buffer make sure it's a string.\n                    payload = RED.util.ensureString(msg.payload);\n                }\n                else {\n                    payload = msg.payload;\n                }\n            }\n            if (payload) {\n                if (msg._session && msg._session.type == \"websocket\") {\n                    node.serverConfig.reply(msg._session.id,payload);\n                } else {\n                    node.serverConfig.broadcast(payload,function(error) {\n                        if (!!error) {\n                            node.warn(RED._(\"websocket.errors.send-error\")+inspect(error));\n                        }\n                    });\n                }\n            }\n        });\n        this.on('close', function() {\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"websocket out\",WebSocketOutNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/23-watch.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var Notify = require(\"fs.notify\");\n    var fs = require(\"fs\");\n    var sep = require(\"path\").sep;\n\n    function WatchNode(n) {\n        RED.nodes.createNode(this,n);\n\n        this.files = (n.files || \"\").split(\",\");\n        for (var f=0; f < this.files.length; f++) {\n            this.files[f] = this.files[f].trim();\n        }\n        this.p = (this.files.length === 1) ? this.files[0] : JSON.stringify(this.files);\n        var node = this;\n\n        var notifications = new Notify(node.files);\n        notifications.on('change', function (file, event, path) {\n            var stat;\n            try {\n                if (fs.statSync(path).isDirectory()) { path = path + sep + file; }\n                stat = fs.statSync(path);\n            } catch(e) { }\n            var type = \"none\";\n            var msg = { payload:path, topic:node.p, file:file };\n            if (stat) {\n                if (stat.isFile()) { type = \"file\"; msg.size = stat.size; }\n                else if (stat.isDirectory()) { type = \"directory\"; }\n                else if (stat.isBlockDevice()) { type = \"blockdevice\"; }\n                else if (stat.isCharacterDevice()) { type = \"characterdevice\"; }\n                else if (stat.isSocket()) { type = \"socket\"; }\n                else if (stat.isFIFO()) { type = \"fifo\"; }\n                else { type = \"n/a\"; }\n            }\n            msg.type = type;\n            node.send(msg);\n        });\n\n        notifications.on('error', function (error, path) {\n            var msg = { payload:path };\n            node.error(error,msg);\n        });\n\n        this.close = function() {\n            notifications.close();\n        }\n    }\n    RED.nodes.registerType(\"watch\",WatchNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/31-tcpin.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var reconnectTime = RED.settings.socketReconnectTime||10000;\n    var socketTimeout = RED.settings.socketTimeout||null;\n    var net = require('net');\n\n    var connectionPool = {};\n\n    function TcpIn(n) {\n        RED.nodes.createNode(this,n);\n        this.host = n.host;\n        this.port = n.port * 1;\n        this.topic = n.topic;\n        this.stream = (!n.datamode||n.datamode=='stream'); /* stream,single*/\n        this.datatype = n.datatype||'buffer'; /* buffer,utf8,base64 */\n        this.newline = (n.newline||\"\").replace(\"\\\\n\",\"\\n\").replace(\"\\\\r\",\"\\r\");\n        this.base64 = n.base64;\n        this.server = (typeof n.server == 'boolean')?n.server:(n.server == \"server\");\n        this.closing = false;\n        this.connected = false;\n        var node = this;\n        var count = 0;\n\n        if (!node.server) {\n            var buffer = null;\n            var client;\n            var reconnectTimeout;\n            var end = false;\n            var setupTcpClient = function() {\n                node.log(RED._(\"tcpin.status.connecting\",{host:node.host,port:node.port}));\n                node.status({fill:\"grey\",shape:\"dot\",text:\"common.status.connecting\"});\n                var id = (1+Math.random()*4294967295).toString(16);\n                client = net.connect(node.port, node.host, function() {\n                    buffer = (node.datatype == 'buffer')? new Buffer(0):\"\";\n                    node.connected = true;\n                    node.log(RED._(\"tcpin.status.connected\",{host:node.host,port:node.port}));\n                    node.status({fill:\"green\",shape:\"dot\",text:\"common.status.connected\"});\n                });\n                connectionPool[id] = client;\n\n                client.on('data', function (data) {\n                    if (node.datatype != 'buffer') {\n                        data = data.toString(node.datatype);\n                    }\n                    if (node.stream) {\n                        var msg;\n                        if ((node.datatype) === \"utf8\" && node.newline !== \"\") {\n                            buffer = buffer+data;\n                            var parts = buffer.split(node.newline);\n                            for (var i = 0;i<parts.length-1;i+=1) {\n                                msg = {topic:node.topic, payload:parts[i]};\n                                msg._session = {type:\"tcp\",id:id};\n                                node.send(msg);\n                            }\n                            buffer = parts[parts.length-1];\n                        } else {\n                            msg = {topic:node.topic, payload:data};\n                            msg._session = {type:\"tcp\",id:id};\n                            node.send(msg);\n                        }\n                    } else {\n                        if ((typeof data) === \"string\") {\n                            buffer = buffer+data;\n                        } else {\n                            buffer = Buffer.concat([buffer,data],buffer.length+data.length);\n                        }\n                    }\n                });\n                client.on('end', function() {\n                    if (!node.stream || (node.datatype == \"utf8\" && node.newline !== \"\" && buffer.length > 0)) {\n                        var msg = {topic:node.topic, payload:buffer};\n                        msg._session = {type:\"tcp\",id:id};\n                        if (buffer.length !== 0) {\n                            end = true; // only ask for fast re-connect if we actually got something\n                            node.send(msg);\n                        }\n                        buffer = null;\n                    }\n                });\n                client.on('close', function() {\n                    delete connectionPool[id];\n                    node.connected = false;\n                    node.status({fill:\"red\",shape:\"ring\",text:\"common.status.disconnected\"});\n                    if (!node.closing) {\n                        if (end) { // if we were asked to close then try to reconnect once very quick.\n                            end = false;\n                            reconnectTimeout = setTimeout(setupTcpClient, 20);\n                        }\n                        else {\n                            node.log(RED._(\"tcpin.errors.connection-lost\",{host:node.host,port:node.port}));\n                            reconnectTimeout = setTimeout(setupTcpClient, reconnectTime);\n                        }\n                    } else {\n                        if (node.done) { node.done(); }\n                    }\n                });\n                client.on('error', function(err) {\n                    node.log(err);\n                });\n            }\n            setupTcpClient();\n\n            this.on('close', function(done) {\n                node.done = done;\n                this.closing = true;\n                if (client) { client.destroy(); }\n                clearTimeout(reconnectTimeout);\n                if (!node.connected) { done(); }\n            });\n        } else {\n            var server = net.createServer(function (socket) {\n                socket.setKeepAlive(true,120000);\n                if (socketTimeout !== null) { socket.setTimeout(socketTimeout); }\n                var id = (1+Math.random()*4294967295).toString(16);\n                connectionPool[id] = socket;\n                count++;\n                node.status({text:RED._(\"tcpin.status.connections\",{count:count})});\n\n                var buffer = (node.datatype == 'buffer')? new Buffer(0):\"\";\n                socket.on('data', function (data) {\n                    if (node.datatype != 'buffer') {\n                        data = data.toString(node.datatype);\n                    }\n                    if (node.stream) {\n                        var msg;\n                        if ((typeof data) === \"string\" && node.newline !== \"\") {\n                            buffer = buffer+data;\n                            var parts = buffer.split(node.newline);\n                            for (var i = 0; i<parts.length-1; i+=1) {\n                                msg = {topic:node.topic, payload:parts[i],ip:socket.remoteAddress,port:socket.remotePort};\n                                msg._session = {type:\"tcp\",id:id};\n                                node.send(msg);\n                            }\n                            buffer = parts[parts.length-1];\n                        } else {\n                            msg = {topic:node.topic, payload:data};\n                            msg._session = {type:\"tcp\",id:id};\n                            node.send(msg);\n                        }\n                    } else {\n                        if ((typeof data) === \"string\") {\n                            buffer = buffer+data;\n                        } else {\n                            buffer = Buffer.concat([buffer,data],buffer.length+data.length);\n                        }\n                    }\n                });\n                socket.on('end', function() {\n                    if (!node.stream || (node.datatype === \"utf8\" && node.newline !== \"\")) {\n                        if (buffer.length > 0) {\n                            var msg = {topic:node.topic, payload:buffer};\n                            msg._session = {type:\"tcp\",id:id};\n                            node.send(msg);\n                        }\n                        buffer = null;\n                    }\n                });\n                socket.on('timeout', function() {\n                    node.log(RED._(\"tcpin.errors.timeout\",{port:node.port}));\n                    socket.end();\n                });\n                socket.on('close', function() {\n                    delete connectionPool[id];\n                    count--;\n                    node.status({text:RED._(\"tcpin.status.connections\",{count:count})});\n                });\n                socket.on('error',function(err) {\n                    node.log(err);\n                });\n            });\n            server.on('error', function(err) {\n                if (err) {\n                    node.error(RED._(\"tcpin.errors.cannot-listen\",{port:node.port,error:err.toString()}));\n                }\n            });\n\n            server.listen(node.port, function(err) {\n                if (err) {\n                    node.error(RED._(\"tcpin.errors.cannot-listen\",{port:node.port,error:err.toString()}));\n                } else {\n                    node.log(RED._(\"tcpin.status.listening-port\",{port:node.port}));\n                    node.on('close', function() {\n                        for (var c in connectionPool) {\n                            if (connectionPool.hasOwnProperty(c)) {\n                                connectionPool[c].end();\n                                connectionPool[c].unref();\n                            }\n                        }\n                        node.closing = true;\n                        server.close();\n                        node.log(RED._(\"tcpin.status.stopped-listening\",{port:node.port}));\n                    });\n                }\n            });\n        }\n\n    }\n    RED.nodes.registerType(\"tcp in\",TcpIn);\n\n    function TcpOut(n) {\n        RED.nodes.createNode(this,n);\n        this.host = n.host;\n        this.port = n.port * 1;\n        this.base64 = n.base64;\n        this.doend = n.end || false;\n        this.beserver = n.beserver;\n        this.name = n.name;\n        this.closing = false;\n        this.connected = false;\n        var node = this;\n\n        if (!node.beserver||node.beserver==\"client\") {\n            var reconnectTimeout;\n            var client = null;\n            var end = false;\n\n            var setupTcpClient = function() {\n                node.log(RED._(\"tcpin.status.connecting\",{host:node.host,port:node.port}));\n                node.status({fill:\"grey\",shape:\"dot\",text:\"common.status.connecting\"});\n                client = net.connect(node.port, node.host, function() {\n                    node.connected = true;\n                    node.log(RED._(\"tcpin.status.connected\",{host:node.host,port:node.port}));\n                    node.status({fill:\"green\",shape:\"dot\",text:\"common.status.connected\"});\n                });\n                client.on('error', function (err) {\n                    node.log(RED._(\"tcpin.errors.error\",{error:err.toString()}));\n                });\n                client.on('end', function (err) {\n                    node.status({});\n                    node.connected = false;\n                });\n                client.on('close', function() {\n                    node.status({fill:\"red\",shape:\"ring\",text:\"common.status.disconnected\"});\n                    node.connected = false;\n                    client.destroy();\n                    if (!node.closing) {\n                        if (end) {\n                            end = false;\n                            reconnectTimeout = setTimeout(setupTcpClient,20);\n                        }\n                        else {\n                            node.log(RED._(\"tcpin.errors.connection-lost\",{host:node.host,port:node.port}));\n                            reconnectTimeout = setTimeout(setupTcpClient,reconnectTime);\n                        }\n                    } else {\n                        if (node.done) { node.done(); }\n                    }\n                });\n            }\n            setupTcpClient();\n\n            node.on(\"input\", function(msg) {\n                if (node.connected && msg.payload != null) {\n                    if (Buffer.isBuffer(msg.payload)) {\n                        client.write(msg.payload);\n                    } else if (typeof msg.payload === \"string\" && node.base64) {\n                        client.write(new Buffer(msg.payload,'base64'));\n                    } else {\n                        client.write(new Buffer(\"\"+msg.payload));\n                    }\n                    if (node.doend === true) {\n                        end = true;\n                        if (client) { node.status({}); client.destroy(); }\n                    }\n                }\n            });\n\n            node.on(\"close\", function(done) {\n                node.done = done;\n                this.closing = true;\n                if (client) { client.destroy(); }\n                clearTimeout(reconnectTimeout);\n                if (!node.connected) { done(); }\n            });\n\n        } else if (node.beserver == \"reply\") {\n            node.on(\"input\",function(msg) {\n                if (msg._session && msg._session.type == \"tcp\") {\n                    var client = connectionPool[msg._session.id];\n                    if (client) {\n                        if (Buffer.isBuffer(msg.payload)) {\n                            client.write(msg.payload);\n                        } else if (typeof msg.payload === \"string\" && node.base64) {\n                            client.write(new Buffer(msg.payload,'base64'));\n                        } else {\n                            client.write(new Buffer(\"\"+msg.payload));\n                        }\n                    }\n                }\n                else {\n                    for (var i in connectionPool) {\n                        if (Buffer.isBuffer(msg.payload)) {\n                            connectionPool[i].write(msg.payload);\n                        } else if (typeof msg.payload === \"string\" && node.base64) {\n                            connectionPool[i].write(new Buffer(msg.payload,'base64'));\n                        } else {\n                            connectionPool[i].write(new Buffer(\"\"+msg.payload));\n                        }\n                    }\n                }\n            });\n        } else {\n            var connectedSockets = [];\n            node.status({text:RED._(\"tcpin.status.connections\",{count:0})});\n            var server = net.createServer(function (socket) {\n                socket.setKeepAlive(true,120000);\n                if (socketTimeout !== null) { socket.setTimeout(socketTimeout); }\n                var remoteDetails = socket.remoteAddress+\":\"+socket.remotePort;\n                node.log(RED._(\"tcpin.status.connection-from\",{host:socket.remoteAddress, port:socket.remotePort}));\n                connectedSockets.push(socket);\n                node.status({text:RED._(\"tcpin.status.connections\",{count:connectedSockets.length})});\n                socket.on('timeout', function() {\n                    node.log(RED._(\"tcpin.errors.timeout\",{port:node.port}));\n                    socket.end();\n                });\n                socket.on('close',function() {\n                    node.log(RED._(\"tcpin.status.connection-closed\",{host:socket.remoteAddress, port:socket.remotePort}));\n                    connectedSockets.splice(connectedSockets.indexOf(socket),1);\n                    node.status({text:RED._(\"tcpin.status.connections\",{count:connectedSockets.length})});\n                });\n                socket.on('error',function() {\n                    node.log(RED._(\"tcpin.errors.socket-error\",{host:socket.remoteAddress, port:socket.remotePort}));\n                    connectedSockets.splice(connectedSockets.indexOf(socket),1);\n                    node.status({text:RED._(\"tcpin.status.connections\",{count:connectedSockets.length})});\n                });\n            });\n\n            node.on(\"input\", function(msg) {\n                if (msg.payload != null) {\n                    var buffer;\n                    if (Buffer.isBuffer(msg.payload)) {\n                        buffer = msg.payload;\n                    } else if (typeof msg.payload === \"string\" && node.base64) {\n                        buffer = new Buffer(msg.payload,'base64');\n                    } else {\n                        buffer = new Buffer(\"\"+msg.payload);\n                    }\n                    for (var i = 0; i < connectedSockets.length; i += 1) {\n                        if (node.doend === true) { connectedSockets[i].end(buffer); }\n                        else { connectedSockets[i].write(buffer); }\n                    }\n                }\n            });\n\n            server.on('error', function(err) {\n                if (err) {\n                    node.error(RED._(\"tcpin.errors.cannot-listen\",{port:node.port,error:err.toString()}));\n                }\n            });\n\n            server.listen(node.port, function(err) {\n                if (err) {\n                    node.error(RED._(\"tcpin.errors.cannot-listen\",{port:node.port,error:err.toString()}));\n                } else {\n                    node.log(RED._(\"tcpin.status.listening-port\",{port:node.port}));\n                    node.on('close', function() {\n                        for (var c in connectedSockets) {\n                            if (connectedSockets.hasOwnProperty(c)) {\n                                connectedSockets[c].end();\n                                connectedSockets[c].unref();\n                            }\n                        }\n                        server.close();\n                        node.log(RED._(\"tcpin.status.stopped-listening\",{port:node.port}));\n                    });\n                }\n            });\n        }\n    }\n    RED.nodes.registerType(\"tcp out\",TcpOut);\n\n    function TcpGet(n) {\n        RED.nodes.createNode(this,n);\n        this.server = n.server;\n        this.port = Number(n.port);\n        this.out = n.out;\n        this.splitc = n.splitc;\n\n        if (this.out != \"char\") { this.splitc = Number(this.splitc); }\n        else {\n            if (this.splitc[0] == '\\\\') {\n                this.splitc = parseInt(this.splitc.replace(\"\\\\n\",0x0A).replace(\"\\\\r\",0x0D).replace(\"\\\\t\",0x09).replace(\"\\\\e\",0x1B).replace(\"\\\\f\",0x0C).replace(\"\\\\0\",0x00));\n            } // jshint ignore:line\n            if (typeof this.splitc == \"string\") {\n                if (this.splitc.substr(0,2) == \"0x\") {\n                    this.splitc = parseInt(this.splitc);\n                }\n                else {\n                    this.splitc = this.splitc.charCodeAt(0);\n                }\n            } // jshint ignore:line\n        }\n\n        var node = this;\n\n        var clients = {};\n\n        this.on(\"input\", function(msg) {\n            var i = 0;\n            if ((!Buffer.isBuffer(msg.payload)) && (typeof msg.payload !== \"string\")) {\n                msg.payload = msg.payload.toString();\n            }\n\n            var host = node.server || msg.host;\n            var port = node.port || msg.port;\n\n            // Store client information independently\n            // the clients object will have:\n            // clients[id].client, clients[id].msg, clients[id].timeout\n            var connection_id = host + \":\" + port;\n            clients[connection_id] = clients[connection_id] || {};\n            clients[connection_id].msg = msg;\n            clients[connection_id].connected = clients[connection_id].connected || false;\n\n            if (!clients[connection_id].connected) {\n                var buf;\n                if (this.out == \"count\") {\n                    if (this.splitc === 0) { buf = new Buffer(1); }\n                    else { buf = new Buffer(this.splitc); }\n                }\n                else { buf = new Buffer(65536); } // set it to 64k... hopefully big enough for most TCP packets.... but only hopefully\n\n                clients[connection_id].client = net.Socket();\n                if (socketTimeout !== null) { clients[connection_id].client.setTimeout(socketTimeout);}\n\n                if (host && port) {\n                    clients[connection_id].client.connect(port, host, function() {\n                        //node.log(RED._(\"tcpin.errors.client-connected\"));\n                        node.status({fill:\"green\",shape:\"dot\",text:\"common.status.connected\"});\n                        if (clients[connection_id] && clients[connection_id].client) {\n                            clients[connection_id].connected  = true;\n                            clients[connection_id].client.write(clients[connection_id].msg.payload);\n                        }\n                    });\n                }\n                else {\n                    node.warn(RED._(\"tcpin.errors.no-host\"));\n                }\n\n                clients[connection_id].client.on('data', function(data) {\n                    if (node.out == \"sit\") { // if we are staying connected just send the buffer\n                        if (clients[connection_id]) {\n                            clients[connection_id].msg.payload = data;\n                            node.send(clients[connection_id].msg);\n                        }\n                    }\n                    else if (node.splitc === 0) {\n                        clients[connection_id].msg.payload = data;\n                        node.send(clients[connection_id].msg);\n                    }\n                    else {\n                        for (var j = 0; j < data.length; j++ ) {\n                            if (node.out === \"time\") {\n                                if (clients[connection_id]) {\n                                    // do the timer thing\n                                    if (clients[connection_id].timeout) {\n                                        i += 1;\n                                        buf[i] = data[j];\n                                    }\n                                    else {\n                                        clients[connection_id].timeout = setTimeout(function () {\n                                            if (clients[connection_id]) {\n                                                clients[connection_id].timeout = null;\n                                                clients[connection_id].msg.payload = new Buffer(i+1);\n                                                buf.copy(clients[connection_id].msg.payload,0,0,i+1);\n                                                node.send(clients[connection_id].msg);\n                                                if (clients[connection_id].client) {\n                                                    node.status({}); clients[connection_id].client.destroy();\n                                                    delete clients[connection_id];\n                                                }\n                                            }\n                                        }, node.splitc);\n                                        i = 0;\n                                        buf[0] = data[j];\n                                    }\n                                }\n                            }\n                            // count bytes into a buffer...\n                            else if (node.out == \"count\") {\n                                buf[i] = data[j];\n                                i += 1;\n                                if ( i >= node.splitc) {\n                                    if (clients[connection_id]) {\n                                        clients[connection_id].msg.payload = new Buffer(i);\n                                        buf.copy(clients[connection_id].msg.payload,0,0,i);\n                                        node.send(clients[connection_id].msg);\n                                        if (clients[connection_id].client) {\n                                            node.status({}); clients[connection_id].client.destroy();\n                                            delete clients[connection_id];\n                                        }\n                                        i = 0;\n                                    }\n                                }\n                            }\n                            // look for a char\n                            else {\n                                buf[i] = data[j];\n                                i += 1;\n                                if (data[j] == node.splitc) {\n                                    if (clients[connection_id]) {\n                                        clients[connection_id].msg.payload = new Buffer(i);\n                                        buf.copy(clients[connection_id].msg.payload,0,0,i);\n                                        node.send(clients[connection_id].msg);\n                                        if (clients[connection_id].client) {\n                                            node.status({}); clients[connection_id].client.destroy();\n                                            delete clients[connection_id];\n                                        }\n                                        i = 0;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                });\n\n                clients[connection_id].client.on('end', function() {\n                    //console.log(\"END\");\n                    node.status({fill:\"grey\",shape:\"ring\",text:\"common.status.disconnected\"});\n                    if (clients[connection_id] && clients[connection_id].client) {\n                        clients[connection_id].connected  = false;\n                        clients[connection_id].client = null;\n                    }\n                });\n\n                clients[connection_id].client.on('close', function() {\n                    //console.log(\"CLOSE\");\n                    if (clients[connection_id]) {\n                        clients[connection_id].connected  = false;\n                    }\n\n                    var anyConnected = false;\n\n                    for (var client in clients) {\n                        if (clients[client].connected) {\n                            anyConnected = true;\n                            break;\n                        }\n                    }\n                    if (node.done && !anyConnected) {\n                        clients = {};\n                        node.done();\n                    }\n                });\n\n                clients[connection_id].client.on('error', function() {\n                    //console.log(\"ERROR\");\n                    node.status({fill:\"red\",shape:\"ring\",text:\"common.status.error\"});\n                    node.error(RED._(\"tcpin.errors.connect-fail\") + \" \" + connection_id, msg);\n                    if (clients[connection_id] && clients[connection_id].client) {\n                        clients[connection_id].connected = false;\n                        clients[connection_id].client.destroy();\n                        delete clients[connection_id];\n                    }\n                });\n\n                clients[connection_id].client.on('timeout',function() {\n                    //console.log(\"TIMEOUT\");\n                    clients[connection_id].connected = false;\n                    node.status({fill:\"grey\",shape:\"dot\",text:\"tcpin.errors.connect-timeout\"});\n                    //node.warn(RED._(\"tcpin.errors.connect-timeout\"));\n                    if (clients[connection_id] && clients[connection_id].client) {\n                        clients[connection_id].client.connect(port, host, function() {\n                            clients[connection_id].connected = true;\n                            node.status({fill:\"green\",shape:\"dot\",text:\"common.status.connected\"});\n                        });\n                    }\n                });\n            }\n            else {\n                if (clients[connection_id] && clients[connection_id].client) {\n                    clients[connection_id].client.write(clients[connection_id].msg.payload);\n                }\n            }\n        });\n\n        this.on(\"close\", function(done) {\n            node.done = done;\n            for (var client in clients) {\n                clients[client].client.destroy();\n            }\n            node.status({});\n\n            var anyConnected = false;\n            for (var c in clients) {\n                if (clients[c].connected) {\n                    anyConnected = true;\n                    break;\n                }\n            }\n\n            if (!anyConnected) {\n                clients = {};\n                done();\n            }\n        });\n\n    }\n    RED.nodes.registerType(\"tcp request\",TcpGet);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/io/32-udp.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var dgram = require('dgram');\n    var udpInputPortsInUse = {};\n\n    // The Input Node\n    function UDPin(n) {\n        RED.nodes.createNode(this,n);\n        this.group = n.group;\n        this.port = n.port;\n        this.datatype = n.datatype;\n        this.iface = n.iface || null;\n        this.multicast = n.multicast;\n        this.ipv = n.ipv || \"udp4\";\n        var node = this;\n\n        var opts = {type:node.ipv, reuseAddr:true};\n        if (process.version.indexOf(\"v0.10\") === 0) { opts = node.ipv; }\n        var server;\n\n        if (!udpInputPortsInUse.hasOwnProperty(this.port)) {\n            server = dgram.createSocket(opts);  // default to udp4\n            udpInputPortsInUse[this.port] = server;\n        }\n        else {\n            node.warn(RED._(\"udp.errors.alreadyused\",node.port));\n            server = udpInputPortsInUse[this.port];  // re-use existing\n        }\n\n        if (process.version.indexOf(\"v0.10\") === 0) { opts = node.ipv; }\n\n        server.on(\"error\", function (err) {\n            if ((err.code == \"EACCES\") && (node.port < 1024)) {\n                node.error(RED._(\"udp.errors.access-error\"));\n            } else {\n                node.error(RED._(\"udp.errors.error\",{error:err.code}));\n            }\n            server.close();\n        });\n\n        server.on('message', function (message, remote) {\n            var msg;\n            if (node.datatype ==\"base64\") {\n                msg = { payload:message.toString('base64'), fromip:remote.address+':'+remote.port, ip:remote.address, port:remote.port };\n            } else if (node.datatype ==\"utf8\") {\n                msg = { payload:message.toString('utf8'), fromip:remote.address+':'+remote.port, ip:remote.address, port:remote.port };\n            } else {\n                msg = { payload:message, fromip:remote.address+':'+remote.port, ip:remote.address, port:remote.port };\n            }\n            node.send(msg);\n        });\n\n        server.on('listening', function () {\n            var address = server.address();\n            node.log(RED._(\"udp.status.listener-at\",{host:address.address,port:address.port}));\n            if (node.multicast == \"true\") {\n                server.setBroadcast(true);\n                try {\n                    server.setMulticastTTL(128);\n                    server.addMembership(node.group,node.iface);\n                    node.log(RED._(\"udp.status.mc-group\",{group:node.group}));\n                } catch (e) {\n                    if (e.errno == \"EINVAL\") {\n                        node.error(RED._(\"udp.errors.bad-mcaddress\"));\n                    } else if (e.errno == \"ENODEV\") {\n                        node.error(RED._(\"udp.errors.interface\"));\n                    } else {\n                        node.error(RED._(\"udp.errors.error\",{error:e.errno}));\n                    }\n                }\n            }\n        });\n\n        node.on(\"close\", function() {\n            if (udpInputPortsInUse.hasOwnProperty(node.port)) {\n                delete udpInputPortsInUse[node.port];\n            }\n            try {\n                server.close();\n                node.log(RED._(\"udp.status.listener-stopped\"));\n            } catch (err) {\n                //node.error(err);\n            }\n        });\n\n        try { server.bind(node.port,node.iface); }\n        catch(e) { } // Don't worry if already bound\n    }\n    RED.httpAdmin.get('/udp-ports/:id', RED.auth.needsPermission('udp-ports.read'), function(req,res) {\n        res.json(Object.keys(udpInputPortsInUse));\n    });\n    RED.nodes.registerType(\"udp in\",UDPin);\n\n\n    // The Output Node\n    function UDPout(n) {\n        RED.nodes.createNode(this,n);\n        //this.group = n.group;\n        this.port = n.port;\n        this.outport = n.outport||\"\";\n        this.base64 = n.base64;\n        this.addr = n.addr;\n        this.iface = n.iface || null;\n        this.multicast = n.multicast;\n        this.ipv = n.ipv || \"udp4\";\n        var node = this;\n\n        var opts = {type:node.ipv, reuseAddr:true};\n        if (process.version.indexOf(\"v0.10\") === 0) { opts = node.ipv; }\n\n        var sock;\n        if (udpInputPortsInUse[this.outport]) {\n            sock = udpInputPortsInUse[this.outport];\n        }\n        else {\n            sock = dgram.createSocket(opts);  // default to udp4\n            udpInputPortsInUse[this.outport] = sock;\n        }\n\n        sock.on(\"error\", function(err) {\n            // Any async error will also get reported in the sock.send call.\n            // This handler is needed to ensure the error marked as handled to\n            // prevent it going to the global error handler and shutting node-red\n            // down.\n        });\n        if (node.multicast != \"false\") {\n            if (node.outport === \"\") { node.outport = node.port; }\n            sock.bind(node.outport, function() {    // have to bind before you can enable broadcast...\n                sock.setBroadcast(true);            // turn on broadcast\n                if (node.multicast == \"multi\") {\n                    try {\n                        sock.setMulticastTTL(128);\n                        sock.addMembership(node.addr,node.iface);   // Add to the multicast group\n                        node.log(RED._(\"udp.status.mc-ready\",{outport:node.outport,host:node.addr,port:node.port}));\n                    } catch (e) {\n                        if (e.errno == \"EINVAL\") {\n                            node.error(RED._(\"udp.errors.bad-mcaddress\"));\n                        } else if (e.errno == \"ENODEV\") {\n                            node.error(RED._(\"udp.errors.interface\"));\n                        } else {\n                            node.error(RED._(\"udp.errors.error\",{error:e.errno}));\n                        }\n                    }\n                } else {\n                    node.log(RED._(\"udp.status.bc-ready\",{outport:node.outport,host:node.addr,port:node.port}));\n                }\n            });\n        } else if ((node.outport !== \"\") && (!udpInputPortsInUse[this.outport])) {\n            sock.bind(node.outport);\n            node.log(RED._(\"udp.status.ready\",{outport:node.outport,host:node.addr,port:node.port}));\n        } else {\n            node.log(RED._(\"udp.status.ready-nolocal\",{host:node.addr,port:node.port}));\n        }\n\n        node.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var add = node.addr || msg.ip || \"\";\n                var por = node.port || msg.port || 0;\n                if (add === \"\") {\n                    node.warn(RED._(\"udp.errors.ip-notset\"));\n                } else if (por === 0) {\n                    node.warn(RED._(\"udp.errors.port-notset\"));\n                } else if (isNaN(por) || (por < 1) || (por > 65535)) {\n                    node.warn(RED._(\"udp.errors.port-invalid\"));\n                } else {\n                    var message;\n                    if (node.base64) {\n                        message = new Buffer(msg.payload, 'base64');\n                    } else if (msg.payload instanceof Buffer) {\n                        message = msg.payload;\n                    } else {\n                        message = new Buffer(\"\"+msg.payload);\n                    }\n                    sock.send(message, 0, message.length, por, add, function(err, bytes) {\n                        if (err) {\n                            node.error(\"udp : \"+err,msg);\n                        }\n                        message = null;\n                    });\n                }\n            }\n        });\n\n        node.on(\"close\", function() {\n            if (udpInputPortsInUse.hasOwnProperty(node.outport)) {\n                delete udpInputPortsInUse[node.outport];\n            }\n            try {\n                sock.close();\n                node.log(RED._(\"udp.status.output-stopped\"));\n            } catch (err) {\n                //node.error(err);\n            }\n        });\n    }\n    RED.nodes.registerType(\"udp out\",UDPout);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/logic/10-switch.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    var jsonata = require('jsonata');\n\n    var operators = {\n        'eq': function(a, b) { return a == b; },\n        'neq': function(a, b) { return a != b; },\n        'lt': function(a, b) { return a < b; },\n        'lte': function(a, b) { return a <= b; },\n        'gt': function(a, b) { return a > b; },\n        'gte': function(a, b) { return a >= b; },\n        'btwn': function(a, b, c) { return a >= b && a <= c; },\n        'cont': function(a, b) { return (a + \"\").indexOf(b) != -1; },\n        'regex': function(a, b, c, d) { return (a + \"\").match(new RegExp(b,d?'i':'')); },\n        'true': function(a) { return a === true; },\n        'false': function(a) { return a === false; },\n        'null': function(a) { return (typeof a == \"undefined\" || a === null); },\n        'nnull': function(a) { return (typeof a != \"undefined\" && a !== null); },\n        'else': function(a) { return a === true; }\n    };\n\n    function SwitchNode(n) {\n        RED.nodes.createNode(this, n);\n        this.rules = n.rules || [];\n        this.property = n.property;\n        this.propertyType = n.propertyType || \"msg\";\n\n        if (this.propertyType === 'jsonata') {\n            try {\n                this.property = jsonata(this.property);\n            } catch(err) {\n                this.error(RED._(\"switch.errors.invalid-expr\",{error:err.message}));\n                return;\n            }\n        }\n\n        this.checkall = n.checkall || \"true\";\n        this.previousValue = null;\n        var node = this;\n        var valid = true;\n        for (var i=0; i<this.rules.length; i+=1) {\n            var rule = this.rules[i];\n            if (!rule.vt) {\n                if (!isNaN(Number(rule.v))) {\n                    rule.vt = 'num';\n                } else {\n                    rule.vt = 'str';\n                }\n            }\n            if (rule.vt === 'num') {\n                if (!isNaN(Number(rule.v))) {\n                    rule.v = Number(rule.v);\n                }\n            } else if (rule.vt === \"jsonata\") {\n                try {\n                    rule.v = jsonata(rule.v);\n                } catch(err) {\n                    this.error(RED._(\"switch.errors.invalid-expr\",{error:err.message}));\n                    valid = false;\n                }\n            }\n            if (typeof rule.v2 !== 'undefined') {\n                if (!rule.v2t) {\n                    if (!isNaN(Number(rule.v2))) {\n                        rule.v2t = 'num';\n                    } else {\n                        rule.v2t = 'str';\n                    }\n                }\n                if (rule.v2t === 'num') {\n                    rule.v2 = Number(rule.v2);\n                } else if (rule.v2t === 'jsonata') {\n                    try {\n                        rule.v2 = jsonata(rule.v2);\n                    } catch(err) {\n                        this.error(RED._(\"switch.errors.invalid-expr\",{error:err.message}));\n                        valid = false;\n                    }\n                }\n            }\n        }\n\n        if (!valid) {\n            return;\n        }\n\n        this.on('input', function (msg) {\n            var onward = [];\n            try {\n                var prop;\n                if (node.propertyType === 'jsonata') {\n                    prop = node.property.evaluate({msg:msg});\n                } else {\n                    prop = RED.util.evaluateNodeProperty(node.property,node.propertyType,node,msg);\n                }\n                var elseflag = true;\n                for (var i=0; i<node.rules.length; i+=1) {\n                    var rule = node.rules[i];\n                    var test = prop;\n                    var v1,v2;\n                    if (rule.vt === 'prev') {\n                        v1 = node.previousValue;\n                    } else if (rule.vt === 'jsonata') {\n                        try {\n                            v1 = rule.v.evaluate({msg:msg});\n                        } catch(err) {\n                            node.error(RED._(\"switch.errors.invalid-expr\",{error:err.message}));\n                            return;\n                        }\n                    } else {\n                        v1 = RED.util.evaluateNodeProperty(rule.v,rule.vt,node,msg);\n                    }\n                    v2 = rule.v2;\n                    if (rule.v2t === 'prev') {\n                        v2 = node.previousValue;\n                    } else if (rule.v2t === 'jsonata') {\n                        try {\n                            v2 = rule.v2.evaluate({msg:msg});\n                        } catch(err) {\n                            node.error(RED._(\"switch.errors.invalid-expr\",{error:err.message}));\n                            return;\n                        }\n                    } else if (typeof v2 !== 'undefined') {\n                        v2 = RED.util.evaluateNodeProperty(rule.v2,rule.v2t,node,msg);\n                    }\n                    if (rule.t == \"else\") { test = elseflag; elseflag = true; }\n                    if (operators[rule.t](test,v1,v2,rule.case)) {\n                        onward.push(msg);\n                        elseflag = false;\n                        if (node.checkall == \"false\") { break; }\n                    } else {\n                        onward.push(null);\n                    }\n                }\n                node.previousValue = prop;\n                this.send(onward);\n            } catch(err) {\n                node.warn(err);\n            }\n        });\n    }\n    RED.nodes.registerType(\"switch\", SwitchNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/logic/15-change.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var jsonata = require(\"jsonata\");\n\n    function ChangeNode(n) {\n        RED.nodes.createNode(this, n);\n\n        this.rules = n.rules;\n        var rule;\n        if (!this.rules) {\n            rule = {\n                t:(n.action==\"replace\"?\"set\":n.action),\n                p:n.property||\"\"\n            }\n\n            if ((rule.t === \"set\")||(rule.t === \"move\")) {\n                rule.to = n.to||\"\";\n            } else if (rule.t === \"change\") {\n                rule.from = n.from||\"\";\n                rule.to = n.to||\"\";\n                rule.re = (n.reg===null||n.reg);\n            }\n            this.rules = [rule];\n        }\n\n        var valid = true;\n        for (var i=0;i<this.rules.length;i++) {\n            rule = this.rules[i];\n            // Migrate to type-aware rules\n            if (!rule.pt) {\n                rule.pt = \"msg\";\n            }\n            if (rule.t === \"change\" && rule.re) {\n                rule.fromt = 're';\n                delete rule.re;\n            }\n            if (rule.t === \"set\" && !rule.tot) {\n                if (rule.to.indexOf(\"msg.\") === 0 && !rule.tot) {\n                    rule.to = rule.to.substring(4);\n                    rule.tot = \"msg\";\n                }\n            }\n            if (!rule.tot) {\n                rule.tot = \"str\";\n            }\n            if (!rule.fromt) {\n                rule.fromt = \"str\";\n            }\n            if (rule.t === \"change\" && rule.fromt !== 'msg' && rule.fromt !== 'flow' && rule.fromt !== 'global') {\n                rule.fromRE = rule.from;\n                if (rule.fromt !== 're') {\n                    rule.fromRE = rule.fromRE.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n                }\n                try {\n                    rule.fromRE = new RegExp(rule.fromRE, \"g\");\n                } catch (e) {\n                    valid = false;\n                    this.error(RED._(\"change.errors.invalid-from\",{error:e.message}));\n                }\n            }\n            if (rule.tot === 'num') {\n                rule.to = Number(rule.to);\n            } else if (rule.tot === 'json') {\n                try {\n                    // check this is parsable JSON\n                    JSON.parse(rule.to);\n                } catch(e2) {\n                    valid = false;\n                    this.error(RED._(\"change.errors.invalid-json\"));\n                }\n            } else if (rule.tot === 'bool') {\n                rule.to = /^true$/i.test(rule.to);\n            } else if (rule.tot === 'jsonata') {\n                try {\n                    rule.to = jsonata(rule.to);\n                } catch(e) {\n                    valid = false;\n                    this.error(RED._(\"change.errors.invalid-from\",{error:e.message}));\n                }\n            }\n        }\n\n        function applyRule(msg,rule) {\n            try {\n                var property = rule.p;\n                var value = rule.to;\n                if (rule.tot === 'json') {\n                    value = JSON.parse(rule.to);\n                }\n                var current;\n                var fromValue;\n                var fromType;\n                var fromRE;\n                if (rule.tot === \"msg\") {\n                    value = RED.util.getMessageProperty(msg,rule.to);\n                } else if (rule.tot === 'flow') {\n                    value = node.context().flow.get(rule.to);\n                } else if (rule.tot === 'global') {\n                    value = node.context().global.get(rule.to);\n                } else if (rule.tot === 'date') {\n                    value = Date.now();\n                } else if (rule.tot === 'jsonata') {\n                    value = rule.to.evaluate({msg:msg});\n                }\n                if (rule.t === 'change') {\n                    if (rule.fromt === 'msg' || rule.fromt === 'flow' || rule.fromt === 'global') {\n                        if (rule.fromt === \"msg\") {\n                            fromValue = RED.util.getMessageProperty(msg,rule.from);\n                        } else if (rule.tot === 'flow') {\n                            fromValue = node.context().flow.get(rule.from);\n                        } else if (rule.tot === 'global') {\n                            fromValue = node.context().global.get(rule.from);\n                        }\n                        if (typeof fromValue === 'number' || fromValue instanceof Number) {\n                            fromType = 'num';\n                        } else if (typeof fromValue === 'boolean') {\n                            fromType = 'bool'\n                        } else if (fromValue instanceof RegExp) {\n                            fromType = 're';\n                            fromRE = fromValue;\n                        } else if (typeof fromValue === 'string') {\n                            fromType = 'str';\n                            fromRE = fromValue.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n                            try {\n                                fromRE = new RegExp(fromRE, \"g\");\n                            } catch (e) {\n                                valid = false;\n                                node.error(RED._(\"change.errors.invalid-from\",{error:e.message}));\n                                return;\n                            }\n                        } else {\n                            node.error(RED._(\"change.errors.invalid-from\",{error:\"unsupported type: \"+(typeof fromValue)}));\n                            return\n                        }\n                    } else {\n                        fromType = rule.fromt;\n                        fromValue = rule.from;\n                        fromRE = rule.fromRE;\n                    }\n                }\n                if (rule.pt === 'msg') {\n                    if (rule.t === 'delete') {\n                        RED.util.setMessageProperty(msg,property,undefined);\n                    } else if (rule.t === 'set') {\n                        RED.util.setMessageProperty(msg,property,value);\n                    } else if (rule.t === 'change') {\n                        current = RED.util.getMessageProperty(msg,property);\n                        if (typeof current === 'string') {\n                            if ((fromType === 'num' || fromType === 'bool' || fromType === 'str') && current === fromValue) {\n                                // str representation of exact from number/boolean\n                                // only replace if they match exactly\n                                RED.util.setMessageProperty(msg,property,value);\n                            } else {\n                                current = current.replace(fromRE,value);\n                                RED.util.setMessageProperty(msg,property,current);\n                            }\n                        } else if ((typeof current === 'number' || current instanceof Number) && fromType === 'num') {\n                            if (current == Number(fromValue)) {\n                                RED.util.setMessageProperty(msg,property,value);\n                            }\n                        } else if (typeof current === 'boolean' && fromType === 'bool') {\n                            if (current.toString() === fromValue) {\n                                RED.util.setMessageProperty(msg,property,value);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var target;\n                    if (rule.pt === 'flow') {\n                        target = node.context().flow;\n                    } else if (rule.pt === 'global') {\n                        target = node.context().global;\n                    }\n                    if (target) {\n                        if (rule.t === 'delete') {\n                            target.set(property,undefined);\n                        } else if (rule.t === 'set') {\n                            target.set(property,value);\n                        } else if (rule.t === 'change') {\n                            current = target.get(msg,property);\n                            if (typeof current === 'string') {\n                                if ((fromType === 'num' || fromType === 'bool' || fromType === 'str') && current === fromValue) {\n                                    // str representation of exact from number/boolean\n                                    // only replace if they match exactly\n                                    target.set(property,value);\n                                } else {\n                                    current = current.replace(fromRE,value);\n                                    target.set(property,current);\n                                }\n                            } else if ((typeof current === 'number' || current instanceof Number) && fromType === 'num') {\n                                if (current == Number(fromValue)) {\n                                    target.set(property,value);\n                                }\n                            } else if (typeof current === 'boolean' && fromType === 'bool') {\n                                if (current.toString() === fromValue) {\n                                    target.set(property,value);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch(err) {/*console.log(err.stack)*/}\n            return msg;\n        }\n        if (valid) {\n            var node = this;\n            this.on('input', function(msg) {\n                for (var i=0; i<this.rules.length; i++) {\n                    if (this.rules[i].t === \"move\") {\n                        var r = this.rules[i];\n                        if ((r.tot !== r.pt) || (r.p.indexOf(r.to) !== -1)) {\n                            msg = applyRule(msg,{t:\"set\", p:r.to, pt:r.tot, to:r.p, tot:r.pt});\n                            applyRule(msg,{t:\"delete\", p:r.p, pt:r.pt});\n                        }\n                        else { // 2 step move if we are moving from a child\n                            msg = applyRule(msg,{t:\"set\", p:\"_temp_move\", pt:r.tot, to:r.p, tot:r.pt});\n                            applyRule(msg,{t:\"delete\", p:r.p, pt:r.pt});\n                            msg = applyRule(msg,{t:\"set\", p:r.to, pt:r.tot, to:\"_temp_move\", tot:r.pt});\n                            applyRule(msg,{t:\"delete\", p:\"_temp_move\", pt:r.pt});\n                        }\n                    } else {\n                        msg = applyRule(msg,this.rules[i]);\n                    }\n                    if (msg === null) {\n                        return;\n                    }\n                }\n                node.send(msg);\n            });\n        }\n    }\n    RED.nodes.registerType(\"change\", ChangeNode);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/logic/16-range.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    function RangeNode(n) {\n        RED.nodes.createNode(this, n);\n        this.action = n.action;\n        this.round = n.round || false;\n        this.minin = Number(n.minin);\n        this.maxin = Number(n.maxin);\n        this.minout = Number(n.minout);\n        this.maxout = Number(n.maxout);\n        var node = this;\n\n        this.on('input', function (msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var n = Number(msg.payload);\n                if (!isNaN(n)) {\n                    if (node.action == \"clamp\") {\n                        if (n < node.minin) { n = node.minin; }\n                        if (n > node.maxin) { n = node.maxin; }\n                    }\n                    if (node.action == \"roll\") {\n                        if (n >= node.maxin) { n = (n - node.minin) % (node.maxin - node.minin) + node.minin; }\n                        if (n <  node.minin) { n = (n - node.minin) % (node.maxin - node.minin) + node.maxin; }\n                    }\n                    msg.payload = ((n - node.minin) / (node.maxin - node.minin) * (node.maxout - node.minout)) + node.minout;\n                    if (node.round) { msg.payload = Math.round(msg.payload); }\n                    node.send(msg);\n                }\n                else { node.log(RED._(\"range.errors.notnumber\")+\": \"+msg.payload); }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"range\", RangeNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/logic/17-split.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function SplitNode(n) {\n        RED.nodes.createNode(this,n);\n        this.splt = (n.splt || \"\\\\n\").replace(/\\\\n/,\"\\n\").replace(/\\\\r/,\"\\r\").replace(/\\\\t/,\"\\t\").replace(/\\\\e/,\"\\e\").replace(/\\\\f/,\"\\f\").replace(/\\\\0/,\"\\0\");\n        var node = this;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var a = msg.payload;\n                if (msg.hasOwnProperty(\"parts\")) { msg.parts = { parts:msg.parts }; } // push existing parts to a stack\n                else { msg.parts = {}; }\n                msg.parts.id = msg._msgid;  // use the existing _msgid by default.\n                if (typeof msg.payload === \"string\") { // Split String into array\n                    a = msg.payload.split(node.splt);\n                    msg.parts.ch = node.splt; // pass the split char to other end for rejoin\n                    msg.parts.type = \"string\";\n                }\n                if (Array.isArray(a)) { // then split array into messages\n                    msg.parts.type = msg.parts.type || \"array\";  // if it wasn't a string in the first place\n                    for (var i = 0; i < a.length; i++) {\n                        msg.payload = a[i];\n                        msg.parts.index = i;\n                        msg.parts.count = a.length;\n                        node.send(RED.util.cloneMessage(msg));\n                    }\n                }\n                else if ((typeof msg.payload === \"object\") && !Buffer.isBuffer(msg.payload)) {\n                    var j = 0;\n                    var l = Object.keys(msg.payload).length;\n                    var pay = msg.payload;\n                    msg.parts.type = \"object\";\n                    for (var p in pay) {\n                        if (pay.hasOwnProperty(p)) {\n                            msg.payload = pay[p];\n                            msg.parts.key = p;\n                            msg.parts.index = j;\n                            msg.parts.count = l;\n                            node.send(RED.util.cloneMessage(msg));\n                            j += 1;\n                        }\n                    }\n                }\n                // TODO not handling Buffers at present...\n                //else {  }   // otherwise drop the message.\n            }\n        });\n    }\n    RED.nodes.registerType(\"split\",SplitNode);\n\n\n    function JoinNode(n) {\n        RED.nodes.createNode(this,n);\n        this.mode = n.mode||\"auto\";\n        this.property = n.property||\"payload\";\n        this.propertyType = n.propertyType||\"msg\";\n        if (this.propertyType === 'full') {\n            this.property = \"payload\";\n        }\n        this.key = n.key||\"topic\";\n        this.timer = (this.mode === \"auto\") ? 0 : Number(n.timeout || 0)*1000;\n        this.timerr = n.timerr || \"send\";\n        this.count = Number(n.count || 0);\n        this.joiner = (n.joiner||\"\").replace(/\\\\n/g,\"\\n\").replace(/\\\\r/g,\"\\r\").replace(/\\\\t/g,\"\\t\").replace(/\\\\e/g,\"\\e\").replace(/\\\\f/g,\"\\f\").replace(/\\\\0/g,\"\\0\");\n        this.build = n.build || \"array\";\n        var node = this;\n        var inflight = {};\n\n        var completeSend = function(partId) {\n            var group = inflight[partId];\n            clearTimeout(group.timeout);\n            delete inflight[partId];\n\n            if (group.type === 'string') {\n                RED.util.setMessageProperty(group.msg,node.property,group.payload.join(group.joinChar));\n            } else {\n                RED.util.setMessageProperty(group.msg,node.property,group.payload);\n            }\n            if (group.msg.hasOwnProperty('parts') && group.msg.parts.hasOwnProperty('parts')) {\n                group.msg.parts = group.msg.parts.parts;\n            } else {\n                delete group.msg.parts;\n            }\n            node.send(group.msg);\n        }\n\n        this.on(\"input\", function(msg) {\ntry {\n            var property;\n            if (node.mode === 'auto' && (!msg.hasOwnProperty(\"parts\")||!msg.parts.hasOwnProperty(\"id\"))) {\n                node.warn(\"Message missing msg.parts property - cannot join in 'auto' mode\")\n                return;\n            }\n            if (node.propertyType == \"full\") {\n                property = msg;\n            } else {\n                try {\n                    property = RED.util.getMessageProperty(msg,node.property);\n                } catch(err) {\n                    node.warn(\"Message property \"+node.property+\" not found\");\n                    return;\n                }\n            }\n\n            var partId;\n            var payloadType;\n            var propertyKey;\n            var targetCount;\n            var joinChar;\n            var propertyIndex;\n            if (node.mode === \"auto\") {\n                // Use msg.parts to identify all of the group information\n                partId = msg.parts.id;\n                payloadType = msg.parts.type;\n                targetCount = msg.parts.count;\n                joinChar = msg.parts.ch;\n                propertyKey = msg.parts.key;\n                propertyIndex = msg.parts.index;\n            } else {\n                // Use the node configuration to identify all of the group information\n                partId = \"_\";\n                payloadType = node.build;\n                targetCount = node.count;\n                joinChar = node.joiner;\n                if (targetCount === 0 && msg.hasOwnProperty('parts')) {\n                    targetCount = msg.parts.count || 0;\n                }\n                if (node.build === 'object') {\n                    propertyKey = RED.util.getMessageProperty(msg,node.key);\n                }\n            }\n            if (payloadType === 'object' && (propertyKey === null || propertyKey === undefined || propertyKey === \"\")) {\n                if (node.mode === \"auto\") {\n                    node.warn(\"Message missing 'msg.parts.key' property - cannot add to object\");\n                } else {\n                    node.warn(\"Message missing key property 'msg.\"+node.key+\"' '- cannot add to object\")\n                }\n                return;\n            }\n            if (!inflight.hasOwnProperty(partId)) {\n                if (payloadType === 'object' || payloadType === 'merged') {\n                    inflight[partId] = {\n                        currentCount:0,\n                        payload:{},\n                        targetCount:targetCount,\n                        type:\"object\",\n                        msg:msg\n                    };\n                } else {\n                    inflight[partId] = {\n                        currentCount:0,\n                        payload:[],\n                        targetCount:targetCount,\n                        type:payloadType,\n                        joinChar: joinChar,\n                        msg:msg\n                    };\n                    if (payloadType === 'string') {\n                        inflight[partId].joinChar = joinChar;\n                    }\n                }\n                if (node.timer > 0) {\n                    inflight[partId].timeout = setTimeout(function() {\n                        completeSend(partId)\n                    }, node.timer)\n                }\n            }\n\n            var group = inflight[partId];\n            if (payloadType === 'object') {\n                group.payload[propertyKey] = property;\n                group.currentCount = Object.keys(group.payload).length;\n            } else if (payloadType === 'merged') {\n                if (Array.isArray(property) || typeof property !== 'object') {\n                    node.warn(\"Cannot merge non-object types\");\n                } else {\n                    for (propertyKey in property) {\n                        if (property.hasOwnProperty(propertyKey)) {\n                            group.payload[propertyKey] = property[propertyKey];\n                        }\n                    }\n                    group.currentCount++;\n                }\n            } else {\n                if (!isNaN(propertyIndex)) {\n                    group.payload[propertyIndex] = property;\n                } else {\n                    group.payload.push(property);\n                }\n                group.currentCount++;\n            }\n            // TODO: currently reuse the last received - add option to pick first received\n            group.msg = msg;\n            if (group.currentCount === group.targetCount || msg.hasOwnProperty('complete')) {\n                delete msg.complete;\n                completeSend(partId);\n            }\n} catch(err) {\n    console.log(err.stack);\n}\n        });\n\n        this.on(\"close\", function() {\n            for (var i in inflight) {\n                if (inflight.hasOwnProperty(i)) {\n                    clearTimeout(inflight[i].timeout);\n                }\n            }\n        });\n    }\n    RED.nodes.registerType(\"join\",JoinNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/parsers/70-CSV.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    function CSVNode(n) {\n        RED.nodes.createNode(this,n);\n        this.template = (n.temp || \"\").split(\",\");\n        this.sep = (n.sep || ',').replace(\"\\\\t\",\"\\t\").replace(\"\\\\n\",\"\\n\").replace(\"\\\\r\",\"\\r\");\n        this.quo = '\"';\n        this.ret = (n.ret || \"\\n\").replace(\"\\\\n\",\"\\n\").replace(\"\\\\r\",\"\\r\");\n        this.winflag = (this.ret === \"\\r\\n\");\n        this.lineend = \"\\n\";\n        this.multi = n.multi || \"one\";\n        this.hdrin = n.hdrin || false;\n        this.hdrout = n.hdrout || false;\n        this.goodtmpl = true;\n        var node = this;\n\n        // pass in an array of column names to be trimed, de-quoted and retrimed\n        var clean = function(col) {\n            for (var t = 0; t < col.length; t++) {\n                col[t] = col[t].trim(); // remove leading and trailing whitespace\n                if (col[t].charAt(0) === '\"' && col[t].charAt(col[t].length -1) === '\"') {\n                    // remove leading and trailing quotes (if they exist) - and remove whitepace again.\n                    col[t] = col[t].substr(1,col[t].length -2).trim();\n                }\n            }\n            if ((col.length === 1) && (col[0] === \"\")) { node.goodtmpl = false; }\n            else { node.goodtmpl = true; }\n            return col;\n        }\n        node.template = clean(node.template);\n\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                if (typeof msg.payload == \"object\") { // convert object to CSV string\n                    try {\n                        var ou = \"\";\n                        if (node.hdrout) {\n                            ou += node.template.join(node.sep) + node.ret;\n                        }\n                        if (!Array.isArray(msg.payload)) { msg.payload = [ msg.payload ]; }\n                        for (var s = 0; s < msg.payload.length; s++) {\n                            if ((Array.isArray(msg.payload[s])) || (typeof msg.payload[s] !== \"object\")) {\n                                if (typeof msg.payload[s] !== \"object\") { msg.payload = [ msg.payload ]; }\n                                for (var t = 0; t < msg.payload[s].length; t++) {\n                                    if (!msg.payload[s][t] && (msg.payload[s][t] !== 0)) { msg.payload[s][t] = \"\"; }\n                                    if (msg.payload[s][t].toString().indexOf(node.quo) !== -1) { // add double quotes if any quotes\n                                        msg.payload[s][t] = msg.payload[s][t].toString().replace(/\"/g, '\"\"');\n                                        msg.payload[s][t] = node.quo + msg.payload[s][t].toString() + node.quo;\n                                    }\n                                    else if (msg.payload[s][t].toString().indexOf(node.sep) !== -1) { // add quotes if any \"commas\"\n                                        msg.payload[s][t] = node.quo + msg.payload[s][t].toString() + node.quo;\n                                    }\n                                }\n                                ou += msg.payload[s].join(node.sep) + node.ret;\n                            }\n                            else {\n                                if ((node.template.length === 1) && (node.template[0] === '')) {\n                                    node.warn(RED._(\"csv.errors.obj_csv\"));\n                                }\n                                else {\n                                    for (var t=0; t < node.template.length; t++) {\n                                        if (node.template[t] === '') {\n                                            ou += node.sep;\n                                        }\n                                        else {\n                                            // aaargh - resorting to eval here - but fairly contained front and back.\n                                            var p = RED.util.ensureString(eval(\"msg.payload[s].\"+node.template[t]));\n\n                                            if (p === \"undefined\") { p = \"\"; }\n                                            if (p.indexOf(node.quo) !== -1) { // add double quotes if any quotes\n                                                p = p.replace(/\"/g, '\"\"');\n                                                ou += node.quo + p + node.quo + node.sep;\n                                            }\n                                            else if (p.indexOf(node.sep) !== -1) { // add quotes if any \"commas\"\n                                                ou += node.quo + p + node.quo + node.sep;\n                                            }\n                                            else { ou += p + node.sep; } // otherwise just add\n                                        }\n                                    }\n                                    ou = ou.slice(0,-1) + node.ret; // remove final \"comma\" and add \"newline\"\n                                }\n                            }\n                        }\n                        msg.payload = ou;\n                        if (msg.payload !== '') { node.send(msg); }\n                    }\n                    catch(e) { node.error(e,msg); }\n                }\n                else if (typeof msg.payload == \"string\") { // convert CSV string to object\n                    try {\n                        var f = true; // flag to indicate if inside or outside a pair of quotes true = outside.\n                        var j = 0; // pointer into array of template items\n                        var k = [\"\"]; // array of data for each of the template items\n                        var o = {}; // output object to build up\n                        var a = []; // output array is needed for multiline option\n                        var first = true; // is this the first line\n                        var line = msg.payload;\n                        var tmp = \"\";\n                        var reg = new RegExp(\"^[-]?[0-9.]*[\\.]?[0-9]*$\");\n\n                        // For now we are just going to assume that any \\r or \\n means an end of line...\n                        //   got to be a weird csv that has singleton \\r \\n in it for another reason...\n\n                        // Now process the whole file/line\n                        for (var i = 0; i < line.length; i++) {\n                            if ((node.hdrin === true) && first) { // if the template is in the first line\n                                if ((line[i] === \"\\n\")||(line[i] === \"\\r\")) { // look for first line break\n                                    node.template = clean(tmp.split(node.sep));\n                                    first = false;\n                                }\n                                else { tmp += line[i]; }\n                            }\n                            else {\n                                if (line[i] === node.quo) { // if it's a quote toggle inside or outside\n                                    f = !f;\n                                    if (line[i-1] === node.quo) { k[j] += '\\\"'; } // if it's a quotequote then it's actually a quote\n                                    //if ((line[i-1] !== node.sep) && (line[i+1] !== node.sep)) { k[j] += line[i]; }\n                                }\n                                else if ((line[i] === node.sep) && f) { // if it is the end of the line then finish\n                                    if (!node.goodtmpl) { node.template[j] = \"col\"+(j+1); }\n                                    if ( node.template[j] && (node.template[j] !== \"\") && (k[j] !== \"\" ) ) {\n                                        if ( reg.test(k[j]) ) { k[j] = parseFloat(k[j]); }\n                                        o[node.template[j]] = k[j];\n                                    }\n                                    j += 1;\n                                    k[j] = \"\";\n                                }\n                                else if ((line[i] === \"\\n\") || (line[i] === \"\\r\")) { // handle multiple lines\n                                    //console.log(j,k,o,k[j]);\n                                    if (!node.goodtmpl) { node.template[j] = \"col\"+(j+1); }\n                                    if ( node.template[j] && (node.template[j] !== \"\") && (k[j] !== \"\") ) {\n                                        if ( reg.test(k[j]) ) { k[j] = parseFloat(k[j]); }\n                                        else { k[j].replace(/\\r$/,''); }\n                                        o[node.template[j]] = k[j];\n                                    }\n                                    if (JSON.stringify(o) !== \"{}\") { // don't send empty objects\n                                        if (node.multi === \"one\") {\n                                            var newMessage = RED.util.cloneMessage(msg);\n                                            newMessage.payload = o;\n                                            node.send(newMessage); // either send\n                                        }\n                                        else { a.push(o); } // or add to the array\n                                    }\n                                    j = 0;\n                                    k = [\"\"];\n                                    o = {};\n                                    f = true; // reset in/out flag ready for next line.\n                                }\n                                else { // just add to the part of the message\n                                    k[j] += line[i];\n                                }\n                            }\n                        }\n                        // Finished so finalize and send anything left\n                        //console.log(j,k,o,k[j]);\n                        if (!node.goodtmpl) { node.template[j] = \"col\"+(j+1); }\n                        if ( node.template[j] && (node.template[j] !== \"\") && (k[j] !== \"\") ) {\n                            if ( reg.test(k[j]) ) { k[j] = parseFloat(k[j]); }\n                            else { k[j].replace(/\\r$/,''); }\n                            o[node.template[j]] = k[j];\n                        }\n                        if (JSON.stringify(o) !== \"{}\") { // don't send empty objects\n                            if (node.multi === \"one\") {\n                                var newMessage = RED.util.cloneMessage(msg);\n                                newMessage.payload = o;\n                                node.send(newMessage); // either send\n                            }\n                            else { a.push(o); } // or add to the aray\n                        }\n                        if (node.multi !== \"one\") {\n                            msg.payload = a;\n                            node.send(msg); // finally send the array\n                        }\n                    }\n                    catch(e) { node.error(e,msg); }\n                }\n                else { node.warn(RED._(\"csv.errors.csv_js\")); }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"csv\",CSVNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/parsers/70-HTML.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var cheerio = require('cheerio');\n\n    function CheerioNode(n) {\n        RED.nodes.createNode(this,n);\n        this.tag = n.tag;\n        this.ret = n.ret || \"html\";\n        this.as = n.as || \"single\";\n        var node = this;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var tag = node.tag;\n                if (msg.hasOwnProperty(\"select\")) { tag = node.tag || msg.select; }\n                try {\n                    var $ = cheerio.load(msg.payload);\n                    var pay = [];\n                    $(tag).each(function() {\n                        if (node.as === \"multi\") {\n                            var pay2 = null;\n                            if (node.ret === \"html\") { pay2 = cheerio.load($(this).html().trim()).xml(); }\n                            if (node.ret === \"text\") { pay2 = $(this).text(); }\n                            if (node.ret === \"attr\") { pay2 = this.attribs; }\n                            //if (node.ret === \"val\")  { pay2 = $(this).val(); }\n                            /* istanbul ignore else */\n                            if (pay2) {\n                                msg.payload = pay2;\n                                node.send(msg);\n                            }\n                        }\n                        if (node.as === \"single\") {\n                            if (node.ret === \"html\") { pay.push( cheerio.load($(this).html().trim()).xml() ); }\n                            if (node.ret === \"text\") { pay.push( $(this).text() ); }\n                            if (node.ret === \"attr\") { pay.push( this.attribs ); }\n                            //if (node.ret === \"val\")  { pay.push( $(this).val() ); }\n                        }\n                    });\n                    if ((node.as === \"single\") && (pay.length !== 0)) {\n                        msg.payload = pay;\n                        node.send(msg);\n                    }\n                } catch (error) {\n                    node.error(error.message,msg);\n                }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"html\",CheerioNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/parsers/70-JSON.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n\n    function JSONNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                if (typeof msg.payload === \"string\") {\n                    try {\n                        msg.payload = JSON.parse(msg.payload);\n                        node.send(msg);\n                    }\n                    catch(e) { node.error(e.message,msg); }\n                }\n                else if (typeof msg.payload === \"object\") {\n                    if (!Buffer.isBuffer(msg.payload)) {\n                        try {\n                            msg.payload = JSON.stringify(msg.payload);\n                            node.send(msg);\n                        }\n                        catch(e) { node.error(RED._(\"json.errors.dropped-error\")); }\n                    }\n                    else { node.warn(RED._(\"json.errors.dropped-object\")); }\n                }\n                else { node.warn(RED._(\"json.errors.dropped\")); }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"json\",JSONNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/parsers/70-XML.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var xml2js = require('xml2js');\n    var parseString = xml2js.parseString;\n\n    function XMLNode(n) {\n        RED.nodes.createNode(this,n);\n        this.attrkey = n.attr;\n        this.charkey = n.chr;\n        var node = this;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var options;\n                if (typeof msg.payload === \"object\") {\n                    options = {renderOpts:{pretty:false}};\n                    if (msg.hasOwnProperty(\"options\") && typeof msg.options === \"object\") { options = msg.options; }\n                    options.async = false;\n                    var builder = new xml2js.Builder(options);\n                    msg.payload = builder.buildObject(msg.payload, options);\n                    node.send(msg);\n                }\n                else if (typeof msg.payload == \"string\") {\n                    options = {};\n                    if (msg.hasOwnProperty(\"options\") && typeof msg.options === \"object\") { options = msg.options; }\n                    options.async = true;\n                    options.attrkey = node.attrkey || options.attrkey || '$';\n                    options.charkey = node.charkey || options.charkey || '_';\n                    parseString(msg.payload, options, function (err, result) {\n                        if (err) { node.error(err, msg); }\n                        else {\n                            msg.payload = result;\n                            node.send(msg);\n                        }\n                    });\n                }\n                else { node.warn(RED._(\"xml.errors.xml_js\")); }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"xml\",XMLNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/parsers/70-YAML.js":"\nmodule.exports = function(RED) {\n    \"use strict\";\n    var yaml = require('js-yaml');\n    function YAMLNode(n) {\n        RED.nodes.createNode(this,n);\n        var node = this;\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                if (typeof msg.payload === \"string\") {\n                    try {\n                        msg.payload = yaml.load(msg.payload);\n                        node.send(msg);\n                    }\n                    catch(e) { node.error(e.message,msg); }\n                }\n                else if (typeof msg.payload === \"object\") {\n                    if (!Buffer.isBuffer(msg.payload)) {\n                        try {\n                            msg.payload = yaml.dump(msg.payload);\n                            node.send(msg);\n                        }\n                        catch(e) {\n                            node.error(RED._(\"yaml.errors.dropped-error\"));\n                        }\n                    }\n                    else { node.warn(RED._(\"yaml.errors.dropped-object\")); }\n                }\n                else { node.warn(RED._(\"yaml.errors.dropped\")); }\n            }\n            else { node.send(msg); } // If no payload - just pass it on.\n        });\n    }\n    RED.nodes.registerType(\"yaml\",YAMLNode);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/storage/28-tail.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var spawn = require('child_process').spawn;\n    var plat = require('os').platform();\n\n    if (plat.match(/^win/)) {\n        throw RED._(\"tail.errors.windowsnotsupport\");\n    }\n\n    function TailNode(n) {\n        RED.nodes.createNode(this,n);\n\n        this.filename = n.filename;\n        this.filetype = n.filetype || \"text\";\n        this.split = n.split || false;\n        var node = this;\n\n        var err = \"\";\n        // TODO: rewrite to use node-tail\n        var tail = spawn(\"tail\", [\"-F\", \"-n\", \"0\", this.filename]);\n        tail.stdout.on(\"data\", function (data) {\n            var msg = { topic:node.filename };\n            if (node.filetype === \"text\") {\n                if (node.split) {\n                    // TODO: allow customisation of the line break - as we do elsewhere\n                    var strings = data.toString().split(\"\\n\");\n                    for (var s in strings) {\n                        //TODO: should we really filter blanks? Is that expected?\n                        if (strings[s] !== \"\") {\n                            node.send({\n                                topic: node.filename,\n                                payload: strings[s]\n                            });\n                        }\n                    }\n                }\n                else {\n                    msg.payload = data.toString();\n                    node.send(msg);\n                }\n            }\n            else {\n                msg.payload = data;\n                node.send(msg);\n            }\n        });\n\n        tail.stderr.on(\"data\", function(data) {\n            node.error(data.toString());\n        });\n\n        this.on(\"close\", function() {\n            /* istanbul ignore else */\n            if (tail) { tail.kill(); }\n        });\n    }\n\n    RED.nodes.registerType(\"tail\",TailNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/nodes/core/storage/50-file.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var fs = require(\"fs-extra\");\n    var os = require(\"os\");\n\n    function FileNode(n) {\n        RED.nodes.createNode(this,n);\n        this.filename = n.filename;\n        this.appendNewline = n.appendNewline;\n        this.overwriteFile = n.overwriteFile.toString();\n        this.createDir = n.createDir || false;\n        var node = this;\n\n        this.on(\"input\",function(msg) {\n            var filename = node.filename || msg.filename || \"\";\n            if (!node.filename) {\n                node.status({fill:\"grey\",shape:\"dot\",text:filename});\n            }\n            if (filename === \"\") {\n                node.warn(RED._(\"file.errors.nofilename\"));\n            } else if (msg.hasOwnProperty(\"payload\") && (typeof msg.payload !== \"undefined\")) {\n                var data = msg.payload;\n                if ((typeof data === \"object\") && (!Buffer.isBuffer(data))) {\n                    data = JSON.stringify(data);\n                }\n                if (typeof data === \"boolean\") { data = data.toString(); }\n                if (typeof data === \"number\") { data = data.toString(); }\n                if ((this.appendNewline) && (!Buffer.isBuffer(data))) { data += os.EOL; }\n                data = new Buffer(data);\n                if (this.overwriteFile === \"true\") {\n                    // using \"binary\" not {encoding:\"binary\"} to be 0.8 compatible for a while\n                    //fs.writeFile(filename, data, \"binary\", function (err) {\n                    fs.writeFile(filename, data, {encoding:\"binary\"}, function (err) {\n                        if (err) {\n                            if ((err.code === \"ENOENT\") && node.createDir) {\n                                fs.ensureFile(filename, function (err) {\n                                    if (err) { node.error(RED._(\"file.errors.createfail\",{error:err.toString()}),msg); }\n                                    else {\n                                        fs.writeFile(filename, data, \"binary\", function (err) {\n                                            if (err) { node.error(RED._(\"file.errors.writefail\",{error:err.toString()}),msg); }\n                                        });\n                                    }\n                                });\n                            }\n                            else { node.error(RED._(\"file.errors.writefail\",{error:err.toString()}),msg); }\n                        }\n                        else if (RED.settings.verbose) { node.log(RED._(\"file.status.wrotefile\",{file:filename})); }\n                    });\n                }\n                else if (this.overwriteFile === \"delete\") {\n                    fs.unlink(filename, function (err) {\n                        if (err) { node.error(RED._(\"file.errors.deletefail\",{error:err.toString()}),msg); }\n                        else if (RED.settings.verbose) { node.log(RED._(\"file.status.deletedfile\",{file:filename})); }\n                    });\n                }\n                else {\n                    // using \"binary\" not {encoding:\"binary\"} to be 0.8 compatible for a while longer\n                    //fs.appendFile(filename, data, \"binary\", function (err) {\n                    fs.appendFile(filename, data, {encoding:\"binary\"}, function (err) {\n                        if (err) {\n                            if ((err.code === \"ENOENT\") && node.createDir) {\n                                fs.ensureFile(filename, function (err) {\n                                    if (err) { node.error(RED._(\"file.errors.createfail\",{error:err.toString()}),msg); }\n                                    else {\n                                        fs.appendFile(filename, data, \"binary\", function (err) {\n                                            if (err) { node.error(RED._(\"file.errors.appendfail\",{error:err.toString()}),msg); }\n                                        });\n                                    }\n                                });\n                            }\n                            else { node.error(RED._(\"file.errors.appendfail\",{error:err.toString()}),msg); }\n                        }\n                        else if (RED.settings.verbose) { node.log(RED._(\"file.status.appendedfile\",{file:filename})); }\n                    });\n                }\n            }\n        });\n        this.on('close', function() {\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"file\",FileNode);\n\n\n    function FileInNode(n) {\n        RED.nodes.createNode(this,n);\n\n        this.filename = n.filename;\n        this.format = n.format;\n        var node = this;\n        var options = {};\n        if (this.format) {\n            options['encoding'] = this.format;\n        }\n        this.on(\"input\",function(msg) {\n            var filename = node.filename || msg.filename || \"\";\n            if (!node.filename) {\n                node.status({fill:\"grey\",shape:\"dot\",text:filename});\n            }\n            if (filename === \"\") {\n                node.warn(RED._(\"file.errors.nofilename\"));\n            } else {\n                msg.filename = filename;\n                fs.readFile(filename,options,function(err,data) {\n                    if (err) {\n                        node.error(err,msg);\n                        msg.error = err;\n                        delete msg.payload;\n                    } else {\n                        msg.payload = data;\n                        delete msg.error;\n                    }\n                    node.send(msg);\n                });\n            }\n        });\n        this.on('close', function() {\n            node.status({});\n        });\n    }\n    RED.nodes.registerType(\"file in\",FileInNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red/red/runtime/storage/localfilesystem.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require('fs-extra');\nvar when = require('when');\nvar nodeFn = require('when/node/function');\nvar keys = require('when/keys');\nvar fspath = require(\"path\");\nvar mkdirp = fs.mkdirs;\n\nvar log = require(\"../log\");\n\nvar promiseDir = nodeFn.lift(mkdirp);\n\nvar initialFlowLoadComplete = false;\nvar settings;\nvar flowsFile;\nvar flowsFullPath;\nvar flowsFileBackup;\nvar credentialsFile;\nvar credentialsFileBackup;\nvar oldCredentialsFile;\nvar sessionsFile;\nvar libDir;\nvar libFlowsDir;\nvar globalSettingsFile;\n\nfunction getFileMeta(root,path) {\n    var fn = fspath.join(root,path);\n    var fd = fs.openSync(fn,\"r\");\n    var size = fs.fstatSync(fd).size;\n    var meta = {};\n    var read = 0;\n    var length = 10;\n    var remaining = \"\";\n    var buffer = Buffer(length);\n    while(read < size) {\n        read+=fs.readSync(fd,buffer,0,length);\n        var data = remaining+buffer.toString();\n        var parts = data.split(\"\\n\");\n        remaining = parts.splice(-1);\n        for (var i=0;i<parts.length;i+=1) {\n            var match = /^\\/\\/ (\\w+): (.*)/.exec(parts[i]);\n            if (match) {\n                meta[match[1]] = match[2];\n            } else {\n                read = size;\n                break;\n            }\n        }\n    }\n    fs.closeSync(fd);\n    return meta;\n}\n\nfunction getFileBody(root,path) {\n    var body = \"\";\n    var fn = fspath.join(root,path);\n    var fd = fs.openSync(fn,\"r\");\n    var size = fs.fstatSync(fd).size;\n    var scanning = true;\n    var read = 0;\n    var length = 50;\n    var remaining = \"\";\n    var buffer = Buffer(length);\n    while(read < size) {\n        var thisRead = fs.readSync(fd,buffer,0,length);\n        read += thisRead;\n        if (scanning) {\n            var data = remaining+buffer.slice(0,thisRead).toString();\n            var parts = data.split(\"\\n\");\n            remaining = parts.splice(-1)[0];\n            for (var i=0;i<parts.length;i+=1) {\n                if (! /^\\/\\/ \\w+: /.test(parts[i])) {\n                    scanning = false;\n                    body += parts[i]+\"\\n\";\n                }\n            }\n            if (! /^\\/\\/ \\w+: /.test(remaining)) {\n                scanning = false;\n            }\n            if (!scanning) {\n                body += remaining;\n            }\n        } else {\n            body += buffer.slice(0,thisRead).toString();\n        }\n    }\n    fs.closeSync(fd);\n    return body;\n}\n\n/**\n * Write content to a file using UTF8 encoding.\n * This forces a fsync before completing to ensure\n * the write hits disk.\n */\nfunction writeFile(path,content) {\n    return when.promise(function(resolve,reject) {\n        var stream = fs.createWriteStream(path);\n        stream.on('open',function(fd) {\n            stream.end(content,'utf8',function() {\n                fs.fsync(fd,resolve);\n            });\n        });\n        stream.on('error',function(err) {\n            reject(err);\n        });\n    });\n}\n\n\nfunction readFile(path,backupPath,emptyResponse,type) {\n    return when.promise(function(resolve) {\n        fs.readFile(path,'utf8',function(err,data) {\n            if (!err) {\n                if (data.length === 0) {\n                    log.warn(log._(\"storage.localfilesystem.empty\",{type:type}));\n                    try {\n                        var backupStat = fs.statSync(backupPath);\n                        if (backupStat.size === 0) {\n                            // Empty flows, empty backup - return empty flow\n                            return resolve(emptyResponse);\n                        }\n                        // Empty flows, restore backup\n                        log.warn(log._(\"storage.localfilesystem.restore\",{path:backupPath,type:type}));\n                        fs.copy(backupPath,path,function(backupCopyErr) {\n                            if (backupCopyErr) {\n                                // Restore backup failed\n                                log.warn(log._(\"storage.localfilesystem.restore-fail\",{message:backupCopyErr.toString(),type:type}));\n                                resolve([]);\n                            } else {\n                                // Loop back in to load the restored backup\n                                resolve(readFile(path,backupPath,emptyResponse,type));\n                            }\n                        });\n                        return;\n                    } catch(backupStatErr) {\n                        // Empty flow file, no back-up file\n                        return resolve(emptyResponse);\n                    }\n                }\n                try {\n                    return resolve(JSON.parse(data));\n                } catch(parseErr) {\n                    log.warn(log._(\"storage.localfilesystem.invalid\",{type:type}));\n                    return resolve(emptyResponse);\n                }\n            } else {\n                if (type === 'flow') {\n                    log.info(log._(\"storage.localfilesystem.create\",{type:type}));\n                }\n                resolve(emptyResponse);\n            }\n        });\n    });\n}\n\nvar localfilesystem = {\n    init: function(_settings) {\n        settings = _settings;\n\n        var promises = [];\n\n        if (!settings.userDir) {\n            try {\n                fs.statSync(fspath.join(process.env.NODE_RED_HOME,\".config.json\"));\n                settings.userDir = process.env.NODE_RED_HOME;\n            } catch(err) {\n                settings.userDir = fspath.join(process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE || process.env.NODE_RED_HOME,\".node-red\");\n                if (!settings.readOnly) {\n                    promises.push(promiseDir(fspath.join(settings.userDir,\"node_modules\")));\n                }\n            }\n        }\n\n        if (settings.flowFile) {\n            flowsFile = settings.flowFile;\n            // handle Unix and Windows \"C:\\\"\n            if ((flowsFile[0] == \"/\") || (flowsFile[1] == \":\")) {\n                // Absolute path\n                flowsFullPath = flowsFile;\n            } else if (flowsFile.substring(0,2) === \"./\") {\n                // Relative to cwd\n                flowsFullPath = fspath.join(process.cwd(),flowsFile);\n            } else {\n                try {\n                    fs.statSync(fspath.join(process.cwd(),flowsFile));\n                    // Found in cwd\n                    flowsFullPath = fspath.join(process.cwd(),flowsFile);\n                } catch(err) {\n                    // Use userDir\n                    flowsFullPath = fspath.join(settings.userDir,flowsFile);\n                }\n            }\n\n        } else {\n            flowsFile = 'flows_'+require('os').hostname()+'.json';\n            flowsFullPath = fspath.join(settings.userDir,flowsFile);\n        }\n        var ffExt = fspath.extname(flowsFullPath);\n        var ffName = fspath.basename(flowsFullPath);\n        var ffBase = fspath.basename(flowsFullPath,ffExt);\n        var ffDir = fspath.dirname(flowsFullPath);\n\n        credentialsFile = fspath.join(settings.userDir,ffBase+\"_cred\"+ffExt);\n        credentialsFileBackup = fspath.join(settings.userDir,\".\"+ffBase+\"_cred\"+ffExt+\".backup\");\n\n        oldCredentialsFile = fspath.join(settings.userDir,\"credentials.json\");\n\n        flowsFileBackup = fspath.join(ffDir,\".\"+ffName+\".backup\");\n\n        sessionsFile = fspath.join(settings.userDir,\".sessions.json\");\n\n        libDir = fspath.join(settings.userDir,\"lib\");\n        libFlowsDir = fspath.join(libDir,\"flows\");\n\n        globalSettingsFile = fspath.join(settings.userDir,\".config.json\");\n\n        if (!settings.readOnly) {\n            promises.push(promiseDir(libFlowsDir));\n        }\n\n        return when.all(promises);\n    },\n\n    getFlows: function() {\n        if (!initialFlowLoadComplete) {\n            initialFlowLoadComplete = true;\n            log.info(log._(\"storage.localfilesystem.user-dir\",{path:settings.userDir}));\n            log.info(log._(\"storage.localfilesystem.flows-file\",{path:flowsFullPath}));\n        }\n        return readFile(flowsFullPath,flowsFileBackup,[],'flow');\n    },\n\n    saveFlows: function(flows) {\n        if (settings.readOnly) {\n            return when.resolve();\n        }\n\n        try {\n            fs.renameSync(flowsFullPath,flowsFileBackup);\n        } catch(err) {\n        }\n\n        var flowData;\n\n        if (settings.flowFilePretty) {\n            flowData = JSON.stringify(flows,null,4);\n        } else {\n            flowData = JSON.stringify(flows);\n        }\n        return writeFile(flowsFullPath, flowData);\n    },\n\n    getCredentials: function() {\n        return readFile(credentialsFile,credentialsFileBackup,{},'credentials');\n    },\n\n    saveCredentials: function(credentials) {\n        if (settings.readOnly) {\n            return when.resolve();\n        }\n\n        try {\n            fs.renameSync(credentialsFile,credentialsFileBackup);\n        } catch(err) {\n        }\n        var credentialData;\n        if (settings.flowFilePretty) {\n            credentialData = JSON.stringify(credentials,null,4);\n        } else {\n            credentialData = JSON.stringify(credentials);\n        }\n        return writeFile(credentialsFile, credentialData);\n    },\n\n    getSettings: function() {\n        return when.promise(function(resolve,reject) {\n            fs.readFile(globalSettingsFile,'utf8',function(err,data) {\n                if (!err) {\n                    try {\n                        return resolve(JSON.parse(data));\n                    } catch(err2) {\n                        log.trace(\"Corrupted config detected - resetting\");\n                    }\n                }\n                return resolve({});\n            })\n        })\n    },\n    saveSettings: function(newSettings) {\n        if (settings.readOnly) {\n            return when.resolve();\n        }\n        return writeFile(globalSettingsFile,JSON.stringify(newSettings,null,1));\n    },\n    getSessions: function() {\n        return when.promise(function(resolve,reject) {\n            fs.readFile(sessionsFile,'utf8',function(err,data){\n                if (!err) {\n                    try {\n                        return resolve(JSON.parse(data));\n                    } catch(err2) {\n                        log.trace(\"Corrupted sessions file - resetting\");\n                    }\n                }\n                resolve({});\n            })\n        });\n    },\n    saveSessions: function(sessions) {\n        if (settings.readOnly) {\n            return when.resolve();\n        }\n        return writeFile(sessionsFile,JSON.stringify(sessions));\n    },\n\n    getLibraryEntry: function(type,path) {\n        var root = fspath.join(libDir,type);\n        var rootPath = fspath.join(libDir,type,path);\n\n        // don't create the folder if it does not exist - we are only reading....\n        return nodeFn.call(fs.lstat, rootPath).then(function(stats) {\n            if (stats.isFile()) {\n                return getFileBody(root,path);\n            }\n            if (path.substr(-1) == '/') {\n                path = path.substr(0,path.length-1);\n            }\n            return nodeFn.call(fs.readdir, rootPath).then(function(fns) {\n                var dirs = [];\n                var files = [];\n                fns.sort().filter(function(fn) {\n                    var fullPath = fspath.join(path,fn);\n                    var absoluteFullPath = fspath.join(root,fullPath);\n                    if (fn[0] != \".\") {\n                        var stats = fs.lstatSync(absoluteFullPath);\n                        if (stats.isDirectory()) {\n                            dirs.push(fn);\n                        } else {\n                            var meta = getFileMeta(root,fullPath);\n                            meta.fn = fn;\n                            files.push(meta);\n                        }\n                    }\n                });\n                return dirs.concat(files);\n            });\n        }).otherwise(function(err) {\n            // if path is empty, then assume it was a folder, return empty\n            if (path === \"\"){\n                return [];\n            }\n\n            // if path ends with slash, it was a folder\n            // so return empty\n            if (path.substr(-1) == '/') {\n                return [];\n            }\n\n            // else path was specified, but did not exist,\n            // check for path.json as an alternative if flows\n            if (type === \"flows\" && !/\\.json$/.test(path)) {\n                return localfilesystem.getLibraryEntry(type,path+\".json\")\n                .otherwise(function(e) {\n                    throw err;\n                });\n            } else {\n                throw err;\n            }\n        });\n    },\n\n    saveLibraryEntry: function(type,path,meta,body) {\n        if (settings.readOnly) {\n            return when.resolve();\n        }\n        var fn = fspath.join(libDir, type, path);\n        var headers = \"\";\n        for (var i in meta) {\n            if (meta.hasOwnProperty(i)) {\n                headers += \"// \"+i+\": \"+meta[i]+\"\\n\";\n            }\n        }\n        if (type === \"flows\" && settings.flowFilePretty) {\n            body = JSON.stringify(JSON.parse(body),null,4);\n        }\n        return promiseDir(fspath.dirname(fn)).then(function () {\n            writeFile(fn,headers+body);\n        });\n    }\n};\n\nmodule.exports = localfilesystem;\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-email/61-email.js":"\n/**\n * POP3 protocol - RFC1939 - https://www.ietf.org/rfc/rfc1939.txt\n *\n * Dependencies:\n * * poplib     - https://www.npmjs.com/package/poplib\n * * nodemailer - https://www.npmjs.com/package/nodemailer\n * * imap       - https://www.npmjs.com/package/imap\n * * mailparser - https://www.npmjs.com/package/mailparser\n */\n\nmodule.exports = function(RED) {\n    \"use strict\";\n    var nodemailer = require(\"nodemailer\");\n    var Imap = require('imap');\n    var POP3Client = require(\"poplib\");\n    var MailParser = require(\"mailparser\").MailParser;\n    var util = require(\"util\");\n\n    try {\n        var globalkeys = RED.settings.email || require(process.env.NODE_RED_HOME+\"/../emailkeys.js\");\n    }\n    catch(err) {\n    }\n\n    function EmailNode(n) {\n        RED.nodes.createNode(this,n);\n        this.topic = n.topic;\n        this.name = n.name;\n        this.outserver = n.server;\n        this.outport = n.port;\n        this.secure = n.secure;\n        var flag = false;\n        if (this.credentials && this.credentials.hasOwnProperty(\"userid\")) {\n            this.userid = this.credentials.userid;\n        } else {\n            if (globalkeys) {\n                this.userid = globalkeys.user;\n                flag = true;\n            }\n        }\n        if (this.credentials && this.credentials.hasOwnProperty(\"password\")) {\n            this.password = this.credentials.password;\n        } else {\n            if (globalkeys) {\n                this.password = globalkeys.pass;\n                flag = true;\n            }\n        }\n        if (flag) {\n            RED.nodes.addCredentials(n.id,{userid:this.userid, password:this.password, global:true});\n        }\n        var node = this;\n\n        var smtpOptions = {\n            host: node.outserver,\n            port: node.outport,\n            secure: node.secure\n        }\n\n        if (this.userid && this.password) {\n            smtpOptions.auth = {\n                user: node.userid,\n                pass: node.password\n            };\n        }\n        var smtpTransport = nodemailer.createTransport(smtpOptions);\n\n        this.on(\"input\", function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                if (smtpTransport) {\n                    node.status({fill:\"blue\",shape:\"dot\",text:\"email.status.sending\"});\n                    if (msg.to && node.name && (msg.to !== node.name)) {\n                        node.warn(RED._(\"node-red:common.errors.nooverride\"));\n                    }\n                    var sendopts = { from: ((msg.from) ? msg.from : node.userid) };   // sender address\n                    sendopts.to = node.name || msg.to; // comma separated list of addressees\n                    if (node.name === \"\") {\n                        sendopts.cc = msg.cc;\n                        sendopts.bcc = msg.bcc;\n                    }\n                    sendopts.subject = msg.topic || msg.title || \"Message from Node-RED\"; // subject line\n                    if (msg.hasOwnProperty(\"envelope\")) { sendopts.envelope = msg.envelope; }\n                    if (Buffer.isBuffer(msg.payload)) { // if it's a buffer in the payload then auto create an attachment instead\n                        if (!msg.filename) {\n                            var fe = \"bin\";\n                            if ((msg.payload[0] === 0xFF)&&(msg.payload[1] === 0xD8)) { fe = \"jpg\"; }\n                            if ((msg.payload[0] === 0x47)&&(msg.payload[1] === 0x49)) { fe = \"gif\"; } //46\n                            if ((msg.payload[0] === 0x42)&&(msg.payload[1] === 0x4D)) { fe = \"bmp\"; }\n                            if ((msg.payload[0] === 0x89)&&(msg.payload[1] === 0x50)) { fe = \"png\"; } //4E\n                            msg.filename = \"attachment.\"+fe;\n                        }\n                        var fname = msg.filename.replace(/^.*[\\\\\\/]/, '') || \"file.bin\";\n                        sendopts.attachments = [ { content:msg.payload, filename:fname } ];\n                        if (msg.hasOwnProperty(\"headers\") && msg.headers.hasOwnProperty(\"content-type\")) {\n                            sendopts.attachments[0].contentType = msg.headers[\"content-type\"];\n                        }\n                        // Create some body text..\n                        sendopts.text = RED._(\"email.default-message\",{filename:fname, description:(msg.description||\"\")});\n                    }\n                    else {\n                        var payload = RED.util.ensureString(msg.payload);\n                        sendopts.text = payload; // plaintext body\n                        if (/<[a-z][\\s\\S]*>/i.test(payload)) { sendopts.html = payload; } // html body\n                        if (msg.attachments) { sendopts.attachments = msg.attachments; } // add attachments\n                    }\n                    smtpTransport.sendMail(sendopts, function(error, info) {\n                        if (error) {\n                            node.error(error,msg);\n                            node.status({fill:\"red\",shape:\"ring\",text:\"email.status.sendfail\"});\n                        } else {\n                            node.log(RED._(\"email.status.messagesent\",{response:info.response}));\n                            node.status({});\n                        }\n                    });\n                }\n                else { node.warn(RED._(\"email.errors.nosmtptransport\")); }\n            }\n            else { node.warn(RED._(\"email.errors.nopayload\")); }\n        });\n    }\n    RED.nodes.registerType(\"e-mail\",EmailNode,{\n        credentials: {\n            userid: {type:\"text\"},\n            password: {type: \"password\"},\n            global: { type:\"boolean\"}\n        }\n    });\n\n\n    //\n    // EmailInNode\n    //\n    // Setup the EmailInNode\n    function EmailInNode(n) {\n        var imap;\n\n        RED.nodes.createNode(this,n);\n        this.name = n.name;\n        this.repeat = n.repeat * 1000 || 300000;\n        this.inserver = n.server || (globalkeys && globalkeys.server) || \"imap.gmail.com\";\n        this.inport = n.port || (globalkeys && globalkeys.port) || \"993\";\n        this.box = n.box || \"INBOX\";\n        this.useSSL= n.useSSL;\n        this.protocol = n.protocol || \"IMAP\";\n        this.disposition = n.disposition || \"None\"; // \"None\", \"Delete\", \"Read\"\n\n        var flag = false;\n\n        if (this.credentials && this.credentials.hasOwnProperty(\"userid\")) {\n            this.userid = this.credentials.userid;\n        } else {\n            if (globalkeys) {\n                this.userid = globalkeys.user;\n                flag = true;\n            } else {\n                this.error(RED._(\"email.errors.nouserid\"));\n            }\n        }\n        if (this.credentials && this.credentials.hasOwnProperty(\"password\")) {\n            this.password = this.credentials.password;\n        } else {\n            if (globalkeys) {\n                this.password = globalkeys.pass;\n                flag = true;\n            } else {\n                this.error(RED._(\"email.errors.nopassword\"));\n            }\n        }\n        if (flag) {\n            RED.nodes.addCredentials(n.id,{userid:this.userid, password:this.password, global:true});\n        }\n\n        var node = this;\n        this.interval_id = null;\n\n        // Process a new email message by building a Node-RED message to be passed onwards\n        // in the message flow.  The parameter called `msg` is the template message we\n        // start with while `mailMessage` is an object returned from `mailparser` that\n        // will be used to populate the email.\n        // DCJ NOTE: - heirachical multipart mime parsers seem to not exist - this one is barely functional.\n        function processNewMessage(msg, mailMessage) {\n            msg = JSON.parse(JSON.stringify(msg)); // Clone the message\n            // Populate the msg fields from the content of the email message\n            // that we have just parsed.\n            msg.payload = mailMessage.text;\n            msg.topic = mailMessage.subject;\n            msg.date = mailMessage.date;\n            msg.header = mailMessage.headers;\n            if (mailMessage.html) { msg.html = mailMessage.html; }\n            if (mailMessage.to && mailMessage.from.to > 0) { msg.to = mailMessage.to; }\n            if (mailMessage.cc && mailMessage.from.cc > 0) { msg.cc = mailMessage.cc; }\n            if (mailMessage.bcc && mailMessage.from.bcc > 0) { msg.bcc = mailMessage.bcc; }\n            if (mailMessage.from && mailMessage.from.length > 0) { msg.from = mailMessage.from[0].address; }\n            if (mailMessage.attachments) { msg.attachments = mailMessage.attachments; }\n            else { msg.attachments = []; }\n            node.send(msg); // Propagate the message down the flow\n        } // End of processNewMessage\n\n        // Check the POP3 email mailbox for any new messages.  For any that are found,\n        // retrieve each message, call processNewMessage to process it and then delete\n        // the messages from the server.\n        function checkPOP3(msg) {\n            var currentMessage;\n            var maxMessage;\n\n            // Form a new connection to our email server using POP3.\n            var pop3Client = new POP3Client(\n                node.inport, node.inserver,\n                {enabletls: node.useSSL} // Should we use SSL to connect to our email server?\n            );\n\n            // If we have a next message to retrieve, ask to retrieve it otherwise issue a\n            // quit request.\n            function nextMessage() {\n                if (currentMessage > maxMessage) {\n                    pop3Client.quit();\n                    return;\n                }\n                pop3Client.retr(currentMessage);\n                currentMessage++;\n            } // End of nextMessage\n\n            pop3Client.on(\"stat\", function(status, data) {\n                // Data contains:\n                // {\n                //   count: <Number of messages to be read>\n                //   octect: <size of messages to be read>\n                // }\n                if (status) {\n                    currentMessage = 1;\n                    maxMessage = data.count;\n                    nextMessage();\n                } else {\n                    node.log(util.format(\"stat error: %s %j\", status, data));\n                }\n            });\n\n            pop3Client.on(\"error\", function(err) {\n                node.log(\"We caught an error: \" + JSON.stringify(err));\n            });\n\n            pop3Client.on(\"connect\", function() {\n                //node.log(\"We are now connected\");\n                pop3Client.login(node.userid, node.password);\n            });\n\n            pop3Client.on(\"login\", function(status, rawData) {\n                //node.log(\"login: \" + status + \", \" + rawData);\n                if (status) {\n                    pop3Client.stat();\n                } else {\n                    node.log(util.format(\"login error: %s %j\", status, rawData));\n                    pop3Client.quit();\n                }\n            });\n\n            pop3Client.on(\"retr\", function(status, msgNumber, data, rawData) {\n                // node.log(util.format(\"retr: status=%s, msgNumber=%d, data=%j\", status, msgNumber, data));\n                if (status) {\n\n                    // We have now received a new email message.  Create an instance of a mail parser\n                    // and pass in the email message.  The parser will signal when it has parsed the message.\n                    var mailparser = new MailParser();\n                    mailparser.on(\"end\", function(mailObject) {\n                        //node.log(util.format(\"mailparser: on(end): %j\", mailObject));\n                        processNewMessage(msg, mailObject);\n                    });\n                    mailparser.write(data);\n                    mailparser.end();\n                    pop3Client.dele(msgNumber);\n                }\n                else {\n                    node.log(util.format(\"retr error: %s %j\", status, rawData));\n                    pop3Client.quit();\n                }\n            });\n\n            pop3Client.on(\"invalid-state\", function(cmd) {\n                node.log(\"Invalid state: \" + cmd);\n            });\n\n            pop3Client.on(\"locked\", function(cmd) {\n                node.log(\"We were locked: \" + cmd);\n            });\n\n            // When we have deleted the last processed message, we can move on to\n            // processing the next message.\n            pop3Client.on(\"dele\", function(status, msgNumber) {\n                nextMessage();\n            });\n        } // End of checkPOP3\n\n\n        //\n        // checkIMAP\n        //\n        // Check the email sever using the IMAP protocol for new messages.\n        function checkIMAP(msg) {\n            node.log(\"Checking IMAP for new messages\");\n            // We get back a 'ready' event once we have connected to imap\n            imap.once(\"ready\", function() {\n                node.status({fill:\"blue\", shape:\"dot\", text:\"email.status.fetching\"});\n                //console.log(\"> ready\");\n                // Open the inbox folder\n                imap.openBox(node.box, // Mailbox name\n                    false, // Open readonly?\n                    function(err, box) {\n                    //console.log(\"> Inbox open: %j\", box);\n                    imap.search([ 'UNSEEN' ], function(err, results) {\n                        if (err) {\n                            node.status({fill:\"red\", shape:\"ring\", text:\"email.status.foldererror\"});\n                            node.error(RED._(\"email.errors.fetchfail\", {folder:node.box}),err);\n                            imap.end();\n                            return;\n                        }\n                        //console.log(\"> search - err=%j, results=%j\", err, results);\n                        if (results.length === 0) {\n                            //console.log(\" [X] - Nothing to fetch\");\n                            node.status({});\n                            imap.end();\n                            return;\n                        }\n\n                        var marks = false;\n                        if (node.disposition === \"Read\") { marks = true; }\n                        // We have the search results that contain the list of unseen messages and can now fetch those messages.\n                        var fetch = imap.fetch(results, {\n                            bodies: '',\n                            struct: true,\n                            markSeen: marks\n                        });\n\n                        // For each fetched message returned ...\n                        fetch.on('message', function(imapMessage, seqno) {\n                            //node.log(RED._(\"email.status.message\",{number:seqno}));\n                            var messageText = \"\";\n                            //console.log(\"> Fetch message - msg=%j, seqno=%d\", imapMessage, seqno);\n                            imapMessage.on('body', function(stream, info) {\n                                //console.log(\"> message - body - stream=?, info=%j\", info);\n                                stream.on('data', function(chunk) {\n                                    //console.log(\"> stream - data - chunk=??\");\n                                    messageText += chunk.toString('utf8');\n                                });\n                                stream.once('end', function() {\n                                    var mailParser = new MailParser();\n                                    mailParser.on('end', function(mailMessage) {\n                                        processNewMessage(msg, mailMessage);\n                                    });\n                                    mailParser.write(messageText);\n                                    mailParser.end();\n                                }); // End of msg->end\n                            }); // End of msg->body\n                        }); // End of fetch->message\n\n                        // When we have fetched all the messages, we don't need the imap connection any more.\n                        fetch.on('end', function() {\n                            node.status({});\n                            var cleanup = function() {\n                                imap.end();\n                            };\n                            if (this.disposition === \"Delete\") {\n                                imap.addFlags(results, \"\\Deleted\", cleanup);\n                            } else if (this.disposition === \"Read\") {\n                                imap.addFlags(results, \"\\Seen\", cleanup);\n                            } else {\n                                cleanup();\n                            }\n                        });\n\n                        fetch.once('error', function(err) {\n                            console.log('Fetch error: ' + err);\n                        });\n                    }); // End of imap->search\n                }); // End of imap->openInbox\n            }); // End of imap->ready\n            node.status({fill:\"grey\",shape:\"dot\",text:\"node-red:common.status.connecting\"});\n            imap.connect();\n        } // End of checkIMAP\n\n\n        // Perform a check of the email inboxes using either POP3 or IMAP\n        function checkEmail(msg) {\n            if (node.protocol === \"POP3\") {\n                checkPOP3(msg);\n            } else if (node.protocol === \"IMAP\") {\n                checkIMAP(msg);\n            }\n        }  // End of checkEmail\n\n        if (node.protocol === \"IMAP\") {\n            imap = new Imap({\n                user: node.userid,\n                password: node.password,\n                host: node.inserver,\n                port: node.inport,\n                tls: node.useSSL,\n                tlsOptions: { rejectUnauthorized: false },\n                connTimeout: node.repeat,\n                authTimeout: node.repeat\n            });\n            imap.on('error', function(err) {\n                if (err.errno !== \"ECONNRESET\") {\n                    node.log(err);\n                    node.status({fill:\"red\",shape:\"ring\",text:\"email.status.connecterror\"});\n                }\n            });\n        }\n\n        this.on(\"input\", function(msg) {\n            checkEmail(msg);\n        });\n\n        this.on(\"close\", function() {\n            if (this.interval_id != null) {\n                clearInterval(this.interval_id);\n            }\n            if (imap) { imap.destroy(); }\n        });\n\n        // Set the repetition timer as needed\n        if (!isNaN(this.repeat) && this.repeat > 0) {\n            this.interval_id = setInterval( function() {\n                node.emit(\"input\",{});\n            }, this.repeat );\n        }\n\n        node.emit(\"input\",{});\n    }\n\n    RED.nodes.registerType(\"e-mail in\",EmailInNode,{\n        credentials: {\n            userid: { type:\"text\" },\n            password: { type: \"password\" },\n            global: { type:\"boolean\" }\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/32-feedparse.js":"\nmodule.exports = function(RED) {\n    \"use strict\";\n    var FeedParser = require(\"feedparser\");\n    var request = require(\"request\");\n    var url = require('url');\n\n    function FeedParseNode(n) {\n        RED.nodes.createNode(this,n);\n        this.url = n.url;\n        this.interval = (parseInt(n.interval)||15) * 60000;\n        var node = this;\n        this.interval_id = null;\n        this.seen = {};\n        var parsedUrl = url.parse(this.url);\n        if (!(parsedUrl.host || (parsedUrl.hostname && parsedUrl.port)) && !parsedUrl.isUnix) {\n            this.error(RED._(\"feedparse.errors.invalidurl\"));\n        } else {\n            var getFeed = function() {\n                var req = request(node.url, {timeout: 10000, pool: false});\n                //req.setMaxListeners(50);\n                //req.setHeader('user-agent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36');\n                //req.setHeader('accept', 'text/html,application/xhtml+xml');\n\n                var feedparser = new FeedParser();\n\n                req.on('error', function(err) { node.error(err); });\n\n                req.on('response', function(res) {\n                    if (res.statusCode != 200) { node.warn(RED._(\"feedparse.errors.badstatuscode\")+\" \"+res.statusCode); }\n                    else { res.pipe(feedparser); }\n                });\n\n                feedparser.on('error', function(error) { node.error(error); });\n\n                feedparser.on('readable', function () {\n                    var stream = this, article;\n                    while (article = stream.read()) {  // jshint ignore:line\n                        if (!(article.guid in node.seen) || ( node.seen[article.guid] !== 0 && node.seen[article.guid] != article.date.getTime())) {\n                            node.seen[article.guid] = article.date?article.date.getTime():0;\n                            var msg = {\n                                topic: article.origlink || article.link,\n                                payload: article.description,\n                                article: article\n                            };\n                            node.send(msg);\n                        }\n                    }\n                });\n\n                feedparser.on('meta', function (meta) {});\n                feedparser.on('end', function () {});\n            };\n            this.interval_id = setInterval(function() { getFeed(); }, node.interval);\n            getFeed();\n        }\n\n        this.on(\"close\", function() {\n            if (this.interval_id != null) {\n                clearInterval(this.interval_id);\n            }\n        });\n    }\n\n    RED.nodes.registerType(\"feedparse\",FeedParseNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/index.js":"// Copyright 2010-2012 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\n'use strict'\n\nvar extend                = require('extend')\n  , cookies               = require('./lib/cookies')\n  , helpers               = require('./lib/helpers')\n\nvar isFunction            = helpers.isFunction\n  , paramsHaveRequestBody = helpers.paramsHaveRequestBody\n\n\n// organize params for patch, post, put, head, del\nfunction initParams(uri, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n  }\n\n  var params = {}\n  if (typeof options === 'object') {\n    extend(params, options, {uri: uri})\n  } else if (typeof uri === 'string') {\n    extend(params, {uri: uri})\n  } else {\n    extend(params, uri)\n  }\n\n  params.callback = callback || params.callback\n  return params\n}\n\nfunction request (uri, options, callback) {\n  if (typeof uri === 'undefined') {\n    throw new Error('undefined is not a valid uri or options object.')\n  }\n\n  var params = initParams(uri, options, callback)\n\n  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {\n    throw new Error('HTTP HEAD requests MUST NOT include a request body.')\n  }\n\n  return new request.Request(params)\n}\n\nfunction verbFunc (verb) {\n  var method = verb.toUpperCase()\n  return function (uri, options, callback) {\n    var params = initParams(uri, options, callback)\n    params.method = method\n    return request(params, params.callback)\n  }\n}\n\n// define like this to please codeintel/intellisense IDEs\nrequest.get = verbFunc('get')\nrequest.head = verbFunc('head')\nrequest.post = verbFunc('post')\nrequest.put = verbFunc('put')\nrequest.patch = verbFunc('patch')\nrequest.del = verbFunc('delete')\nrequest['delete'] = verbFunc('delete')\n\nrequest.jar = function (store) {\n  return cookies.jar(store)\n}\n\nrequest.cookie = function (str) {\n  return cookies.parse(str)\n}\n\nfunction wrapRequestMethod (method, options, requester, verb) {\n\n  return function (uri, opts, callback) {\n    var params = initParams(uri, opts, callback)\n\n    var target = {}\n    extend(true, target, options, params)\n\n    target.pool = params.pool || options.pool\n\n    if (verb) {\n      target.method = verb.toUpperCase()\n    }\n\n    if (isFunction(requester)) {\n      method = requester\n    }\n\n    return method(target, target.callback)\n  }\n}\n\nrequest.defaults = function (options, requester) {\n  var self = this\n\n  options = options || {}\n\n  if (typeof options === 'function') {\n    requester = options\n    options = {}\n  }\n\n  var defaults      = wrapRequestMethod(self, options, requester)\n\n  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete']\n  verbs.forEach(function(verb) {\n    defaults[verb]  = wrapRequestMethod(self[verb], options, requester, verb)\n  })\n\n  defaults.cookie   = wrapRequestMethod(self.cookie, options, requester)\n  defaults.jar      = self.jar\n  defaults.defaults = self.defaults\n  return defaults\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (optionsArg) {\n    extend(options, optionsArg)\n  }\n  if (agentOptions) {\n    options.agentOptions = agentOptions\n  }\n\n  options.forever = true\n  return request.defaults(options)\n}\n\n// Exports\n\nmodule.exports = request\nrequest.Request = require('./request')\nrequest.initParams = initParams\n\n// Backwards compatibility for request.debug\nObject.defineProperty(request, 'debug', {\n  enumerable : true,\n  get : function() {\n    return request.Request.debug\n  },\n  set : function(debug) {\n    request.Request.debug = debug\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/cookies.js":"'use strict'\n\nvar tough = require('tough-cookie')\n\nvar Cookie = tough.Cookie\n  , CookieJar = tough.CookieJar\n\n\nexports.parse = function(str) {\n  if (str && str.uri) {\n    str = str.uri\n  }\n  if (typeof str !== 'string') {\n    throw new Error('The cookie function only accepts STRING as param')\n  }\n  return Cookie.parse(str, {loose: true})\n}\n\n// Adapt the sometimes-Async api of tough.CookieJar to our requirements\nfunction RequestJar(store) {\n  var self = this\n  self._jar = new CookieJar(store, {looseMode: true})\n}\nRequestJar.prototype.setCookie = function(cookieOrStr, uri, options) {\n  var self = this\n  return self._jar.setCookieSync(cookieOrStr, uri, options || {})\n}\nRequestJar.prototype.getCookieString = function(uri) {\n  var self = this\n  return self._jar.getCookieStringSync(uri)\n}\nRequestJar.prototype.getCookies = function(uri) {\n  var self = this\n  return self._jar.getCookiesSync(uri)\n}\n\nexports.jar = function(store) {\n  return new RequestJar(store)\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/helpers.js":"'use strict'\n\nvar jsonSafeStringify = require('json-stringify-safe')\n  , crypto = require('crypto')\n\nfunction deferMethod() {\n  if (typeof setImmediate === 'undefined') {\n    return process.nextTick\n  }\n\n  return setImmediate\n}\n\nfunction isFunction(value) {\n  return typeof value === 'function'\n}\n\nfunction paramsHaveRequestBody(params) {\n  return (\n    params.body ||\n    params.requestBodyStream ||\n    (params.json && typeof params.json !== 'boolean') ||\n    params.multipart\n  )\n}\n\nfunction safeStringify (obj, replacer) {\n  var ret\n  try {\n    ret = JSON.stringify(obj, replacer)\n  } catch (e) {\n    ret = jsonSafeStringify(obj, replacer)\n  }\n  return ret\n}\n\nfunction md5 (str) {\n  return crypto.createHash('md5').update(str).digest('hex')\n}\n\nfunction isReadStream (rs) {\n  return rs.readable && rs.path && rs.mode\n}\n\nfunction toBase64 (str) {\n  return (new Buffer(str || '', 'utf8')).toString('base64')\n}\n\nfunction copy (obj) {\n  var o = {}\n  Object.keys(obj).forEach(function (i) {\n    o[i] = obj[i]\n  })\n  return o\n}\n\nfunction version () {\n  var numbers = process.version.replace('v', '').split('.')\n  return {\n    major: parseInt(numbers[0], 10),\n    minor: parseInt(numbers[1], 10),\n    patch: parseInt(numbers[2], 10)\n  }\n}\n\nexports.isFunction            = isFunction\nexports.paramsHaveRequestBody = paramsHaveRequestBody\nexports.safeStringify         = safeStringify\nexports.md5                   = md5\nexports.isReadStream          = isReadStream\nexports.toBase64              = toBase64\nexports.copy                  = copy\nexports.version               = version\nexports.defer                 = deferMethod()\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/request.js":"'use strict'\n\nvar http = require('http')\n  , https = require('https')\n  , url = require('url')\n  , util = require('util')\n  , stream = require('stream')\n  , zlib = require('zlib')\n  , bl = require('bl')\n  , hawk = require('hawk')\n  , aws2 = require('aws-sign2')\n  , aws4 = require('aws4')\n  , httpSignature = require('http-signature')\n  , mime = require('mime-types')\n  , stringstream = require('stringstream')\n  , caseless = require('caseless')\n  , ForeverAgent = require('forever-agent')\n  , FormData = require('form-data')\n  , extend = require('extend')\n  , isstream = require('isstream')\n  , isTypedArray = require('is-typedarray').strict\n  , helpers = require('./lib/helpers')\n  , cookies = require('./lib/cookies')\n  , getProxyFromURI = require('./lib/getProxyFromURI')\n  , Querystring = require('./lib/querystring').Querystring\n  , Har = require('./lib/har').Har\n  , Auth = require('./lib/auth').Auth\n  , OAuth = require('./lib/oauth').OAuth\n  , Multipart = require('./lib/multipart').Multipart\n  , Redirect = require('./lib/redirect').Redirect\n  , Tunnel = require('./lib/tunnel').Tunnel\n\nvar safeStringify = helpers.safeStringify\n  , isReadStream = helpers.isReadStream\n  , toBase64 = helpers.toBase64\n  , defer = helpers.defer\n  , copy = helpers.copy\n  , version = helpers.version\n  , globalCookieJar = cookies.jar()\n\n\nvar globalPool = {}\n\nfunction filterForNonReserved(reserved, options) {\n  // Filter out properties that are not reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var notReserved = (reserved.indexOf(i) === -1)\n    if (notReserved) {\n      object[i] = options[i]\n    }\n  }\n  return object\n}\n\nfunction filterOutReservedFunctions(reserved, options) {\n  // Filter out properties that are functions and are reserved.\n  // Reserved values are passed in at call site.\n\n  var object = {}\n  for (var i in options) {\n    var isReserved = !(reserved.indexOf(i) === -1)\n    var isFunction = (typeof options[i] === 'function')\n    if (!(isReserved && isFunction)) {\n      object[i] = options[i]\n    }\n  }\n  return object\n\n}\n\n// Return a simpler request object to allow serialization\nfunction requestToJSON() {\n  var self = this\n  return {\n    uri: self.uri,\n    method: self.method,\n    headers: self.headers\n  }\n}\n\n// Return a simpler response object to allow serialization\nfunction responseToJSON() {\n  var self = this\n  return {\n    statusCode: self.statusCode,\n    body: self.body,\n    headers: self.headers,\n    request: requestToJSON.call(self.request)\n  }\n}\n\nfunction Request (options) {\n  // if given the method property in options, set property explicitMethod to true\n\n  // extend the Request instance with any non-reserved properties\n  // remove any reserved functions from the options object\n  // set Request instance to be readable and writable\n  // call init\n\n  var self = this\n\n  // start with HAR, then override with additional options\n  if (options.har) {\n    self._har = new Har(self)\n    options = self._har.options(options)\n  }\n\n  stream.Stream.call(self)\n  var reserved = Object.keys(Request.prototype)\n  var nonReserved = filterForNonReserved(reserved, options)\n\n  extend(self, nonReserved)\n  options = filterOutReservedFunctions(reserved, options)\n\n  self.readable = true\n  self.writable = true\n  if (options.method) {\n    self.explicitMethod = true\n  }\n  self._qs = new Querystring(self)\n  self._auth = new Auth(self)\n  self._oauth = new OAuth(self)\n  self._multipart = new Multipart(self)\n  self._redirect = new Redirect(self)\n  self._tunnel = new Tunnel(self)\n  self.init(options)\n}\n\nutil.inherits(Request, stream.Stream)\n\n// Debugging\nRequest.debug = process.env.NODE_DEBUG && /\\brequest\\b/.test(process.env.NODE_DEBUG)\nfunction debug() {\n  if (Request.debug) {\n    console.error('REQUEST %s', util.format.apply(util, arguments))\n  }\n}\nRequest.prototype.debug = debug\n\nRequest.prototype.init = function (options) {\n  // init() contains all the code to setup the request object.\n  // the actual outgoing request is not started until start() is called\n  // this function is called from both the constructor and on redirect.\n  var self = this\n  if (!options) {\n    options = {}\n  }\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  // Delete headers with value undefined since they break\n  // ClientRequest.OutgoingMessage.setHeader in node 0.12\n  for (var headerName in self.headers) {\n    if (typeof self.headers[headerName] === 'undefined') {\n      delete self.headers[headerName]\n    }\n  }\n\n  caseless.httpify(self, self.headers)\n\n  if (!self.method) {\n    self.method = options.method || 'GET'\n  }\n  if (!self.localAddress) {\n    self.localAddress = options.localAddress\n  }\n\n  self._qs.init(options)\n\n  debug(options)\n  if (!self.pool && self.pool !== false) {\n    self.pool = globalPool\n  }\n  self.dests = self.dests || []\n  self.__isRequestRequest = true\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) {\n        return // Print a warning maybe?\n      }\n      self._callbackCalled = true\n      self._callback.apply(self, arguments)\n    }\n    self.on('error', self.callback.bind())\n    self.on('complete', self.callback.bind(self, null))\n  }\n\n  // People use this property instead all the time, so support it\n  if (!self.uri && self.url) {\n    self.uri = self.url\n    delete self.url\n  }\n\n  // If there's a baseUrl, then use it as the base URL (i.e. uri must be\n  // specified as a relative path and is appended to baseUrl).\n  if (self.baseUrl) {\n    if (typeof self.baseUrl !== 'string') {\n      return self.emit('error', new Error('options.baseUrl must be a string'))\n    }\n\n    if (typeof self.uri !== 'string') {\n      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))\n    }\n\n    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {\n      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))\n    }\n\n    // Handle all cases to make sure that there's only one slash between\n    // baseUrl and uri.\n    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1\n    var uriStartsWithSlash = self.uri.indexOf('/') === 0\n\n    if (baseUrlEndsWithSlash && uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri.slice(1)\n    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {\n      self.uri = self.baseUrl + self.uri\n    } else if (self.uri === '') {\n      self.uri = self.baseUrl\n    } else {\n      self.uri = self.baseUrl + '/' + self.uri\n    }\n    delete self.baseUrl\n  }\n\n  // A URI is needed by this point, emit error if we haven't been able to get one\n  if (!self.uri) {\n    return self.emit('error', new Error('options.uri is a required argument'))\n  }\n\n  // If a string URI/URL was given, parse it into a URL object\n  if (typeof self.uri === 'string') {\n    self.uri = url.parse(self.uri)\n  }\n\n  // Some URL objects are not from a URL parsed string and need href added\n  if (!self.uri.href) {\n    self.uri.href = url.format(self.uri)\n  }\n\n  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme\n  if (self.uri.protocol === 'unix:') {\n    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))\n  }\n\n  // Support Unix Sockets\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  if (self.strictSSL === false) {\n    self.rejectUnauthorized = false\n  }\n\n  if (!self.uri.pathname) {self.uri.pathname = '/'}\n\n  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {\n    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar\n    // Detect and reject it as soon as possible\n    var faultyUri = url.format(self.uri)\n    var message = 'Invalid URI \"' + faultyUri + '\"'\n    if (Object.keys(options).length === 0) {\n      // No option ? This can be the sign of a redirect\n      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)\n      // they should be warned that it can be caused by a redirection (can save some hair)\n      message += '. This can be caused by a crappy redirection.'\n    }\n    // This error was fatal\n    self.abort()\n    return self.emit('error', new Error(message))\n  }\n\n  if (!self.hasOwnProperty('proxy')) {\n    self.proxy = getProxyFromURI(self.uri)\n  }\n\n  self.tunnel = self._tunnel.isEnabled()\n  if (self.proxy) {\n    self._tunnel.setup(options)\n  }\n\n  self._redirect.onRequest(options)\n\n  self.setHost = false\n  if (!self.hasHeader('host')) {\n    var hostHeaderName = self.originalHostHeaderName || 'host'\n    self.setHeader(hostHeaderName, self.uri.hostname)\n    if (self.uri.port) {\n      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&\n           !(self.uri.port === 443 && self.uri.protocol === 'https:') ) {\n        self.setHeader(hostHeaderName, self.getHeader('host') + (':' + self.uri.port) )\n      }\n    }\n    self.setHost = true\n  }\n\n  self.jar(self._jar || options.jar)\n\n  if (!self.uri.port) {\n    if (self.uri.protocol === 'http:') {self.uri.port = 80}\n    else if (self.uri.protocol === 'https:') {self.uri.port = 443}\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (options.form) {\n    self.form(options.form)\n  }\n\n  if (options.formData) {\n    var formData = options.formData\n    var requestForm = self.form()\n    var appendFormValue = function (key, value) {\n      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n        requestForm.append(key, value.value, value.options)\n      } else {\n        requestForm.append(key, value)\n      }\n    }\n    for (var formKey in formData) {\n      if (formData.hasOwnProperty(formKey)) {\n        var formValue = formData[formKey]\n        if (formValue instanceof Array) {\n          for (var j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j])\n          }\n        } else {\n          appendFormValue(formKey, formValue)\n        }\n      }\n    }\n  }\n\n  if (options.qs) {\n    self.qs(options.qs)\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || '')\n  }\n\n  if (self.path.length === 0) {\n    self.path = '/'\n  }\n\n  // Auth must happen last in case signing is dependent on other headers\n  if (options.aws) {\n    self.aws(options.aws)\n  }\n\n  if (options.hawk) {\n    self.hawk(options.hawk)\n  }\n\n  if (options.httpSignature) {\n    self.httpSignature(options.httpSignature)\n  }\n\n  if (options.auth) {\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {\n      options.auth.user = options.auth.username\n    }\n    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {\n      options.auth.pass = options.auth.password\n    }\n\n    self.auth(\n      options.auth.user,\n      options.auth.pass,\n      options.auth.sendImmediately,\n      options.auth.bearer\n    )\n  }\n\n  if (self.gzip && !self.hasHeader('accept-encoding')) {\n    self.setHeader('accept-encoding', 'gzip, deflate')\n  }\n\n  if (self.uri.auth && !self.hasHeader('authorization')) {\n    var uriAuthPieces = self.uri.auth.split(':').map(function(item) {return self._qs.unescape(item)})\n    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true)\n  }\n\n  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {\n    var proxyAuthPieces = self.proxy.auth.split(':').map(function(item) {return self._qs.unescape(item)})\n    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'))\n    self.setHeader('proxy-authorization', authHeader)\n  }\n\n  if (self.proxy && !self.tunnel) {\n    self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n  }\n\n  if (options.json) {\n    self.json(options.json)\n  }\n  if (options.multipart) {\n    self.multipart(options.multipart)\n  }\n\n  if (options.time) {\n    self.timing = true\n    self.elapsedTime = self.elapsedTime || 0\n  }\n\n  function setContentLength () {\n    if (isTypedArray(self.body)) {\n      self.body = new Buffer(self.body)\n    }\n\n    if (!self.hasHeader('content-length')) {\n      var length\n      if (typeof self.body === 'string') {\n        length = Buffer.byteLength(self.body)\n      }\n      else if (Array.isArray(self.body)) {\n        length = self.body.reduce(function (a, b) {return a + b.length}, 0)\n      }\n      else {\n        length = self.body.length\n      }\n\n      if (length) {\n        self.setHeader('content-length', length)\n      } else {\n        self.emit('error', new Error('Argument error, options.body.'))\n      }\n    }\n  }\n  if (self.body && !isstream(self.body)) {\n    setContentLength()\n  }\n\n  if (options.oauth) {\n    self.oauth(options.oauth)\n  } else if (self._oauth.params && self.hasHeader('authorization')) {\n    self.oauth(self._oauth.params)\n  }\n\n  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol\n    , defaultModules = {'http:':http, 'https:':https}\n    , httpModules = self.httpModules || {}\n\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) {\n    return self.emit('error', new Error('Invalid protocol: ' + protocol))\n  }\n\n  if (options.ca) {\n    self.ca = options.ca\n  }\n\n  if (!self.agent) {\n    if (options.agentOptions) {\n      self.agentOptions = options.agentOptions\n    }\n\n    if (options.agentClass) {\n      self.agentClass = options.agentClass\n    } else if (options.forever) {\n      var v = version()\n      // use ForeverAgent in node 0.10- only\n      if (v.major === 0 && v.minor <= 10) {\n        self.agentClass = protocol === 'http:' ? ForeverAgent : ForeverAgent.SSL\n      } else {\n        self.agentClass = self.httpModule.Agent\n        self.agentOptions = self.agentOptions || {}\n        self.agentOptions.keepAlive = true\n      }\n    } else {\n      self.agentClass = self.httpModule.Agent\n    }\n  }\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    self.agent = self.agent || self.getNewAgent()\n  }\n\n  self.on('pipe', function (src) {\n    if (self.ntick && self._started) {\n      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'))\n    }\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', mime.lookup(src.path))\n      }\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.hasHeader(i)) {\n            self.setHeader(i, src.headers[i])\n          }\n        }\n      }\n      if (self._json && !self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n      if (src.method && !self.explicitMethod) {\n        self.method = src.method\n      }\n    }\n\n    // self.on('pipe', function () {\n    //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')\n    // })\n  })\n\n  defer(function () {\n    if (self._aborted) {\n      return\n    }\n\n    var end = function () {\n      if (self._form) {\n        if (!self._auth.hasAuth) {\n          self._form.pipe(self)\n        }\n        else if (self._auth.hasAuth && self._auth.sentAuth) {\n          self._form.pipe(self)\n        }\n      }\n      if (self._multipart && self._multipart.chunked) {\n        self._multipart.body.pipe(self)\n      }\n      if (self.body) {\n        if (isstream(self.body)) {\n          self.body.pipe(self)\n        } else {\n          setContentLength()\n          if (Array.isArray(self.body)) {\n            self.body.forEach(function (part) {\n              self.write(part)\n            })\n          } else {\n            self.write(self.body)\n          }\n          self.end()\n        }\n      } else if (self.requestBodyStream) {\n        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.')\n        self.requestBodyStream.pipe(self)\n      } else if (!self.src) {\n        if (self._auth.hasAuth && !self._auth.sentAuth) {\n          self.end()\n          return\n        }\n        if (self.method !== 'GET' && typeof self.method !== 'undefined') {\n          self.setHeader('content-length', 0)\n        }\n        self.end()\n      }\n    }\n\n    if (self._form && !self.hasHeader('content-length')) {\n      // Before ending the request, we had to compute the length of the whole form, asyncly\n      self.setHeader(self._form.getHeaders(), true)\n      self._form.getLength(function (err, length) {\n        if (!err && !isNaN(length)) {\n          self.setHeader('content-length', length)\n        }\n        end()\n      })\n    } else {\n      end()\n    }\n\n    self.ntick = true\n  })\n\n}\n\nRequest.prototype.getNewAgent = function () {\n  var self = this\n  var Agent = self.agentClass\n  var options = {}\n  if (self.agentOptions) {\n    for (var i in self.agentOptions) {\n      options[i] = self.agentOptions[i]\n    }\n  }\n  if (self.ca) {\n    options.ca = self.ca\n  }\n  if (self.ciphers) {\n    options.ciphers = self.ciphers\n  }\n  if (self.secureProtocol) {\n    options.secureProtocol = self.secureProtocol\n  }\n  if (self.secureOptions) {\n    options.secureOptions = self.secureOptions\n  }\n  if (typeof self.rejectUnauthorized !== 'undefined') {\n    options.rejectUnauthorized = self.rejectUnauthorized\n  }\n\n  if (self.cert && self.key) {\n    options.key = self.key\n    options.cert = self.cert\n  }\n\n  if (self.pfx) {\n    options.pfx = self.pfx\n  }\n\n  if (self.passphrase) {\n    options.passphrase = self.passphrase\n  }\n\n  var poolKey = ''\n\n  // different types of agents are in different pools\n  if (Agent !== self.httpModule.Agent) {\n    poolKey += Agent.name\n  }\n\n  // ca option is only relevant if proxy or destination are https\n  var proxy = self.proxy\n  if (typeof proxy === 'string') {\n    proxy = url.parse(proxy)\n  }\n  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:'\n\n  if (isHttps) {\n    if (options.ca) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ca\n    }\n\n    if (typeof options.rejectUnauthorized !== 'undefined') {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.rejectUnauthorized\n    }\n\n    if (options.cert) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.cert.toString('ascii') + options.key.toString('ascii')\n    }\n\n    if (options.pfx) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.pfx.toString('ascii')\n    }\n\n    if (options.ciphers) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.ciphers\n    }\n\n    if (options.secureProtocol) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureProtocol\n    }\n\n    if (options.secureOptions) {\n      if (poolKey) {\n        poolKey += ':'\n      }\n      poolKey += options.secureOptions\n    }\n  }\n\n  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {\n    // not doing anything special.  Use the globalAgent\n    return self.httpModule.globalAgent\n  }\n\n  // we're using a stored agent.  Make sure it's protocol-specific\n  poolKey = self.uri.protocol + poolKey\n\n  // generate a new agent for this setting if none yet exists\n  if (!self.pool[poolKey]) {\n    self.pool[poolKey] = new Agent(options)\n    // properly set maxSockets on new agents\n    if (self.pool.maxSockets) {\n      self.pool[poolKey].maxSockets = self.pool.maxSockets\n    }\n  }\n\n  return self.pool[poolKey]\n}\n\nRequest.prototype.start = function () {\n  // start() is called once we are ready to send the outgoing HTTP request.\n  // this is usually called on the first write(), end() or on nextTick()\n  var self = this\n\n  if (self._aborted) {\n    return\n  }\n\n  self._started = true\n  self.method = self.method || 'GET'\n  self.href = self.uri.href\n\n  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {\n    self.setHeader('content-length', self.src.stat.size)\n  }\n  if (self._aws) {\n    self.aws(self._aws, true)\n  }\n\n  // We have a method named auth, which is completely different from the http.request\n  // auth option.  If we don't remove it, we're gonna have a bad time.\n  var reqOptions = copy(self)\n  delete reqOptions.auth\n\n  debug('make request', self.uri.href)\n\n  try {\n    self.req = self.httpModule.request(reqOptions)\n  } catch (err) {\n    self.emit('error', err)\n    return\n  }\n\n  if (self.timing) {\n    self.startTime = new Date().getTime()\n  }\n\n  if (self.timeout && !self.timeoutTimer) {\n    var timeout = self.timeout < 0 ? 0 : self.timeout\n    // Set a timeout in memory - this block will throw if the server takes more\n    // than `timeout` to write the HTTP status and headers (corresponding to\n    // the on('response') event on the client). NB: this measures wall-clock\n    // time, not the time between bytes sent by the server.\n    self.timeoutTimer = setTimeout(function () {\n      var connectTimeout = self.req.socket && self.req.socket.readable === false\n      self.abort()\n      var e = new Error('ETIMEDOUT')\n      e.code = 'ETIMEDOUT'\n      e.connect = connectTimeout\n      self.emit('error', e)\n    }, timeout)\n\n    if (self.req.setTimeout) { // only works on node 0.6+\n      // Set an additional timeout on the socket, via the `setsockopt` syscall.\n      // This timeout sets the amount of time to wait *between* bytes sent\n      // from the server, and may or may not correspond to the wall-clock time\n      // elapsed from the start of the request.\n      //\n      // In particular, it's useful for erroring if the server fails to send\n      // data halfway through streaming a response.\n      self.req.setTimeout(timeout, function () {\n        if (self.req) {\n          self.req.abort()\n          var e = new Error('ESOCKETTIMEDOUT')\n          e.code = 'ESOCKETTIMEDOUT'\n          e.connect = false\n          self.emit('error', e)\n        }\n      })\n    }\n  }\n\n  self.req.on('response', self.onRequestResponse.bind(self))\n  self.req.on('error', self.onRequestError.bind(self))\n  self.req.on('drain', function() {\n    self.emit('drain')\n  })\n  self.req.on('socket', function(socket) {\n    self.emit('socket', socket)\n  })\n\n  self.emit('request', self.req)\n}\n\nRequest.prototype.onRequestError = function (error) {\n  var self = this\n  if (self._aborted) {\n    return\n  }\n  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET'\n      && self.agent.addRequestNoreuse) {\n    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) }\n    self.start()\n    self.req.end()\n    return\n  }\n  if (self.timeout && self.timeoutTimer) {\n    clearTimeout(self.timeoutTimer)\n    self.timeoutTimer = null\n  }\n  self.emit('error', error)\n}\n\nRequest.prototype.onRequestResponse = function (response) {\n  var self = this\n  debug('onRequestResponse', self.uri.href, response.statusCode, response.headers)\n  response.on('end', function() {\n    if (self.timing) {\n      self.elapsedTime += (new Date().getTime() - self.startTime)\n      debug('elapsed time', self.elapsedTime)\n      response.elapsedTime = self.elapsedTime\n    }\n    debug('response end', self.uri.href, response.statusCode, response.headers)\n  })\n\n  if (self._aborted) {\n    debug('aborted', self.uri.href)\n    response.resume()\n    return\n  }\n\n  self.response = response\n  response.request = self\n  response.toJSON = responseToJSON\n\n  // XXX This is different on 0.10, because SSL is strict by default\n  if (self.httpModule === https &&\n      self.strictSSL && (!response.hasOwnProperty('socket') ||\n      !response.socket.authorized)) {\n    debug('strict ssl error', self.uri.href)\n    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL'\n    self.emit('error', new Error('SSL Error: ' + sslErr))\n    return\n  }\n\n  // Save the original host before any redirect (if it changes, we need to\n  // remove any authorization headers).  Also remember the case of the header\n  // name because lots of broken servers expect Host instead of host and we\n  // want the caller to be able to specify this.\n  self.originalHost = self.getHeader('host')\n  if (!self.originalHostHeaderName) {\n    self.originalHostHeaderName = self.hasHeader('host')\n  }\n  if (self.setHost) {\n    self.removeHeader('host')\n  }\n  if (self.timeout && self.timeoutTimer) {\n    clearTimeout(self.timeoutTimer)\n    self.timeoutTimer = null\n  }\n\n  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar\n  var addCookie = function (cookie) {\n    //set the cookie if it's domain in the href's domain.\n    try {\n      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true})\n    } catch (e) {\n      self.emit('error', e)\n    }\n  }\n\n  response.caseless = caseless(response.headers)\n\n  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {\n    var headerName = response.caseless.has('set-cookie')\n    if (Array.isArray(response.headers[headerName])) {\n      response.headers[headerName].forEach(addCookie)\n    } else {\n      addCookie(response.headers[headerName])\n    }\n  }\n\n  if (self._redirect.onResponse(response)) {\n    return // Ignore the rest of the response\n  } else {\n    // Be a good stream and emit end when the response is finished.\n    // Hack to emit end on close because of a core bug that never fires end\n    response.on('close', function () {\n      if (!self._ended) {\n        self.response.emit('end')\n      }\n    })\n\n    response.on('end', function () {\n      self._ended = true\n    })\n\n    var noBody = function (code) {\n      return (\n        self.method === 'HEAD'\n        // Informational\n        || (code >= 100 && code < 200)\n        // No Content\n        || code === 204\n        // Not Modified\n        || code === 304\n      )\n    }\n\n    var responseContent\n    if (self.gzip && !noBody(response.statusCode)) {\n      var contentEncoding = response.headers['content-encoding'] || 'identity'\n      contentEncoding = contentEncoding.trim().toLowerCase()\n\n      if (contentEncoding === 'gzip') {\n        responseContent = zlib.createGunzip()\n        response.pipe(responseContent)\n      } else if (contentEncoding === 'deflate') {\n        responseContent = zlib.createInflate()\n        response.pipe(responseContent)\n      } else {\n        // Since previous versions didn't check for Content-Encoding header,\n        // ignore any invalid values to preserve backwards-compatibility\n        if (contentEncoding !== 'identity') {\n          debug('ignoring unrecognized Content-Encoding ' + contentEncoding)\n        }\n        responseContent = response\n      }\n    } else {\n      responseContent = response\n    }\n\n    if (self.encoding) {\n      if (self.dests.length !== 0) {\n        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.')\n      } else if (responseContent.setEncoding) {\n        responseContent.setEncoding(self.encoding)\n      } else {\n        // Should only occur on node pre-v0.9.4 (joyent/node@9b5abe5) with\n        // zlib streams.\n        // If/When support for 0.9.4 is dropped, this should be unnecessary.\n        responseContent = responseContent.pipe(stringstream(self.encoding))\n      }\n    }\n\n    if (self._paused) {\n      responseContent.pause()\n    }\n\n    self.responseContent = responseContent\n\n    self.emit('response', response)\n\n    self.dests.forEach(function (dest) {\n      self.pipeDest(dest)\n    })\n\n    responseContent.on('data', function (chunk) {\n      self._destdata = true\n      self.emit('data', chunk)\n    })\n    responseContent.on('end', function (chunk) {\n      self.emit('end', chunk)\n    })\n    responseContent.on('error', function (error) {\n      self.emit('error', error)\n    })\n    responseContent.on('close', function () {self.emit('close')})\n\n    if (self.callback) {\n      self.readResponseBody(response)\n    }\n    //if no callback\n    else {\n      self.on('end', function () {\n        if (self._aborted) {\n          debug('aborted', self.uri.href)\n          return\n        }\n        self.emit('complete', response)\n      })\n    }\n  }\n  debug('finish init function', self.uri.href)\n}\n\nRequest.prototype.readResponseBody = function (response) {\n  var self = this\n  debug('reading response\\'s body')\n  var buffer = bl()\n    , strings = []\n\n  self.on('data', function (chunk) {\n    if (Buffer.isBuffer(chunk)) {\n      buffer.append(chunk)\n    } else {\n      strings.push(chunk)\n    }\n  })\n  self.on('end', function () {\n    debug('end event', self.uri.href)\n    if (self._aborted) {\n      debug('aborted', self.uri.href)\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffer.destroy()\n      return\n    }\n\n    if (buffer.length) {\n      debug('has body', self.uri.href, buffer.length)\n      if (self.encoding === null) {\n        // response.body = buffer\n        // can't move to this until https://github.com/rvagg/bl/issues/13\n        response.body = buffer.slice()\n      } else {\n        response.body = buffer.toString(self.encoding)\n      }\n      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.\n      // This can lead to leaky behavior if the user retains a reference to the request object.\n      buffer.destroy()\n    } else if (strings.length) {\n      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.\n      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().\n      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\\uFEFF') {\n        strings[0] = strings[0].substring(1)\n      }\n      response.body = strings.join('')\n    }\n\n    if (self._json) {\n      try {\n        response.body = JSON.parse(response.body, self._jsonReviver)\n      } catch (e) {\n        debug('invalid JSON received', self.uri.href)\n      }\n    }\n    debug('emitting complete', self.uri.href)\n    if (typeof response.body === 'undefined' && !self._json) {\n      response.body = self.encoding === null ? new Buffer(0) : ''\n    }\n    self.emit('complete', response, response.body)\n  })\n}\n\nRequest.prototype.abort = function () {\n  var self = this\n  self._aborted = true\n\n  if (self.req) {\n    self.req.abort()\n  }\n  else if (self.response) {\n    self.response.destroy()\n  }\n\n  self.emit('abort')\n}\n\nRequest.prototype.pipeDest = function (dest) {\n  var self = this\n  var response = self.response\n  // Called after the response is received\n  if (dest.headers && !dest.headersSent) {\n    if (response.caseless.has('content-type')) {\n      var ctname = response.caseless.has('content-type')\n      if (dest.setHeader) {\n        dest.setHeader(ctname, response.headers[ctname])\n      }\n      else {\n        dest.headers[ctname] = response.headers[ctname]\n      }\n    }\n\n    if (response.caseless.has('content-length')) {\n      var clname = response.caseless.has('content-length')\n      if (dest.setHeader) {\n        dest.setHeader(clname, response.headers[clname])\n      } else {\n        dest.headers[clname] = response.headers[clname]\n      }\n    }\n  }\n  if (dest.setHeader && !dest.headersSent) {\n    for (var i in response.headers) {\n      // If the response content is being decoded, the Content-Encoding header\n      // of the response doesn't represent the piped content, so don't pass it.\n      if (!self.gzip || i !== 'content-encoding') {\n        dest.setHeader(i, response.headers[i])\n      }\n    }\n    dest.statusCode = response.statusCode\n  }\n  if (self.pipefilter) {\n    self.pipefilter(response, dest)\n  }\n}\n\nRequest.prototype.qs = function (q, clobber) {\n  var self = this\n  var base\n  if (!clobber && self.uri.query) {\n    base = self._qs.parse(self.uri.query)\n  } else {\n    base = {}\n  }\n\n  for (var i in q) {\n    base[i] = q[i]\n  }\n\n  var qs = self._qs.stringify(base)\n\n  if (qs === '') {\n    return self\n  }\n\n  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs)\n  self.url = self.uri\n  self.path = self.uri.path\n\n  if (self.uri.host === 'unix') {\n    self.enableUnixSocket()\n  }\n\n  return self\n}\nRequest.prototype.form = function (form) {\n  var self = this\n  if (form) {\n    if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n      self.setHeader('content-type', 'application/x-www-form-urlencoded')\n    }\n    self.body = (typeof form === 'string')\n      ? self._qs.rfc3986(form.toString('utf8'))\n      : self._qs.stringify(form).toString('utf8')\n    return self\n  }\n  // create form-data object\n  self._form = new FormData()\n  self._form.on('error', function(err) {\n    err.message = 'form-data: ' + err.message\n    self.emit('error', err)\n    self.abort()\n  })\n  return self._form\n}\nRequest.prototype.multipart = function (multipart) {\n  var self = this\n\n  self._multipart.onRequest(multipart)\n\n  if (!self._multipart.chunked) {\n    self.body = self._multipart.body\n  }\n\n  return self\n}\nRequest.prototype.json = function (val) {\n  var self = this\n\n  if (!self.hasHeader('accept')) {\n    self.setHeader('accept', 'application/json')\n  }\n\n  if (typeof self.jsonReplacer === 'function') {\n    self._jsonReplacer = self.jsonReplacer\n  }\n\n  self._json = true\n  if (typeof val === 'boolean') {\n    if (self.body !== undefined) {\n      if (!/^application\\/x-www-form-urlencoded\\b/.test(self.getHeader('content-type'))) {\n        self.body = safeStringify(self.body, self._jsonReplacer)\n      } else {\n        self.body = self._qs.rfc3986(self.body)\n      }\n      if (!self.hasHeader('content-type')) {\n        self.setHeader('content-type', 'application/json')\n      }\n    }\n  } else {\n    self.body = safeStringify(val, self._jsonReplacer)\n    if (!self.hasHeader('content-type')) {\n      self.setHeader('content-type', 'application/json')\n    }\n  }\n\n  if (typeof self.jsonReviver === 'function') {\n    self._jsonReviver = self.jsonReviver\n  }\n\n  return self\n}\nRequest.prototype.getHeader = function (name, headers) {\n  var self = this\n  var result, re, match\n  if (!headers) {\n    headers = self.headers\n  }\n  Object.keys(headers).forEach(function (key) {\n    if (key.length !== name.length) {\n      return\n    }\n    re = new RegExp(name, 'i')\n    match = key.match(re)\n    if (match) {\n      result = headers[key]\n    }\n  })\n  return result\n}\nRequest.prototype.enableUnixSocket = function () {\n  // Get the socket & request paths from the URL\n  var unixParts = this.uri.path.split(':')\n    , host = unixParts[0]\n    , path = unixParts[1]\n  // Apply unix properties to request\n  this.socketPath = host\n  this.uri.pathname = path\n  this.uri.path = path\n  this.uri.host = host\n  this.uri.hostname = host\n  this.uri.isUnix = true\n}\n\n\nRequest.prototype.auth = function (user, pass, sendImmediately, bearer) {\n  var self = this\n\n  self._auth.onRequest(user, pass, sendImmediately, bearer)\n\n  return self\n}\nRequest.prototype.aws = function (opts, now) {\n  var self = this\n\n  if (!now) {\n    self._aws = opts\n    return self\n  }\n\n  if (opts.sign_version == 4 || opts.sign_version == '4') {\n    // use aws4\n    var options = {\n      host: self.uri.host,\n      path: self.uri.path,\n      method: self.method,\n      headers: {\n        'content-type': self.getHeader('content-type') || ''\n      },\n      body: self.body\n    }\n    var signRes = aws4.sign(options, {\n      accessKeyId: opts.key,\n      secretAccessKey: opts.secret\n    })\n    self.setHeader('authorization', signRes.headers.Authorization)\n    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date'])\n  }\n  else {\n    // default: use aws-sign2\n    var date = new Date()\n    self.setHeader('date', date.toUTCString())\n    var auth =\n      { key: opts.key\n      , secret: opts.secret\n      , verb: self.method.toUpperCase()\n      , date: date\n      , contentType: self.getHeader('content-type') || ''\n      , md5: self.getHeader('content-md5') || ''\n      , amazonHeaders: aws2.canonicalizeHeaders(self.headers)\n      }\n    var path = self.uri.path\n    if (opts.bucket && path) {\n      auth.resource = '/' + opts.bucket + path\n    } else if (opts.bucket && !path) {\n      auth.resource = '/' + opts.bucket\n    } else if (!opts.bucket && path) {\n      auth.resource = path\n    } else if (!opts.bucket && !path) {\n      auth.resource = '/'\n    }\n    auth.resource = aws2.canonicalizeResource(auth.resource)\n    self.setHeader('authorization', aws2.authorization(auth))\n  }\n\n  return self\n}\nRequest.prototype.httpSignature = function (opts) {\n  var self = this\n  httpSignature.signRequest({\n    getHeader: function(header) {\n      return self.getHeader(header, self.headers)\n    },\n    setHeader: function(header, value) {\n      self.setHeader(header, value)\n    },\n    method: self.method,\n    path: self.path\n  }, opts)\n  debug('httpSignature authorization', self.getHeader('authorization'))\n\n  return self\n}\nRequest.prototype.hawk = function (opts) {\n  var self = this\n  self.setHeader('Authorization', hawk.client.header(self.uri, self.method, opts).field)\n}\nRequest.prototype.oauth = function (_oauth) {\n  var self = this\n\n  self._oauth.onRequest(_oauth)\n\n  return self\n}\n\nRequest.prototype.jar = function (jar) {\n  var self = this\n  var cookies\n\n  if (self._redirect.redirectsFollowed === 0) {\n    self.originalCookieHeader = self.getHeader('cookie')\n  }\n\n  if (!jar) {\n    // disable cookies\n    cookies = false\n    self._disableCookies = true\n  } else {\n    var targetCookieJar = (jar && jar.getCookieString) ? jar : globalCookieJar\n    var urihref = self.uri.href\n    //fetch cookie in the Specified host\n    if (targetCookieJar) {\n      cookies = targetCookieJar.getCookieString(urihref)\n    }\n  }\n\n  //if need cookie and cookie is not empty\n  if (cookies && cookies.length) {\n    if (self.originalCookieHeader) {\n      // Don't overwrite existing Cookie header\n      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies)\n    } else {\n      self.setHeader('cookie', cookies)\n    }\n  }\n  self._jar = jar\n  return self\n}\n\n\n// Stream API\nRequest.prototype.pipe = function (dest, opts) {\n  var self = this\n\n  if (self.response) {\n    if (self._destdata) {\n      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'))\n    } else if (self._ended) {\n      self.emit('error', new Error('You cannot pipe after the response has been ended.'))\n    } else {\n      stream.Stream.prototype.pipe.call(self, dest, opts)\n      self.pipeDest(dest)\n      return dest\n    }\n  } else {\n    self.dests.push(dest)\n    stream.Stream.prototype.pipe.call(self, dest, opts)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  var self = this\n  if (self._aborted) {return}\n\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    return self.req.write.apply(self.req, arguments)\n  }\n}\nRequest.prototype.end = function (chunk) {\n  var self = this\n  if (self._aborted) {return}\n\n  if (chunk) {\n    self.write(chunk)\n  }\n  if (!self._started) {\n    self.start()\n  }\n  if (self.req) {\n    self.req.end()\n  }\n}\nRequest.prototype.pause = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = true\n  } else {\n    self.responseContent.pause.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.resume = function () {\n  var self = this\n  if (!self.responseContent) {\n    self._paused = false\n  } else {\n    self.responseContent.resume.apply(self.responseContent, arguments)\n  }\n}\nRequest.prototype.destroy = function () {\n  var self = this\n  if (!self._ended) {\n    self.end()\n  } else if (self.response) {\n    self.response.destroy()\n  }\n}\n\nRequest.defaultProxyHeaderWhiteList =\n  Tunnel.defaultProxyHeaderWhiteList.slice()\n\nRequest.defaultProxyHeaderExclusiveList =\n  Tunnel.defaultProxyHeaderExclusiveList.slice()\n\n// Exports\n\nRequest.prototype.toJSON = requestToJSON\nmodule.exports = Request\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/bl/bl.js":"var DuplexStream = require('readable-stream/duplex')\n  , util         = require('util')\n\n\nfunction BufferList (callback) {\n  if (!(this instanceof BufferList))\n    return new BufferList(callback)\n\n  this._bufs  = []\n  this.length = 0\n\n  if (typeof callback == 'function') {\n    this._callback = callback\n\n    var piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n  } else {\n    this.append(callback)\n  }\n\n  DuplexStream.call(this)\n}\n\n\nutil.inherits(BufferList, DuplexStream)\n\n\nBufferList.prototype._offset = function _offset (offset) {\n  var tot = 0, i = 0, _t\n  for (; i < this._bufs.length; i++) {\n    _t = tot + this._bufs[i].length\n    if (offset < _t)\n      return [ i, offset - tot ]\n    tot = _t\n  }\n}\n\n\nBufferList.prototype.append = function append (buf) {\n  var i = 0\n    , newBuf\n\n  if (Array.isArray(buf)) {\n    for (; i < buf.length; i++)\n      this.append(buf[i])\n  } else if (buf instanceof BufferList) {\n    // unwrap argument into individual BufferLists\n    for (; i < buf._bufs.length; i++)\n      this.append(buf._bufs[i])\n  } else if (buf != null) {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf == 'number')\n      buf = buf.toString()\n\n    newBuf = Buffer.isBuffer(buf) ? buf : new Buffer(buf)\n    this._bufs.push(newBuf)\n    this.length += newBuf.length\n  }\n\n  return this\n}\n\n\nBufferList.prototype._write = function _write (buf, encoding, callback) {\n  this.append(buf)\n\n  if (typeof callback == 'function')\n    callback()\n}\n\n\nBufferList.prototype._read = function _read (size) {\n  if (!this.length)\n    return this.push(null)\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\n\nBufferList.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\n\nBufferList.prototype.get = function get (index) {\n  return this.slice(index, index + 1)[0]\n}\n\n\nBufferList.prototype.slice = function slice (start, end) {\n  return this.copy(null, 0, start, end)\n}\n\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart != 'number' || srcStart < 0)\n    srcStart = 0\n  if (typeof srcEnd != 'number' || srcEnd > this.length)\n    srcEnd = this.length\n  if (srcStart >= this.length)\n    return dst || new Buffer(0)\n  if (srcEnd <= 0)\n    return dst || new Buffer(0)\n\n  var copy   = !!dst\n    , off    = this._offset(srcStart)\n    , len    = srcEnd - srcStart\n    , bytes  = len\n    , bufoff = (copy && dstStart) || 0\n    , start  = off[1]\n    , l\n    , i\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd == this.length) {\n    if (!copy) // slice, just return a full concat\n      return Buffer.concat(this._bufs)\n\n    // copy, need to copy individual buffers\n    for (i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) // a slice, we need something to copy in to\n    dst = new Buffer(len)\n\n  for (i = off[0]; i < this._bufs.length; i++) {\n    l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      break\n    }\n\n    bufoff += l\n    bytes -= l\n\n    if (start)\n      start = 0\n  }\n\n  return dst\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n  return this\n}\n\n\nBufferList.prototype.duplicate = function duplicate () {\n  var i = 0\n    , copy = new BufferList()\n\n  for (; i < this._bufs.length; i++)\n    copy.append(this._bufs[i])\n\n  return copy\n}\n\n\nBufferList.prototype.destroy = function destroy () {\n  this._bufs.length = 0\n  this.length = 0\n  this.push(null)\n}\n\n\n;(function () {\n  var methods = {\n      'readDoubleBE' : 8\n    , 'readDoubleLE' : 8\n    , 'readFloatBE'  : 4\n    , 'readFloatLE'  : 4\n    , 'readInt32BE'  : 4\n    , 'readInt32LE'  : 4\n    , 'readUInt32BE' : 4\n    , 'readUInt32LE' : 4\n    , 'readInt16BE'  : 2\n    , 'readInt16LE'  : 2\n    , 'readUInt16BE' : 2\n    , 'readUInt16LE' : 2\n    , 'readInt8'     : 1\n    , 'readUInt8'    : 1\n  }\n\n  for (var m in methods) {\n    (function (m) {\n      BufferList.prototype[m] = function (offset) {\n        return this.slice(offset, offset + methods[m])[m](0)\n      }\n    }(m))\n  }\n}())\n\n\nmodule.exports = BufferList\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/readable-stream/duplex.js":"module.exports = require(\"./lib/_stream_duplex.js\")\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/readable-stream/lib/_stream_duplex.js":"// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/readable-stream/lib/_stream_readable.js":"'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events');\n\n/*<replacement>*/\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = undefined;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar Duplex;\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nvar Duplex;\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;\n      }\n\n      if (!addToFront) state.reading = false;\n\n      // Don't add to the buffer if we've decoded to an empty string chunk and\n      // we're not in object mode\n      if (!skipAdd) {\n        // if we want the data now, just emit it.\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);\n        } else {\n          // update the buffer info.\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);\n        }\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended) return 0;\n\n  if (state.objectMode) return n === 0 ? 0 : 1;\n\n  if (n === null || isNaN(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length) return state.buffer[0].length;else return state.length;\n  }\n\n  if (n <= 0) return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else {\n      return state.length;\n    }\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (typeof n !== 'number' || n > 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended) state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error) dest.on('error', onerror);else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);else dest._events.error = [onerror, dest._events.error];\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);\n    }return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && !this._readableState.endEmitted) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0) return null;\n\n  if (length === 0) ret = null;else if (objectMode) ret = list.shift();else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode) ret = list.join('');else if (list.length === 1) ret = list[0];else ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode) ret = '';else ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode) ret += buf.slice(0, cpy);else buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length) list[0] = buf.slice(cpy);else list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/readable-stream/lib/_stream_writable.js":"// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/caseless/index.js":"function Caseless (dict) {\n  this.dict = dict || {}\n}\nCaseless.prototype.set = function (name, value, clobber) {\n  if (typeof name === 'object') {\n    for (var i in name) {\n      this.set(i, name[i], value)\n    }\n  } else {\n    if (typeof clobber === 'undefined') clobber = true\n    var has = this.has(name)\n\n    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value\n    else this.dict[has || name] = value\n    return has\n  }\n}\nCaseless.prototype.has = function (name) {\n  var keys = Object.keys(this.dict)\n    , name = name.toLowerCase()\n    ;\n  for (var i=0;i<keys.length;i++) {\n    if (keys[i].toLowerCase() === name) return keys[i]\n  }\n  return false\n}\nCaseless.prototype.get = function (name) {\n  name = name.toLowerCase()\n  var result, _key\n  var headers = this.dict\n  Object.keys(headers).forEach(function (key) {\n    _key = key.toLowerCase()\n    if (name === _key) result = headers[key]\n  })\n  return result\n}\nCaseless.prototype.swap = function (name) {\n  var has = this.has(name)\n  if (!has) throw new Error('There is no header than matches \"'+name+'\"')\n  this.dict[name] = this.dict[has]\n  delete this.dict[has]\n}\nCaseless.prototype.del = function (name) {\n  var has = this.has(name)\n  return delete this.dict[has || name]\n}\n\nmodule.exports = function (dict) {return new Caseless(dict)}\nmodule.exports.httpify = function (resp, headers) {\n  var c = new Caseless(headers)\n  resp.setHeader = function (key, value, clobber) {\n    if (typeof value === 'undefined') return\n    return c.set(key, value, clobber)\n  }\n  resp.hasHeader = function (key) {\n    return c.has(key)\n  }\n  resp.getHeader = function (key) {\n    return c.get(key)\n  }\n  resp.removeHeader = function (key) {\n    return c.del(key)\n  }\n  resp.headers = c.dict\n  return c\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/form-data/lib/form_data.js":"var CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar mime = require('mime-types');\nvar async = require('async');\nvar populate = require('./populate.js');\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n */\nfunction FormData() {\n  if (!(this instanceof FormData)) {\n    throw new TypeError('Failed to construct FormData: Please use the _new_ operator, this object constructor cannot be called as a function.');\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._lengthRetrievers = [];\n\n  CombinedStream.call(this);\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._lengthRetrievers.push(function(next) {\n\n      if (value.hasOwnProperty('fd')) {\n\n        // take read range into a account\n        // `end` = Infinity > read file till the end\n        //\n        // TODO: Looks like there is bug in Node fs.createReadStream\n        // it doesn't respect `end` options without `start` options\n        // Fix it when node fixes it.\n        // https://github.com/joyent/node/issues/7819\n        if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n          // when end specified\n          // no need to calculate range\n          // inclusive, starts with 0\n          next(null, value.end + 1 - (value.start ? value.start : 0));\n\n        // not that fast snoopy\n        } else {\n          // still need to fetch file size from fs\n          fs.stat(value.path, function(err, stat) {\n\n            var fileSize;\n\n            if (err) {\n              next(err);\n              return;\n            }\n\n            // update final size based on the range options\n            fileSize = stat.size - (value.start ? value.start : 0);\n            next(null, fileSize);\n          });\n        }\n\n      // or http response\n      } else if (value.hasOwnProperty('httpVersion')) {\n        next(null, +value.headers['content-length']);\n\n      // or request stream http://github.com/mikeal/request\n      } else if (value.hasOwnProperty('httpModule')) {\n        // wait till response come back\n        value.on('response', function(response) {\n          value.pause();\n          next(null, +response.headers['content-length']);\n        });\n        value.resume();\n\n      // something else\n      } else {\n        next('Unknown stream');\n      }\n    });\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    header = headers[prop];\n\n    // skip nullish headers.\n    if (header == null) {\n      continue;\n    }\n\n    // convert all headers to arrays.\n    if (!Array.isArray(header)) {\n      header = [header];\n    }\n\n    // add non-empty headers.\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var contentDisposition;\n\n  // custom filename takes precedence\n  // fs- and request- streams have path property\n  // formidable and the browser add a name property.\n  var filename = options.filename || value.name || value.path;\n\n  // or try http response\n  if (!filename && value.readable && value.hasOwnProperty('httpVersion')) {\n    filename = value.client._httpMessage.path;\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + path.basename(filename) + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filename\n  if (!contentType && options.filename) {\n    contentType = mime.lookup(options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\n// TODO: Looks like unused function\nFormData.prototype.getCustomHeaders = function(contentType) {\n  contentType = contentType ? contentType : 'multipart/form-data';\n\n  var formHeaders = {\n    'content-type': contentType + '; boundary=' + this.getBoundary(),\n    'content-length': this.getLengthSync()\n  };\n\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (this._lengthRetrievers.length) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._lengthRetrievers.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  async.parallel(this._lengthRetrievers, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err) {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/async/dist/async.js":"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.async = global.async || {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest$1(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n// Lodash rest function without function.toString()\n// remappings\nfunction rest(func, start) {\n    return overRest$1(func, start, identity);\n}\n\nvar initialParams = function (fn) {\n    return rest(function (args /*..., callback*/) {\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    });\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous funuction, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function (value) {\n                callback(null, value);\n            }, function (err) {\n                callback(err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction supportsAsync() {\n    var supported;\n    try {\n        /* eslint no-eval: 0 */\n        supported = isAsync(eval('(async function () {})'));\n    } catch (e) {\n        supported = false;\n    }\n    return supported;\n}\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nvar wrapAsync$1 = supportsAsync() ? wrapAsync : identity;\n\nfunction applyEach$1(eachfn) {\n    return rest(function (fns, args) {\n        var go = initialParams(function (args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync$1(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        } else {\n            return go;\n        }\n    });\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  value = Object(value);\n  return (symToStringTag && symToStringTag in value)\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? { value: coll[i], key: i } : null;\n    };\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done) return null;\n        i++;\n        return { value: item.value, key: i };\n    };\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? { value: obj[key], key: key } : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function () {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            } else if (value === breakLoop || done && running <= 0) {\n                done = true;\n                return callback(null);\n            } else {\n                replenish();\n            }\n        }\n\n        function replenish() {\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if (++completed === length || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function (coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} function - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply$2 = rest(function (fn, args) {\n    return rest(function (callArgs) {\n        return fn.apply(null, args.concat(callArgs));\n    });\n});\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            runningTasks--;\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function (val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = args;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = args;\n                taskComplete(key);\n            }\n        }));\n\n        runningTasks++;\n        var taskFn = wrapAsync$1(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20f0';\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboMarksRange$1 + rsComboSymbolsRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg) {\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync$1(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return rest(function (fn, args) {\n        defer(function () {\n            fn.apply(null, args);\n        });\n    });\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function (node) {\n    if (node.prev) node.prev.next = node.next;else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = DLL;\n\nDLL.prototype.insertAfter = function (node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function (node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function (node) {\n    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);\n};\n\nDLL.prototype.push = function (node) {\n    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);\n};\n\nDLL.prototype.shift = function () {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function () {\n    return this.tail && this.removeLink(this.tail);\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    } else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync$1(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    }\n\n    function _next(tasks) {\n        return rest(function (args) {\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n                var index = baseIndexOf(workersList, task, 0);\n                if (index >= 0) {\n                    workersList.splice(index);\n                }\n\n                task.callback.apply(task, args);\n\n                if (args[0] != null) {\n                    q.error(args[0], task.data);\n                }\n            }\n\n            if (numRunning <= q.concurrency - q.buffer) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        });\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated: noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n                var tasks = [],\n                    data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    data.push(node.data);\n                }\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n                numRunning += 1;\n                workersList.push(tasks[0]);\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function () {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n  return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfSeries(coll, function (x, i, callback) {\n        _iteratee(memo, x, function (err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nvar seq$1 = rest(function seq(functions) {\n    var _functions = arrayMap(functions, wrapAsync$1);\n    return rest(function (args) {\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function (newargs, fn, cb) {\n            fn.apply(that, newargs.concat(rest(function (err, nextargs) {\n                cb(err, nextargs);\n            })));\n        }, function (err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    });\n});\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = rest(function (args) {\n  return seq$1.apply(null, args.reverse());\n});\n\nfunction concat$1(eachfn, arr, fn, callback) {\n    var result = [];\n    eachfn(arr, function (x, index, cb) {\n        fn(x, function (err, y) {\n            result = result.concat(y || []);\n            cb(err);\n        });\n    }, function (err) {\n        callback(err, result);\n    });\n}\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doParallel(concat$1);\n\nfunction doSeries(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doSeries(concat$1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = rest(function (values) {\n    var args = [null].concat(values);\n    return initialParams(function (ignoredArgs, callback) {\n        return callback.apply(this, args);\n    });\n});\n\nfunction _createTester(check, getResult) {\n    return function (eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function (value, _, callback) {\n            iteratee(value, function (err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return rest(function (fn, args) {\n        wrapAsync$1(fn).apply(null, args.concat(rest(function (err, args) {\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        })));\n    });\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        args.push(check);\n        _test.apply(this, args);\n    });\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function () {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync$1(fn);\n    var _test = wrapAsync$1(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({ index: index, value: x });\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync$1(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync$1(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function (coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync$1(iteratee);\n    mapLimit(coll, limit, function (val, callback) {\n        _iteratee(val, function (err, key) {\n            if (err) return callback(err);\n            return callback(null, { key: key, val: val });\n        });\n    }, function (err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync$1(iteratee);\n    eachOfLimit(obj, limit, function (val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync$1(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function () {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(rest(function (args) {\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            })));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `setImmediate`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @alias setImmediate\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync$1(task)(rest(function (err, args) {\n            if (args.length <= 1) {\n                args = args[0];\n            }\n            results[key] = args;\n            callback(err);\n        }));\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n  _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n  _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n  var _worker = wrapAsync$1(worker);\n  return queue(function (items, cb) {\n    _worker(items[0], cb);\n  }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function (worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function (data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function () {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync$1(tasks[i])(callback);\n    }\n}\n\nvar slice = Array.prototype.slice;\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight(array, memo, iteratee, callback) {\n  var reversed = slice.call(array).reverse();\n  reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync$1(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(rest(function callback(err, cbArgs) {\n            if (err) {\n                reflectCallback(null, {\n                    error: err\n                });\n            } else {\n                var value = null;\n                if (cbArgs.length === 1) {\n                    value = cbArgs[0];\n                } else if (cbArgs.length > 1) {\n                    value = cbArgs;\n                }\n                reflectCallback(null, {\n                    value: value\n                });\n            }\n        }));\n\n        return _fn.apply(this, args);\n    });\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function (value, cb) {\n        iteratee(value, function (err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function (task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // It can also be embedded within other control flow functions to retry\n * // individual methods that are not as reliable, like this:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync$1(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function (err) {\n            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync$1(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n  _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy(coll, iteratee, callback) {\n    var _iteratee = wrapAsync$1(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, { value: x, criteria: criteria });\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria,\n            b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var originalCallback, timer;\n    var timedOut = false;\n\n    function injectedCallback() {\n        if (!timedOut) {\n            originalCallback.apply(null, arguments);\n            clearTimeout(timer);\n        }\n    }\n\n    function timeoutCallback() {\n        var name = asyncFn.name || 'anonymous';\n        var error = new Error('Callback function \"' + name + '\" timed out.');\n        error.code = 'ETIMEDOUT';\n        if (info) {\n            error.info = info;\n        }\n        timedOut = true;\n        originalCallback(error);\n    }\n\n    var fn = wrapAsync$1(asyncFn);\n\n    return initialParams(function (args, origCallback) {\n        originalCallback = origCallback;\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args.concat(injectedCallback));\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax$1 = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax$1(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n  var _iteratee = wrapAsync$1(iteratee);\n  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform(coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n\n    eachOf(coll, function (v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function (err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync$1(iteratee);\n    if (!test()) return callback(null);\n    var next = rest(function (err, args) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    });\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function () {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function (tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        if (taskIndex === tasks.length) {\n            return callback.apply(null, [null].concat(args));\n        }\n\n        var taskCallback = onlyOnce(rest(function (err, args) {\n            if (err) {\n                return callback.apply(null, [err].concat(args));\n            }\n            nextTask(args);\n        }));\n\n        args.push(taskCallback);\n\n        var task = wrapAsync$1(tasks[taskIndex++]);\n        task.apply(null, args);\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n  applyEach: applyEach,\n  applyEachSeries: applyEachSeries,\n  apply: apply$2,\n  asyncify: asyncify,\n  auto: auto,\n  autoInject: autoInject,\n  cargo: cargo,\n  compose: compose,\n  concat: concat,\n  concatSeries: concatSeries,\n  constant: constant,\n  detect: detect,\n  detectLimit: detectLimit,\n  detectSeries: detectSeries,\n  dir: dir,\n  doDuring: doDuring,\n  doUntil: doUntil,\n  doWhilst: doWhilst,\n  during: during,\n  each: eachLimit,\n  eachLimit: eachLimit$1,\n  eachOf: eachOf,\n  eachOfLimit: eachOfLimit,\n  eachOfSeries: eachOfSeries,\n  eachSeries: eachSeries,\n  ensureAsync: ensureAsync,\n  every: every,\n  everyLimit: everyLimit,\n  everySeries: everySeries,\n  filter: filter,\n  filterLimit: filterLimit,\n  filterSeries: filterSeries,\n  forever: forever,\n  groupBy: groupBy,\n  groupByLimit: groupByLimit,\n  groupBySeries: groupBySeries,\n  log: log,\n  map: map,\n  mapLimit: mapLimit,\n  mapSeries: mapSeries,\n  mapValues: mapValues,\n  mapValuesLimit: mapValuesLimit,\n  mapValuesSeries: mapValuesSeries,\n  memoize: memoize,\n  nextTick: nextTick,\n  parallel: parallelLimit,\n  parallelLimit: parallelLimit$1,\n  priorityQueue: priorityQueue,\n  queue: queue$1,\n  race: race,\n  reduce: reduce,\n  reduceRight: reduceRight,\n  reflect: reflect,\n  reflectAll: reflectAll,\n  reject: reject,\n  rejectLimit: rejectLimit,\n  rejectSeries: rejectSeries,\n  retry: retry,\n  retryable: retryable,\n  seq: seq$1,\n  series: series,\n  setImmediate: setImmediate$1,\n  some: some,\n  someLimit: someLimit,\n  someSeries: someSeries,\n  sortBy: sortBy,\n  timeout: timeout,\n  times: times,\n  timesLimit: timeLimit,\n  timesSeries: timesSeries,\n  transform: transform,\n  unmemoize: unmemoize,\n  until: until,\n  waterfall: waterfall,\n  whilst: whilst,\n\n  // aliases\n  all: every,\n  any: some,\n  forEach: eachLimit,\n  forEachSeries: eachSeries,\n  forEachLimit: eachLimit$1,\n  forEachOf: eachOf,\n  forEachOfSeries: eachOfSeries,\n  forEachOfLimit: eachOfLimit,\n  inject: reduce,\n  foldl: reduce,\n  foldr: reduceRight,\n  select: filter,\n  selectLimit: filterLimit,\n  selectSeries: filterSeries,\n  wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.apply = apply$2;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq$1;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/form-data/lib/populate.js":"// populates missing values\nmodule.exports = function(dst, src) {\n\n  Object.keys(src).forEach(function(prop)\n  {\n    dst[prop] = dst[prop] || src[prop];\n  });\n\n  return dst;\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/getProxyFromURI.js":"'use strict'\n\nfunction formatHostname(hostname) {\n  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'\n  return hostname.replace(/^\\.*/, '.').toLowerCase()\n}\n\nfunction parseNoProxyZone(zone) {\n  zone = zone.trim().toLowerCase()\n\n  var zoneParts = zone.split(':', 2)\n    , zoneHost = formatHostname(zoneParts[0])\n    , zonePort = zoneParts[1]\n    , hasPort = zone.indexOf(':') > -1\n\n  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}\n}\n\nfunction uriInNoProxy(uri, noProxy) {\n  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80')\n    , hostname = formatHostname(uri.hostname)\n    , noProxyList = noProxy.split(',')\n\n  // iterate through the noProxyList until it finds a match.\n  return noProxyList.map(parseNoProxyZone).some(function(noProxyZone) {\n    var isMatchedAt = hostname.indexOf(noProxyZone.hostname)\n      , hostnameMatched = (\n          isMatchedAt > -1 &&\n          (isMatchedAt === hostname.length - noProxyZone.hostname.length)\n        )\n\n    if (noProxyZone.hasPort) {\n      return (port === noProxyZone.port) && hostnameMatched\n    }\n\n    return hostnameMatched\n  })\n}\n\nfunction getProxyFromURI(uri) {\n  // Decide the proper request proxy to use based on the request URI object and the\n  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)\n  // respect NO_PROXY environment variables (see: http://lynx.isc.org/current/breakout/lynx_help/keystrokes/environments.html)\n\n  var noProxy = process.env.NO_PROXY || process.env.no_proxy || ''\n\n  // if the noProxy is a wildcard then return null\n\n  if (noProxy === '*') {\n    return null\n  }\n\n  // if the noProxy is not empty and the uri is found return null\n\n  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {\n    return null\n  }\n\n  // Check for HTTP or HTTPS Proxy in environment Else default to null\n\n  if (uri.protocol === 'http:') {\n    return process.env.HTTP_PROXY ||\n           process.env.http_proxy || null\n  }\n\n  if (uri.protocol === 'https:') {\n    return process.env.HTTPS_PROXY ||\n           process.env.https_proxy ||\n           process.env.HTTP_PROXY  ||\n           process.env.http_proxy  || null\n  }\n\n  // if none of that works, return null\n  // (What uri protocol are you using then?)\n\n  return null\n}\n\nmodule.exports = getProxyFromURI\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/querystring.js":"'use strict'\n\nvar qs = require('qs')\n  , querystring = require('querystring')\n\n\nfunction Querystring (request) {\n  this.request = request\n  this.lib = null\n  this.useQuerystring = null\n  this.parseOptions = null\n  this.stringifyOptions = null\n}\n\nQuerystring.prototype.init = function (options) {\n  if (this.lib) {return}\n\n  this.useQuerystring = options.useQuerystring\n  this.lib = (this.useQuerystring ? querystring : qs)\n\n  this.parseOptions = options.qsParseOptions || {}\n  this.stringifyOptions = options.qsStringifyOptions || {}\n}\n\nQuerystring.prototype.stringify = function (obj) {\n  return (this.useQuerystring)\n    ? this.rfc3986(this.lib.stringify(obj,\n      this.stringifyOptions.sep || null,\n      this.stringifyOptions.eq || null,\n      this.stringifyOptions))\n    : this.lib.stringify(obj, this.stringifyOptions)\n}\n\nQuerystring.prototype.parse = function (str) {\n  return (this.useQuerystring)\n    ? this.lib.parse(str,\n      this.parseOptions.sep || null,\n      this.parseOptions.eq || null,\n      this.parseOptions)\n    : this.lib.parse(str, this.parseOptions)\n}\n\nQuerystring.prototype.rfc3986 = function (str) {\n  return str.replace(/[!'()*]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\nQuerystring.prototype.unescape = querystring.unescape\n\nexports.Querystring = Querystring\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/qs/lib/index.js":"'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/qs/lib/stringify.js":"'use strict';\n\nvar Utils = require('./utils');\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) {\n        return prefix + '[]';\n    },\n    indices: function indices(prefix, key) {\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) {\n        return prefix;\n    }\n};\n\nvar defaults = {\n    delimiter: '&',\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true,\n    encoder: Utils.encode\n};\n\nvar stringify = function stringify(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encoder ? encoder(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || Utils.isBuffer(obj)) {\n        if (encoder) {\n            return [encoder(prefix) + '=' + encoder(obj)];\n        }\n        return [prefix + '=' + String(obj)];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        } else {\n            values = values.concat(stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;\n    var encoder = encode ? (typeof options.encoder === 'function' ? options.encoder : defaults.encoder) : null;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n\n    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/qs/lib/utils.js":"'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nvar has = Object.prototype.hasOwnProperty;\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (obj[i] && typeof obj[i] === 'object') {\n                compacted.push(exports.compact(obj[i], refs));\n            } else if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/qs/lib/parse.js":"'use strict';\n\nvar Utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false,\n    decoder: Utils.decode\n};\n\nvar parseValues = function parseValues(str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos));\n            val = options.decoder(part.slice(pos + 1));\n        }\n        if (has.call(obj, key)) {\n            obj[key] = [].concat(obj[key]).concat(val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function parseObject(chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\nvar parseKeys = function parseKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n\n    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/har.js":"'use strict'\n\nvar fs = require('fs')\nvar qs = require('querystring')\nvar validate = require('har-validator')\nvar extend = require('extend')\n\nfunction Har (request) {\n  this.request = request\n}\n\nHar.prototype.reducer = function (obj, pair) {\n  // new property ?\n  if (obj[pair.name] === undefined) {\n    obj[pair.name] = pair.value\n    return obj\n  }\n\n  // existing? convert to array\n  var arr = [\n    obj[pair.name],\n    pair.value\n  ]\n\n  obj[pair.name] = arr\n\n  return obj\n}\n\nHar.prototype.prep = function (data) {\n  // construct utility properties\n  data.queryObj = {}\n  data.headersObj = {}\n  data.postData.jsonObj = false\n  data.postData.paramsObj = false\n\n  // construct query objects\n  if (data.queryString && data.queryString.length) {\n    data.queryObj = data.queryString.reduce(this.reducer, {})\n  }\n\n  // construct headers objects\n  if (data.headers && data.headers.length) {\n    // loweCase header keys\n    data.headersObj = data.headers.reduceRight(function (headers, header) {\n      headers[header.name] = header.value\n      return headers\n    }, {})\n  }\n\n  // construct Cookie header\n  if (data.cookies && data.cookies.length) {\n    var cookies = data.cookies.map(function (cookie) {\n      return cookie.name + '=' + cookie.value\n    })\n\n    if (cookies.length) {\n      data.headersObj.cookie = cookies.join('; ')\n    }\n  }\n\n  // prep body\n  function some (arr) {\n    return arr.some(function (type) {\n      return data.postData.mimeType.indexOf(type) === 0\n    })\n  }\n\n  if (some([\n    'multipart/mixed',\n    'multipart/related',\n    'multipart/form-data',\n    'multipart/alternative'])) {\n\n    // reset values\n    data.postData.mimeType = 'multipart/form-data'\n  }\n\n  else if (some([\n    'application/x-www-form-urlencoded'])) {\n\n    if (!data.postData.params) {\n      data.postData.text = ''\n    } else {\n      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {})\n\n      // always overwrite\n      data.postData.text = qs.stringify(data.postData.paramsObj)\n    }\n  }\n\n  else if (some([\n    'text/json',\n    'text/x-json',\n    'application/json',\n    'application/x-json'])) {\n\n    data.postData.mimeType = 'application/json'\n\n    if (data.postData.text) {\n      try {\n        data.postData.jsonObj = JSON.parse(data.postData.text)\n      } catch (e) {\n        this.request.debug(e)\n\n        // force back to text/plain\n        data.postData.mimeType = 'text/plain'\n      }\n    }\n  }\n\n  return data\n}\n\nHar.prototype.options = function (options) {\n  // skip if no har property defined\n  if (!options.har) {\n    return options\n  }\n\n  var har = {}\n  extend(har, options.har)\n\n  // only process the first entry\n  if (har.log && har.log.entries) {\n    har = har.log.entries[0]\n  }\n\n  // add optional properties to make validation successful\n  har.url = har.url || options.url || options.uri || options.baseUrl || '/'\n  har.httpVersion = har.httpVersion || 'HTTP/1.1'\n  har.queryString = har.queryString || []\n  har.headers = har.headers || []\n  har.cookies = har.cookies || []\n  har.postData = har.postData || {}\n  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream'\n\n  har.bodySize = 0\n  har.headersSize = 0\n  har.postData.size = 0\n\n  if (!validate.request(har)) {\n    return options\n  }\n\n  // clean up and get some utility properties\n  var req = this.prep(har)\n\n  // construct new options\n  if (req.url) {\n    options.url = req.url\n  }\n\n  if (req.method) {\n    options.method = req.method\n  }\n\n  if (Object.keys(req.queryObj).length) {\n    options.qs = req.queryObj\n  }\n\n  if (Object.keys(req.headersObj).length) {\n    options.headers = req.headersObj\n  }\n\n  function test (type) {\n    return req.postData.mimeType.indexOf(type) === 0\n  }\n  if (test('application/x-www-form-urlencoded')) {\n    options.form = req.postData.paramsObj\n  }\n  else if (test('application/json')) {\n    if (req.postData.jsonObj) {\n      options.body = req.postData.jsonObj\n      options.json = true\n    }\n  }\n  else if (test('multipart/form-data')) {\n    options.formData = {}\n\n    req.postData.params.forEach(function (param) {\n      var attachment = {}\n\n      if (!param.fileName && !param.fileName && !param.contentType) {\n        options.formData[param.name] = param.value\n        return\n      }\n\n      // attempt to read from disk!\n      if (param.fileName && !param.value) {\n        attachment.value = fs.createReadStream(param.fileName)\n      } else if (param.value) {\n        attachment.value = param.value\n      }\n\n      if (param.fileName) {\n        attachment.options = {\n          filename: param.fileName,\n          contentType: param.contentType ? param.contentType : null\n        }\n      }\n\n      options.formData[param.name] = attachment\n    })\n  }\n  else {\n    if (req.postData.text) {\n      options.body = req.postData.text\n    }\n  }\n\n  return options\n}\n\nexports.Har = Har\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/har-validator/lib/index.js":"'use strict'\n\nvar Promise = require('pinkie-promise')\nvar runner = require('./runner')\nvar schemas = require('./schemas')\n\nvar promisify = function (schema) {\n  return function (data) {\n    return new Promise(function (resolve, reject) {\n      runner(schema, data, function (err, valid) {\n        return err === null ? resolve(data) : reject(err)\n      })\n    })\n  }\n}\n\nmodule.exports = promisify(schemas.har)\n\n// utility methods for all parts of the schema\nObject.keys(schemas).map(function (name) {\n  module.exports[name] = promisify(schemas[name])\n})\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/har-validator/lib/runner.js":"'use strict'\n\nvar schemas = require('./schemas')\nvar ValidationError = require('./error')\nvar validator = require('is-my-json-valid')\n\nmodule.exports = function (schema, data, cb) {\n  // default value\n  var valid = false\n\n  // validator config\n  var validate = validator(schema, {\n    greedy: true,\n    verbose: true,\n    schemas: schemas\n  })\n\n  // execute is-my-json-valid\n  if (data !== undefined) {\n    valid = validate(data)\n  }\n\n  // callback?\n  if (typeof cb === 'function') {\n    return cb(validate.errors ? new ValidationError(validate.errors) : null, valid)\n  }\n\n  return valid\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/har-validator/lib/schemas/index.js":"'use strict'\n\nvar schemas = {\n  cache: require('./cache.json'),\n  cacheEntry: require('./cacheEntry.json'),\n  content: require('./content.json'),\n  cookie: require('./cookie.json'),\n  creator: require('./creator.json'),\n  entry: require('./entry.json'),\n  har: require('./har.json'),\n  log: require('./log.json'),\n  page: require('./page.json'),\n  pageTimings: require('./pageTimings.json'),\n  postData: require('./postData.json'),\n  record: require('./record.json'),\n  request: require('./request.json'),\n  response: require('./response.json'),\n  timings: require('./timings.json')\n}\n\n// is-my-json-valid does not provide meaningful error messages for external schemas\n// this is a workaround\nschemas.cache.properties.beforeRequest = schemas.cacheEntry\nschemas.cache.properties.afterRequest = schemas.cacheEntry\n\nschemas.page.properties.pageTimings = schemas.pageTimings\n\nschemas.request.properties.cookies.items = schemas.cookie\nschemas.request.properties.headers.items = schemas.record\nschemas.request.properties.queryString.items = schemas.record\nschemas.request.properties.postData = schemas.postData\n\nschemas.response.properties.cookies.items = schemas.cookie\nschemas.response.properties.headers.items = schemas.record\nschemas.response.properties.content = schemas.content\n\nschemas.entry.properties.request = schemas.request\nschemas.entry.properties.response = schemas.response\nschemas.entry.properties.cache = schemas.cache\nschemas.entry.properties.timings = schemas.timings\n\nschemas.log.properties.creator = schemas.creator\nschemas.log.properties.browser = schemas.creator\nschemas.log.properties.pages.items = schemas.page\nschemas.log.properties.entries.items = schemas.entry\n\nschemas.har.properties.log = schemas.log\n\nmodule.exports = schemas\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/har-validator/lib/error.js":"'use strict'\n\nfunction ValidationError (errors) {\n  this.name = 'ValidationError'\n  this.errors = errors\n}\n\nValidationError.prototype = Error.prototype\n\nmodule.exports = ValidationError\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/auth.js":"'use strict'\n\nvar caseless = require('caseless')\n  , uuid = require('node-uuid')\n  , helpers = require('./helpers')\n\nvar md5 = helpers.md5\n  , toBase64 = helpers.toBase64\n\n\nfunction Auth (request) {\n  // define all public properties here\n  this.request = request\n  this.hasAuth = false\n  this.sentAuth = false\n  this.bearerToken = null\n  this.user = null\n  this.pass = null\n}\n\nAuth.prototype.basic = function (user, pass, sendImmediately) {\n  var self = this\n  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {\n    self.request.emit('error', new Error('auth() received invalid user or password'))\n  }\n  self.user = user\n  self.pass = pass\n  self.hasAuth = true\n  var header = user + ':' + (pass || '')\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    var authHeader = 'Basic ' + toBase64(header)\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.bearer = function (bearer, sendImmediately) {\n  var self = this\n  self.bearerToken = bearer\n  self.hasAuth = true\n  if (sendImmediately || typeof sendImmediately === 'undefined') {\n    if (typeof bearer === 'function') {\n      bearer = bearer()\n    }\n    var authHeader = 'Bearer ' + (bearer || '')\n    self.sentAuth = true\n    return authHeader\n  }\n}\n\nAuth.prototype.digest = function (method, path, authHeader) {\n  // TODO: More complete implementation of RFC 2617.\n  //   - handle challenge.domain\n  //   - support qop=\"auth-int\" only\n  //   - handle Authentication-Info (not necessarily?)\n  //   - check challenge.stale (not necessarily?)\n  //   - increase nc (not necessarily?)\n  // For reference:\n  // http://tools.ietf.org/html/rfc2617#section-3\n  // https://github.com/bagder/curl/blob/master/lib/http_digest.c\n\n  var self = this\n\n  var challenge = {}\n  var re = /([a-z0-9_-]+)=(?:\"([^\"]+)\"|([a-z0-9_-]+))/gi\n  for (;;) {\n    var match = re.exec(authHeader)\n    if (!match) {\n      break\n    }\n    challenge[match[1]] = match[2] || match[3]\n  }\n\n  /**\n   * RFC 2617: handle both MD5 and MD5-sess algorithms.\n   *\n   * If the algorithm directive's value is \"MD5\" or unspecified, then HA1 is\n   *   HA1=MD5(username:realm:password)\n   * If the algorithm directive's value is \"MD5-sess\", then HA1 is\n   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)\n   */\n  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {\n    var ha1 = md5(user + ':' + realm + ':' + pass)\n    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {\n      return md5(ha1 + ':' + nonce + ':' + cnonce)\n    } else {\n      return ha1\n    }\n  }\n\n  var qop = /(^|,)\\s*auth\\s*($|,)/.test(challenge.qop) && 'auth'\n  var nc = qop && '00000001'\n  var cnonce = qop && uuid().replace(/-/g, '')\n  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce)\n  var ha2 = md5(method + ':' + path)\n  var digestResponse = qop\n    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)\n    : md5(ha1 + ':' + challenge.nonce + ':' + ha2)\n  var authValues = {\n    username: self.user,\n    realm: challenge.realm,\n    nonce: challenge.nonce,\n    uri: path,\n    qop: qop,\n    response: digestResponse,\n    nc: nc,\n    cnonce: cnonce,\n    algorithm: challenge.algorithm,\n    opaque: challenge.opaque\n  }\n\n  authHeader = []\n  for (var k in authValues) {\n    if (authValues[k]) {\n      if (k === 'qop' || k === 'nc' || k === 'algorithm') {\n        authHeader.push(k + '=' + authValues[k])\n      } else {\n        authHeader.push(k + '=\"' + authValues[k] + '\"')\n      }\n    }\n  }\n  authHeader = 'Digest ' + authHeader.join(', ')\n  self.sentAuth = true\n  return authHeader\n}\n\nAuth.prototype.onRequest = function (user, pass, sendImmediately, bearer) {\n  var self = this\n    , request = self.request\n\n  var authHeader\n  if (bearer === undefined && user === undefined) {\n    self.request.emit('error', new Error('no auth mechanism defined'))\n  } else if (bearer !== undefined) {\n    authHeader = self.bearer(bearer, sendImmediately)\n  } else {\n    authHeader = self.basic(user, pass, sendImmediately)\n  }\n  if (authHeader) {\n    request.setHeader('authorization', authHeader)\n  }\n}\n\nAuth.prototype.onResponse = function (response) {\n  var self = this\n    , request = self.request\n\n  if (!self.hasAuth || self.sentAuth) { return null }\n\n  var c = caseless(response.headers)\n\n  var authHeader = c.get('www-authenticate')\n  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase()\n  request.debug('reauth', authVerb)\n\n  switch (authVerb) {\n    case 'basic':\n      return self.basic(self.user, self.pass, true)\n\n    case 'bearer':\n      return self.bearer(self.bearerToken, true)\n\n    case 'digest':\n      return self.digest(request.method, request.path, authHeader)\n  }\n}\n\nexports.Auth = Auth\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/node-uuid/uuid.js":"//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n/*global window, require, define */\n(function(_window) {\n  'use strict';\n\n  // Unique ID creation requires a high quality random # generator.  We feature\n  // detect to determine the best RNG source, normalizing to a function that\n  // returns 128-bits of randomness, since that's what's usually required\n  var _rng, _mathRNG, _nodeRNG, _whatwgRNG, _previousRoot;\n\n  function setupBrowser() {\n    // Allow for MSIE11 msCrypto\n    var _crypto = _window.crypto || _window.msCrypto;\n\n    if (!_rng && _crypto && _crypto.getRandomValues) {\n      // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n      //\n      // Moderately fast, high quality\n      try {\n        var _rnds8 = new Uint8Array(16);\n        _whatwgRNG = _rng = function whatwgRNG() {\n          _crypto.getRandomValues(_rnds8);\n          return _rnds8;\n        };\n        _rng();\n      } catch(e) {}\n    }\n\n    if (!_rng) {\n      // Math.random()-based (RNG)\n      //\n      // If all else fails, use Math.random().  It's fast, but is of unspecified\n      // quality.\n      var  _rnds = new Array(16);\n      _mathRNG = _rng = function() {\n        for (var i = 0, r; i < 16; i++) {\n          if ((i & 0x03) === 0) { r = Math.random() * 0x100000000; }\n          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n        }\n\n        return _rnds;\n      };\n      if ('undefined' !== typeof console && console.warn) {\n        console.warn(\"[SECURITY] node-uuid: crypto not usable, falling back to insecure Math.random()\");\n      }\n    }\n  }\n\n  function setupNode() {\n    // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n    //\n    // Moderately fast, high quality\n    if ('function' === typeof require) {\n      try {\n        var _rb = require('crypto').randomBytes;\n        _nodeRNG = _rng = _rb && function() {return _rb(16);};\n        _rng();\n      } catch(e) {}\n    }\n  }\n\n  if (_window) {\n    setupBrowser();\n  } else {\n    setupNode();\n  }\n\n  // Buffer class to use\n  var BufferClass = ('function' === typeof Buffer) ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = (options.clockseq != null) ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = (options.msecs != null) ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = (options.nsecs != null) ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) === 'string') {\n      buf = (options === 'binary') ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n  uuid._rng = _rng;\n  uuid._mathRNG = _mathRNG;\n  uuid._nodeRNG = _nodeRNG;\n  uuid._whatwgRNG = _whatwgRNG;\n\n  if (('undefined' !== typeof module) && module.exports) {\n    // Publish as node.js module\n    module.exports = uuid;\n  } else if (typeof define === 'function' && define.amd) {\n    // Publish as AMD module\n    define(function() {return uuid;});\n\n\n  } else {\n    // Publish as global (in browsers)\n    _previousRoot = _window.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _window.uuid = _previousRoot;\n      return uuid;\n    };\n\n    _window.uuid = uuid;\n  }\n})('undefined' !== typeof window ? window : null);\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/oauth.js":"'use strict'\n\nvar url = require('url')\n  , qs = require('qs')\n  , caseless = require('caseless')\n  , uuid = require('node-uuid')\n  , oauth = require('oauth-sign')\n  , crypto = require('crypto')\n\n\nfunction OAuth (request) {\n  this.request = request\n  this.params = null\n}\n\nOAuth.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {\n  var oa = {}\n  for (var i in _oauth) {\n    oa['oauth_' + i] = _oauth[i]\n  }\n  if (!oa.oauth_version) {\n    oa.oauth_version = '1.0'\n  }\n  if (!oa.oauth_timestamp) {\n    oa.oauth_timestamp = Math.floor( Date.now() / 1000 ).toString()\n  }\n  if (!oa.oauth_nonce) {\n    oa.oauth_nonce = uuid().replace(/-/g, '')\n  }\n  if (!oa.oauth_signature_method) {\n    oa.oauth_signature_method = 'HMAC-SHA1'\n  }\n\n  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key\n  delete oa.oauth_consumer_secret\n  delete oa.oauth_private_key\n\n  var token_secret = oa.oauth_token_secret\n  delete oa.oauth_token_secret\n\n  var realm = oa.oauth_realm\n  delete oa.oauth_realm\n  delete oa.oauth_transport_method\n\n  var baseurl = uri.protocol + '//' + uri.host + uri.pathname\n  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'))\n\n  oa.oauth_signature = oauth.sign(\n    oa.oauth_signature_method,\n    method,\n    baseurl,\n    params,\n    consumer_secret_or_private_key,\n    token_secret)\n\n  if (realm) {\n    oa.realm = realm\n  }\n\n  return oa\n}\n\nOAuth.prototype.buildBodyHash = function(_oauth, body) {\n  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {\n    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +\n      ' signature_method not supported with body_hash signing.'))\n  }\n\n  var shasum = crypto.createHash('sha1')\n  shasum.update(body || '')\n  var sha1 = shasum.digest('hex')\n\n  return new Buffer(sha1).toString('base64')\n}\n\nOAuth.prototype.concatParams = function (oa, sep, wrap) {\n  wrap = wrap || ''\n\n  var params = Object.keys(oa).filter(function (i) {\n    return i !== 'realm' && i !== 'oauth_signature'\n  }).sort()\n\n  if (oa.realm) {\n    params.splice(0, 0, 'realm')\n  }\n  params.push('oauth_signature')\n\n  return params.map(function (i) {\n    return i + '=' + wrap + oauth.rfc3986(oa[i]) + wrap\n  }).join(sep)\n}\n\nOAuth.prototype.onRequest = function (_oauth) {\n  var self = this\n  self.params = _oauth\n\n  var uri = self.request.uri || {}\n    , method = self.request.method || ''\n    , headers = caseless(self.request.headers)\n    , body = self.request.body || ''\n    , qsLib = self.request.qsLib || qs\n\n  var form\n    , query\n    , contentType = headers.get('content-type') || ''\n    , formContentType = 'application/x-www-form-urlencoded'\n    , transport = _oauth.transport_method || 'header'\n\n  if (contentType.slice(0, formContentType.length) === formContentType) {\n    contentType = formContentType\n    form = body\n  }\n  if (uri.query) {\n    query = uri.query\n  }\n  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {\n    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +\n      'and content-type ' + formContentType))\n  }\n\n  if (!form && typeof _oauth.body_hash === 'boolean') {\n    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString())\n  }\n\n  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib)\n\n  switch (transport) {\n    case 'header':\n      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '\"'))\n      break\n\n    case 'query':\n      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&')\n      self.request.uri = url.parse(href)\n      self.request.path = self.request.uri.path\n      break\n\n    case 'body':\n      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&')\n      break\n\n    default:\n      self.request.emit('error', new Error('oauth: transport_method invalid'))\n  }\n}\n\nexports.OAuth = OAuth\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/multipart.js":"'use strict'\n\nvar uuid = require('node-uuid')\n  , CombinedStream = require('combined-stream')\n  , isstream = require('isstream')\n\n\nfunction Multipart (request) {\n  this.request = request\n  this.boundary = uuid()\n  this.chunked = false\n  this.body = null\n}\n\nMultipart.prototype.isChunked = function (options) {\n  var self = this\n    , chunked = false\n    , parts = options.data || options\n\n  if (!parts.forEach) {\n    self.request.emit('error', new Error('Argument error, options.multipart.'))\n  }\n\n  if (options.chunked !== undefined) {\n    chunked = options.chunked\n  }\n\n  if (self.request.getHeader('transfer-encoding') === 'chunked') {\n    chunked = true\n  }\n\n  if (!chunked) {\n    parts.forEach(function (part) {\n      if (typeof part.body === 'undefined') {\n        self.request.emit('error', new Error('Body attribute missing in multipart.'))\n      }\n      if (isstream(part.body)) {\n        chunked = true\n      }\n    })\n  }\n\n  return chunked\n}\n\nMultipart.prototype.setHeaders = function (chunked) {\n  var self = this\n\n  if (chunked && !self.request.hasHeader('transfer-encoding')) {\n    self.request.setHeader('transfer-encoding', 'chunked')\n  }\n\n  var header = self.request.getHeader('content-type')\n\n  if (!header || header.indexOf('multipart') === -1) {\n    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary)\n  } else {\n    if (header.indexOf('boundary') !== -1) {\n      self.boundary = header.replace(/.*boundary=([^\\s;]+).*/, '$1')\n    } else {\n      self.request.setHeader('content-type', header + '; boundary=' + self.boundary)\n    }\n  }\n}\n\nMultipart.prototype.build = function (parts, chunked) {\n  var self = this\n  var body = chunked ? new CombinedStream() : []\n\n  function add (part) {\n    if (typeof part === 'number') {\n      part = part.toString()\n    }\n    return chunked ? body.append(part) : body.push(new Buffer(part))\n  }\n\n  if (self.request.preambleCRLF) {\n    add('\\r\\n')\n  }\n\n  parts.forEach(function (part) {\n    var preamble = '--' + self.boundary + '\\r\\n'\n    Object.keys(part).forEach(function (key) {\n      if (key === 'body') { return }\n      preamble += key + ': ' + part[key] + '\\r\\n'\n    })\n    preamble += '\\r\\n'\n    add(preamble)\n    add(part.body)\n    add('\\r\\n')\n  })\n  add('--' + self.boundary + '--')\n\n  if (self.request.postambleCRLF) {\n    add('\\r\\n')\n  }\n\n  return body\n}\n\nMultipart.prototype.onRequest = function (options) {\n  var self = this\n\n  var chunked = self.isChunked(options)\n    , parts = options.data || options\n\n  self.setHeaders(chunked)\n  self.chunked = chunked\n  self.body = self.build(parts, chunked)\n}\n\nexports.Multipart = Multipart\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/redirect.js":"'use strict'\n\nvar url = require('url')\nvar isUrl = /^https?:/\n\nfunction Redirect (request) {\n  this.request = request\n  this.followRedirect = true\n  this.followRedirects = true\n  this.followAllRedirects = false\n  this.allowRedirect = function () {return true}\n  this.maxRedirects = 10\n  this.redirects = []\n  this.redirectsFollowed = 0\n  this.removeRefererHeader = false\n}\n\nRedirect.prototype.onRequest = function (options) {\n  var self = this\n\n  if (options.maxRedirects !== undefined) {\n    self.maxRedirects = options.maxRedirects\n  }\n  if (typeof options.followRedirect === 'function') {\n    self.allowRedirect = options.followRedirect\n  }\n  if (options.followRedirect !== undefined) {\n    self.followRedirects = !!options.followRedirect\n  }\n  if (options.followAllRedirects !== undefined) {\n    self.followAllRedirects = options.followAllRedirects\n  }\n  if (self.followRedirects || self.followAllRedirects) {\n    self.redirects = self.redirects || []\n  }\n  if (options.removeRefererHeader !== undefined) {\n    self.removeRefererHeader = options.removeRefererHeader\n  }\n}\n\nRedirect.prototype.redirectTo = function (response) {\n  var self = this\n    , request = self.request\n\n  var redirectTo = null\n  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {\n    var location = response.caseless.get('location')\n    request.debug('redirect', location)\n\n    if (self.followAllRedirects) {\n      redirectTo = location\n    } else if (self.followRedirects) {\n      switch (request.method) {\n        case 'PATCH':\n        case 'PUT':\n        case 'POST':\n        case 'DELETE':\n          // Do not follow redirects\n          break\n        default:\n          redirectTo = location\n          break\n      }\n    }\n  } else if (response.statusCode === 401) {\n    var authHeader = request._auth.onResponse(response)\n    if (authHeader) {\n      request.setHeader('authorization', authHeader)\n      redirectTo = request.uri\n    }\n  }\n  return redirectTo\n}\n\nRedirect.prototype.onResponse = function (response) {\n  var self = this\n    , request = self.request\n\n  var redirectTo = self.redirectTo(response)\n  if (!redirectTo || !self.allowRedirect.call(request, response)) {\n    return false\n  }\n\n  request.debug('redirect to', redirectTo)\n\n  // ignore any potential response body.  it cannot possibly be useful\n  // to us at this point.\n  // response.resume should be defined, but check anyway before calling. Workaround for browserify.\n  if (response.resume) {\n    response.resume()\n  }\n\n  if (self.redirectsFollowed >= self.maxRedirects) {\n    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href))\n    return false\n  }\n  self.redirectsFollowed += 1\n\n  if (!isUrl.test(redirectTo)) {\n    redirectTo = url.resolve(request.uri.href, redirectTo)\n  }\n\n  var uriPrev = request.uri\n  request.uri = url.parse(redirectTo)\n\n  // handle the case where we change protocol from https to http or vice versa\n  if (request.uri.protocol !== uriPrev.protocol) {\n    delete request.agent\n  }\n\n  self.redirects.push(\n    { statusCode : response.statusCode\n    , redirectUri: redirectTo\n    }\n  )\n  if (self.followAllRedirects && request.method !== 'HEAD'\n    && response.statusCode !== 401 && response.statusCode !== 307) {\n    request.method = 'GET'\n  }\n  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215\n  delete request.src\n  delete request.req\n  delete request._started\n  if (response.statusCode !== 401 && response.statusCode !== 307) {\n    // Remove parameters from the previous response, unless this is the second request\n    // for a server that requires digest authentication.\n    delete request.body\n    delete request._form\n    if (request.headers) {\n      request.removeHeader('host')\n      request.removeHeader('content-type')\n      request.removeHeader('content-length')\n      if (request.uri.hostname !== request.originalHost.split(':')[0]) {\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of curl:\n        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710\n        request.removeHeader('authorization')\n      }\n    }\n  }\n\n  if (!self.removeRefererHeader) {\n    request.setHeader('referer', uriPrev.href)\n  }\n\n  request.emit('redirect')\n\n  request.init()\n\n  return true\n}\n\nexports.Redirect = Redirect\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/request/lib/tunnel.js":"'use strict'\n\nvar url = require('url')\n  , tunnel = require('tunnel-agent')\n\nvar defaultProxyHeaderWhiteList = [\n  'accept',\n  'accept-charset',\n  'accept-encoding',\n  'accept-language',\n  'accept-ranges',\n  'cache-control',\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-md5',\n  'content-range',\n  'content-type',\n  'connection',\n  'date',\n  'expect',\n  'max-forwards',\n  'pragma',\n  'referer',\n  'te',\n  'user-agent',\n  'via'\n]\n\nvar defaultProxyHeaderExclusiveList = [\n  'proxy-authorization'\n]\n\nfunction constructProxyHost(uriObject) {\n  var port = uriObject.port\n    , protocol = uriObject.protocol\n    , proxyHost = uriObject.hostname + ':'\n\n  if (port) {\n    proxyHost += port\n  } else if (protocol === 'https:') {\n    proxyHost += '443'\n  } else {\n    proxyHost += '80'\n  }\n\n  return proxyHost\n}\n\nfunction constructProxyHeaderWhiteList(headers, proxyHeaderWhiteList) {\n  var whiteList = proxyHeaderWhiteList\n    .reduce(function (set, header) {\n      set[header.toLowerCase()] = true\n      return set\n    }, {})\n\n  return Object.keys(headers)\n    .filter(function (header) {\n      return whiteList[header.toLowerCase()]\n    })\n    .reduce(function (set, header) {\n      set[header] = headers[header]\n      return set\n    }, {})\n}\n\nfunction constructTunnelOptions (request, proxyHeaders) {\n  var proxy = request.proxy\n\n  var tunnelOptions = {\n    proxy : {\n      host      : proxy.hostname,\n      port      : +proxy.port,\n      proxyAuth : proxy.auth,\n      headers   : proxyHeaders\n    },\n    headers            : request.headers,\n    ca                 : request.ca,\n    cert               : request.cert,\n    key                : request.key,\n    passphrase         : request.passphrase,\n    pfx                : request.pfx,\n    ciphers            : request.ciphers,\n    rejectUnauthorized : request.rejectUnauthorized,\n    secureOptions      : request.secureOptions,\n    secureProtocol     : request.secureProtocol\n  }\n\n  return tunnelOptions\n}\n\nfunction constructTunnelFnName(uri, proxy) {\n  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http')\n  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http')\n  return [uriProtocol, proxyProtocol].join('Over')\n}\n\nfunction getTunnelFn(request) {\n  var uri = request.uri\n  var proxy = request.proxy\n  var tunnelFnName = constructTunnelFnName(uri, proxy)\n  return tunnel[tunnelFnName]\n}\n\n\nfunction Tunnel (request) {\n  this.request = request\n  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList\n  this.proxyHeaderExclusiveList = []\n  if (typeof request.tunnel !== 'undefined') {\n    this.tunnelOverride = request.tunnel\n  }\n}\n\nTunnel.prototype.isEnabled = function () {\n  var self = this\n    , request = self.request\n  // Tunnel HTTPS by default. Allow the user to override this setting.\n\n  // If self.tunnelOverride is set (the user specified a value), use it.\n  if (typeof self.tunnelOverride !== 'undefined') {\n    return self.tunnelOverride\n  }\n\n  // If the destination is HTTPS, tunnel.\n  if (request.uri.protocol === 'https:') {\n    return true\n  }\n\n  // Otherwise, do not use tunnel.\n  return false\n}\n\nTunnel.prototype.setup = function (options) {\n  var self = this\n    , request = self.request\n\n  options = options || {}\n\n  if (typeof request.proxy === 'string') {\n    request.proxy = url.parse(request.proxy)\n  }\n\n  if (!request.proxy || !request.tunnel) {\n    return false\n  }\n\n  // Setup Proxy Header Exclusive List and White List\n  if (options.proxyHeaderWhiteList) {\n    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList\n  }\n  if (options.proxyHeaderExclusiveList) {\n    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList\n  }\n\n  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList)\n  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList)\n\n  // Setup Proxy Headers and Proxy Headers Host\n  // Only send the Proxy White Listed Header names\n  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList)\n  proxyHeaders.host = constructProxyHost(request.uri)\n\n  proxyHeaderExclusiveList.forEach(request.removeHeader, request)\n\n  // Set Agent from Tunnel Data\n  var tunnelFn = getTunnelFn(request)\n  var tunnelOptions = constructTunnelOptions(request, proxyHeaders)\n  request.agent = tunnelFn(tunnelOptions)\n\n  return true\n}\n\nTunnel.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList\nTunnel.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList\nexports.Tunnel = Tunnel\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-feedparser/node_modules/tunnel-agent/index.js":"'use strict'\n\nvar net = require('net')\n  , tls = require('tls')\n  , http = require('http')\n  , https = require('https')\n  , events = require('events')\n  , assert = require('assert')\n  , util = require('util')\n  ;\n\nexports.httpOverHttp = httpOverHttp\nexports.httpsOverHttp = httpsOverHttp\nexports.httpOverHttps = httpOverHttps\nexports.httpsOverHttps = httpsOverHttps\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  return agent\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  return agent\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  agent.createSocket = createSecureSocket\n  agent.defaultPort = 443\n  return agent\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.proxyOptions = self.options.proxy || {}\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n  self.requests = []\n  self.sockets = []\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i]\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1)\n        pending.request.onSocket(socket)\n        return\n      }\n    }\n    socket.destroy()\n    self.removeSocket(socket)\n  })\n}\nutil.inherits(TunnelingAgent, events.EventEmitter)\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, options) {\n  var self = this\n\n   // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: options.host, port: options.port, request: req})\n    return\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createConnection({host: options.host, port: options.port, request: req})\n}\n\nTunnelingAgent.prototype.createConnection = function createConnection(pending) {\n  var self = this\n\n  self.createSocket(pending, function(socket) {\n    socket.on('free', onFree)\n    socket.on('close', onCloseOrRemove)\n    socket.on('agentRemove', onCloseOrRemove)\n    pending.request.onSocket(socket)\n\n    function onFree() {\n      self.emit('free', socket, pending.host, pending.port)\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket)\n      socket.removeListener('free', onFree)\n      socket.removeListener('close', onCloseOrRemove)\n      socket.removeListener('agentRemove', onCloseOrRemove)\n    }\n  })\n}\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this\n  var placeholder = {}\n  self.sockets.push(placeholder)\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, \n    { method: 'CONNECT'\n    , path: options.host + ':' + options.port\n    , agent: false\n    }\n  )\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {}\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64')\n  }\n\n  debug('making CONNECT request')\n  var connectReq = self.request(connectOptions)\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\n  connectReq.once('response', onResponse) // for v0.6\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\n  connectReq.once('connect', onConnect)   // for v0.7 or later\n  connectReq.once('error', onError)\n  connectReq.end()\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head)\n    })\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners()\n    socket.removeAllListeners()\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0)\n      debug('tunneling connection has established')\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\n      cb(socket)\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n      error.code = 'ECONNRESET'\n      options.request.emit('error', error)\n      self.removeSocket(placeholder)\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners()\n\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n    error.code = 'ECONNRESET'\n    options.request.emit('error', error)\n    self.removeSocket(placeholder)\n  }\n}\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) return\n  \n  this.sockets.splice(pos, 1)\n\n  var pending = this.requests.shift()\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createConnection(pending)\n  }\n}\n\nfunction createSecureSocket(options, cb) {\n  var self = this\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options, \n      { servername: options.host\n      , socket: socket\n      }\n    ))\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket\n    cb(secureSocket)\n  })\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i]\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides)\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j]\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k]\n        }\n      }\n    }\n  }\n  return target\n}\n\n\nvar debug\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments)\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0]\n    } else {\n      args.unshift('TUNNEL:')\n    }\n    console.error.apply(console, args)\n  }\n} else {\n  debug = function() {}\n}\nexports.debug = debug // for test\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-rbe/rbe.js":"\nmodule.exports = function(RED) {\n    \"use strict\";\n    function RbeNode(n) {\n        RED.nodes.createNode(this,n);\n        this.func = n.func || \"rbe\";\n        this.gap = n.gap || \"0\";\n        this.start = n.start || '';\n        this.inout = n.inout || \"out\";\n        this.pc = false;\n        if (this.gap.substr(-1) === \"%\") {\n            this.pc = true;\n            this.gap = parseFloat(this.gap);\n        }\n        this.g = this.gap;\n        var node = this;\n\n        node.previous = {};\n        this.on(\"input\",function(msg) {\n            if (msg.hasOwnProperty(\"payload\")) {\n                var t = msg.topic || \"_no_topic\";\n                if (this.func === \"rbe\") {\n                    if (typeof(msg.payload) === \"object\") {\n                        if (typeof(node.previous[t]) !== \"object\") { node.previous[t] = {}; }\n                        if (!RED.util.compareObjects(msg.payload, node.previous[t])) {\n                            node.previous[t] = msg.payload;\n                            node.send(msg);\n                        }\n                    }\n                    else {\n                        if (msg.payload !== node.previous[t]) {\n                            node.previous[t] = msg.payload;\n                            node.send(msg);\n                        }\n                    }\n                }\n                else {\n                    var n = parseFloat(msg.payload);\n                    if (!isNaN(n)) {\n                        if ((typeof node.previous[t] === 'undefined') && (this.func === \"narrowband\")) {\n                            if (node.start === '') { node.previous[t] = n; }\n                            else { node.previous[t] = node.start; }\n                        }\n                        if (node.pc) { node.gap = (node.previous[t] * node.g / 100) || 0; }\n                        else { node.gap = Number(node.gap); }\n                        if ((node.previous[t] === undefined) && (node.func === \"narrowbandEq\")) { node.previous[t] = n; }\n                        if (node.previous[t] === undefined) { node.previous[t] = n - node.gap; }\n                        if (Math.abs(n - node.previous[t]) === node.gap) {\n                            if (this.func === \"deadbandEq\") {\n                                if (node.inout === \"out\") { node.previous[t] = n; }\n                                node.send(msg);\n                            }\n                        }\n                        else if (Math.abs(n - node.previous[t]) > node.gap) {\n                            if (this.func === \"deadband\") {\n                                if (node.inout === \"out\") { node.previous[t] = n; }\n                                node.send(msg);\n                            }\n                        }\n                        else if (Math.abs(n - node.previous[t]) < node.gap) {\n                            if ((this.func === \"narrowband\")||(this.func === \"narrowbandEq\")) {\n                                if (node.inout === \"out\") { node.previous[t] = n; }\n                                node.send(msg);\n                            }\n                        }\n                        if (node.inout === \"in\") { node.previous[t] = n; }\n                    }\n                    else {\n                        node.warn(RED._(\"rbe.warn.nonumber\"));\n                    }\n                }\n            } // ignore msg with no payload property.\n        });\n    }\n    RED.nodes.registerType(\"rbe\",RbeNode);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node_modules/node-red-node-twitter/27-twitter.js":"\nmodule.exports = function(RED) {\n    \"use strict\";\n    var Ntwitter = require('twitter-ng');\n    var OAuth= require('oauth').OAuth;\n    var request = require('request');\n    var twitterRateTimeout;\n\n    function TwitterNode(n) {\n        RED.nodes.createNode(this,n);\n        this.screen_name = n.screen_name;\n    }\n    RED.nodes.registerType(\"twitter-credentials\",TwitterNode,{\n        credentials: {\n            screen_name: {type:\"text\"},\n            access_token: {type: \"password\"},\n            access_token_secret: {type:\"password\"}\n        }\n    });\n\n\n    /**\n     * Populate msg.location based on data found in msg.tweet.\n     */\n    function addLocationToTweet(msg) {\n        if (msg.tweet) {\n            if (msg.tweet.geo) { // if geo is set, always set location from geo\n                if (msg.tweet.geo.coordinates && msg.tweet.geo.coordinates.length === 2) {\n                    if (!msg.location) { msg.location = {}; }\n                    // coordinates[0] is lat, coordinates[1] is lon\n                    msg.location.lat = msg.tweet.geo.coordinates[0];\n                    msg.location.lon = msg.tweet.geo.coordinates[1];\n                    msg.location.icon = \"twitter\";\n                }\n            }\n            else if (msg.tweet.coordinates) { // otherwise attempt go get it from coordinates\n                if (msg.tweet.coordinates.coordinates && msg.tweet.coordinates.coordinates.length === 2) {\n                    if (!msg.location) { msg.location = {}; }\n                    // WARNING! coordinates[1] is lat, coordinates[0] is lon!!!\n                    msg.location.lat = msg.tweet.coordinates.coordinates[1];\n                    msg.location.lon = msg.tweet.coordinates.coordinates[0];\n                    msg.location.icon = \"twitter\";\n                }\n            } // if none of these found then just do nothing\n        } // if no msg.tweet then just do nothing\n    }\n\n    function TwitterInNode(n) {\n        RED.nodes.createNode(this,n);\n        this.active = true;\n        this.user = n.user;\n        //this.tags = n.tags.replace(/ /g,'');\n        this.tags = n.tags;\n        this.twitter = n.twitter;\n        this.topic = n.topic||\"tweets\";\n        this.twitterConfig = RED.nodes.getNode(this.twitter);\n        var credentials = RED.nodes.getCredentials(this.twitter);\n\n        if (credentials && credentials.screen_name == this.twitterConfig.screen_name) {\n            var twit = new Ntwitter({\n                consumer_key: \"OKjYEd1ef2bfFolV25G5nQ\",\n                consumer_secret: \"meRsltCktVMUI8gmggpXett7WBLd1k0qidYazoML6g\",\n                access_token_key: credentials.access_token,\n                access_token_secret: credentials.access_token_secret\n            });\n\n            //setInterval(function() {\n            //        twit.get(\"/application/rate_limit_status.json\",null,function(err,cb) {\n            //                console.log(\"direct_messages:\",cb[\"resources\"][\"direct_messages\"]);\n            //        });\n            //\n            //},10000);\n\n            var node = this;\n            if (this.user === \"user\") {\n                node.poll_ids = [];\n                node.since_ids = {};\n                node.status({});\n                var users = node.tags.split(\",\");\n                if (users === '') { node.warn(RED._(\"twitter.warn.nousers\")); }\n                //if (users.length === 0) { node.warn(RED._(\"twitter.warn.nousers\")); }\n                else {\n                    for (var i=0; i<users.length; i++) {\n                        var user = users[i].replace(\" \",\"\");\n                        twit.getUserTimeline({\n                            screen_name:user,\n                            trim_user:0,\n                            count:1\n                        },(function() {\n                            var u = user+\"\";\n                            return function(err,cb) {\n                                if (err) {\n                                    node.error(err);\n                                    return;\n                                }\n                                if (cb[0]) {\n                                    node.since_ids[u] = cb[0].id_str;\n                                }\n                                else {\n                                    node.since_ids[u] = '0';\n                                }\n                                node.poll_ids.push(setInterval(function() {\n                                    twit.getUserTimeline({\n                                        screen_name:u,\n                                        trim_user:0,\n                                        since_id:node.since_ids[u]\n                                    }, function(err,cb) {\n                                        if (cb) {\n                                            for (var t=cb.length-1; t>=0; t-=1) {\n                                                var tweet = cb[t];\n                                                var where = tweet.user.location;\n                                                var la = tweet.lang || tweet.user.lang;\n                                                var msg = { topic:node.topic+\"/\"+tweet.user.screen_name, payload:tweet.text, lang:la, tweet:tweet };\n                                                if (where) {\n                                                    msg.location = {place:where};\n                                                    addLocationToTweet(msg);\n                                                }\n                                                node.send(msg);\n                                                if (t === 0) {\n                                                    node.since_ids[u] = tweet.id_str;\n                                                }\n                                            }\n                                        }\n                                        if (err) {\n                                            node.error(err);\n                                        }\n                                    });\n                                },60000));\n                            }\n                        }()));\n                    }\n                }\n            }\n            else if (this.user === \"dm\") {\n                node.poll_ids = [];\n                node.status({});\n                twit.getDirectMessages({\n                    screen_name:node.twitterConfig.screen_name,\n                    trim_user:0,\n                    count:1\n                },function(err,cb) {\n                    if (err) {\n                        node.error(err);\n                        return;\n                    }\n                    if (cb[0]) {\n                        node.since_id = cb[0].id_str;\n                    }\n                    else {\n                        node.since_id = '0';\n                    }\n                    node.poll_ids.push(setInterval(function() {\n                        twit.getDirectMessages({\n                            screen_name:node.twitterConfig.screen_name,\n                            trim_user:0,\n                            since_id:node.since_id\n                        },function(err,cb) {\n                                if (cb) {\n                                    for (var t=cb.length-1;t>=0;t-=1) {\n                                        var tweet = cb[t];\n                                        var where = tweet.sender.location;\n                                        var la = tweet.lang || tweet.sender.lang;\n                                        var msg = { topic:node.topic+\"/\"+tweet.sender.screen_name, payload:tweet.text, lang:la, tweet:tweet };\n                                        if (where) {\n                                            msg.location = {place:where};\n                                            addLocationToTweet(msg);\n                                        }\n                                        node.send(msg);\n                                        if (t === 0) {\n                                            node.since_id = tweet.id_str;\n                                        }\n                                    }\n                                }\n                                if (err) {\n                                    node.error(err);\n                                }\n                            });\n                    },120000));\n                });\n            }\n            else if (this.user === \"event\") {\n                try {\n                    var thingu = 'user';\n                    var setupEvStream = function() {\n                        if (node.active) {\n                            twit.stream(thingu, st, function(stream) {\n                                node.status({fill:\"green\", shape:\"dot\", text:\" \"});\n                                node.stream = stream;\n                                stream.on('data', function(tweet) {\n                                    if (tweet.event !== undefined) {\n                                        var where = tweet.source.location;\n                                        var la = tweet.source.lang;\n                                        var msg = { topic:node.topic+\"/\"+tweet.source.screen_name, payload:tweet.event, lang:la, tweet:tweet };\n                                        if (where) {\n                                            msg.location = {place:where};\n                                            addLocationToTweet(msg);\n                                        }\n                                        node.send(msg);\n                                    }\n                                });\n                                stream.on('limit', function(tweet) {\n                                    node.status({fill:\"grey\", shape:\"dot\", text:\" \"});\n                                    node.tout2 = setTimeout(function() { node.status({fill:\"green\", shape:\"dot\", text:\" \"}); },10000);\n                                });\n                                stream.on('error', function(tweet,rc) {\n                                    //console.log(\"ERRO\",rc,tweet);\n                                    if (rc == 420) {\n                                        node.status({fill:\"red\", shape:\"ring\", text:RED._(\"twitter.errors.ratelimit\")});\n                                    }\n                                    else {\n                                        node.status({fill:\"red\", shape:\"ring\", text:\" \"});\n                                        node.warn(RED._(\"twitter.errors.streamerror\",{error:tweet.toString(),rc:rc}));\n                                    }\n                                    twitterRateTimeout = Date.now() + retry;\n                                    if (node.restart) {\n                                        node.tout = setTimeout(function() { setupEvStream() },retry);\n                                    }\n                                });\n                                stream.on('destroy', function (response) {\n                                    //console.log(\"DEST\",response)\n                                    twitterRateTimeout = Date.now() + 15000;\n                                    if (node.restart) {\n                                        node.status({fill:\"red\", shape:\"dot\", text:\" \"});\n                                        node.warn(RED._(\"twitter.errors.unexpectedend\"));\n                                        node.tout = setTimeout(function() { setupEvStream() },15000);\n                                    }\n                                });\n                            });\n                        }\n                    }\n                    setupEvStream();\n                }\n                catch (err) {\n                    node.error(err);\n                }\n            }\n            else {\n                try {\n                    var thing = 'statuses/filter';\n                    var tags = node.tags;\n                    var st = { track: [tags] };\n\n                    var setupStream = function() {\n                        if (node.restart) {\n                            node.status({fill:\"green\", shape:\"dot\", text:(tags||\" \")});\n                            twit.stream(thing, st, function(stream) {\n                                //console.log(\"ST\",st);\n                                node.stream = stream;\n                                var retry = 60000; // 60 secs backoff for now\n                                stream.on('data', function(tweet) {\n                                    if (tweet.user !== undefined) {\n                                        var where = tweet.user.location;\n                                        var la = tweet.lang || tweet.user.lang;\n                                        var msg = { topic:node.topic+\"/\"+tweet.user.screen_name, payload:tweet.text, lang:la, tweet:tweet };\n                                        if (where) {\n                                            msg.location = {place:where};\n                                            addLocationToTweet(msg);\n                                        }\n                                        node.send(msg);\n                                        //node.status({fill:\"green\", shape:\"dot\", text:(tags||\" \")});\n                                    }\n                                });\n                                stream.on('limit', function(tweet) {\n                                    //node.status({fill:\"grey\", shape:\"dot\", text:RED._(\"twitter.errors.limitrate\")});\n                                    node.status({fill:\"grey\", shape:\"dot\", text:(tags||\" \")});\n                                    node.tout2 = setTimeout(function() { node.status({fill:\"green\", shape:\"dot\", text:(tags||\" \")}); },10000);\n                                });\n                                stream.on('error', function(tweet,rc) {\n                                    //console.log(\"ERRO\",rc,tweet);\n                                    if (rc == 420) {\n                                        node.status({fill:\"red\", shape:\"ring\", text:RED._(\"twitter.errors.ratelimit\")});\n                                    }\n                                    else {\n                                        node.status({fill:\"red\", shape:\"ring\", text:tweet.toString()});\n                                        node.warn(RED._(\"twitter.errors.streamerror\",{error:tweet.toString(),rc:rc}));\n                                    }\n                                    twitterRateTimeout = Date.now() + retry;\n                                    if (node.restart) {\n                                        node.tout = setTimeout(function() { setupStream() },retry);\n                                    }\n                                });\n                                stream.on('destroy', function (response) {\n                                    //console.log(\"DEST\",response)\n                                    twitterRateTimeout = Date.now() + 15000;\n                                    if (node.restart) {\n                                        node.status({fill:\"red\", shape:\"dot\", text:\" \"});\n                                        node.warn(RED._(\"twitter.errors.unexpectedend\"));\n                                        node.tout = setTimeout(function() { setupStream() },15000);\n                                    }\n                                });\n                            });\n                        }\n                    }\n\n                    // ask for users stream instead of public\n                    if (this.user === \"true\") {\n                        thing = 'user';\n                        // twit.getFriendsIds(node.twitterConfig.screen_name.substr(1), function(err,list) {\n                        //     friends = list;\n                        // });\n                        st = null;\n                    }\n\n                    // if 4 numeric tags that look like a geo area then set geo area\n                    var bits = node.tags.split(\",\");\n                    if (bits.length == 4) {\n                        if ((Number(bits[0]) < Number(bits[2])) && (Number(bits[1]) < Number(bits[3]))) {\n                            st = { locations: node.tags };\n                            node.log(RED._(\"twitter.status.using-geo\",{location:node.tags.toString()}));\n                        }\n                    }\n\n                    // all public tweets\n                    if (this.user === \"false\") {\n                        node.on(\"input\", function(msg) {\n                            if (this.tags === '') {\n                                if (node.tout) { clearTimeout(node.tout); }\n                                if (node.tout2) { clearTimeout(node.tout2); }\n                                if (this.stream) {\n                                    this.restart = false;\n                                    node.stream.removeAllListeners();\n                                    this.stream.destroy();\n                                }\n                                if ((typeof msg.payload === \"string\") && (msg.payload !== \"\")) {\n                                    st = { track:[msg.payload] };\n                                    tags = msg.payload;\n\n                                    this.restart = true;\n                                    if ((twitterRateTimeout - Date.now()) > 0 ) {\n                                        node.status({fill:\"red\", shape:\"ring\", text:tags});\n                                        node.tout = setTimeout(function() {\n                                            setupStream();\n                                        }, twitterRateTimeout - Date.now() );\n                                    }\n                                    else {\n                                        setupStream();\n                                    }\n                                }\n                                else {\n                                    node.status({fill:\"yellow\", shape:\"ring\", text:RED._(\"twitter.warn.waiting\")});\n                                }\n                            }\n                        });\n                    }\n\n                    // wait for input or start the stream\n                    if ((this.user === \"false\") && (tags === '')) {\n                        node.status({fill:\"yellow\", shape:\"ring\", text:RED._(\"twitter.warn.waiting\")});\n                    }\n                    else {\n                        this.restart = true;\n                        setupStream();\n                    }\n                }\n                catch (err) {\n                    node.error(err);\n                }\n            }\n        }\n        else {\n            this.error(RED._(\"twitter.errors.missingcredentials\"));\n        }\n\n        this.on('close', function() {\n            if (node.tout) { clearTimeout(node.tout); }\n            if (node.tout2) { clearTimeout(node.tout2); }\n            if (this.stream) {\n                this.restart = false;\n                node.stream.removeAllListeners();\n                this.stream.destroy();\n            }\n            if (this.poll_ids) {\n                for (var i=0;i<this.poll_ids.length;i++) {\n                    clearInterval(this.poll_ids[i]);\n                }\n            }\n        });\n    }\n    RED.nodes.registerType(\"twitter in\",TwitterInNode);\n\n\n    function TwitterOutNode(n) {\n        RED.nodes.createNode(this,n);\n        this.topic = n.topic;\n        this.twitter = n.twitter;\n        this.twitterConfig = RED.nodes.getNode(this.twitter);\n        var credentials = RED.nodes.getCredentials(this.twitter);\n        var node = this;\n\n        if (credentials && credentials.screen_name == this.twitterConfig.screen_name) {\n            var twit = new Ntwitter({\n                consumer_key: \"OKjYEd1ef2bfFolV25G5nQ\",\n                consumer_secret: \"meRsltCktVMUI8gmggpXett7WBLd1k0qidYazoML6g\",\n                access_token_key: credentials.access_token,\n                access_token_secret: credentials.access_token_secret\n            });\n            node.on(\"input\", function(msg) {\n                if (msg.hasOwnProperty(\"payload\")) {\n                    node.status({fill:\"blue\",shape:\"dot\",text:\"twitter.status.tweeting\"});\n\n                    if (msg.payload.length > 140) {\n                        msg.payload = msg.payload.slice(0,139);\n                        node.warn(RED._(\"twitter.errors.truncated\"));\n                    }\n\n                    if (msg.media && Buffer.isBuffer(msg.media)) {\n                        var apiUrl = \"https://api.twitter.com/1.1/statuses/update_with_media.json\";\n                        var signedUrl = oa.signUrl(apiUrl,\n                            credentials.access_token,\n                            credentials.access_token_secret,\n                            \"POST\");\n\n                        var r = request.post(signedUrl,function(err,httpResponse,body) {\n                            if (err) {\n                                node.error(err,msg);\n                                node.status({fill:\"red\",shape:\"ring\",text:\"twitter.status.failed\"});\n                            }\n                            else {\n                                var response = JSON.parse(body);\n                                if (response.errors) {\n                                    var errorList = response.errors.map(function(er) { return er.code+\": \"+er.message }).join(\", \");\n                                    node.error(RED._(\"twitter.errors.sendfail\",{error:errorList}),msg);\n                                    node.status({fill:\"red\",shape:\"ring\",text:\"twitter.status.failed\"});\n                                }\n                                else {\n                                    node.status({});\n                                }\n                            }\n                        });\n                        var form = r.form();\n                        form.append(\"status\",msg.payload);\n                        form.append(\"media[]\",msg.media,{filename:\"image\"});\n\n                    }\n                    else {\n                        if (typeof msg.params === 'undefined') { msg.params = {}; }\n                        twit.updateStatus(msg.payload, msg.params, function (err, data) {\n                            if (err) {\n                                node.status({fill:\"red\",shape:\"ring\",text:\"twitter.status.failed\"});\n                                node.error(err,msg);\n                            }\n                            node.status({});\n                        });\n                    }\n                }\n                else { node.warn(RED._(\"twitter.errors.nopayload\")); }\n            });\n        }\n    }\n    RED.nodes.registerType(\"twitter out\",TwitterOutNode);\n\n    var oa = new OAuth(\n        \"https://api.twitter.com/oauth/request_token\",\n        \"https://api.twitter.com/oauth/access_token\",\n        \"OKjYEd1ef2bfFolV25G5nQ\",\n        \"meRsltCktVMUI8gmggpXett7WBLd1k0qidYazoML6g\",\n        \"1.0\",\n        null,\n        \"HMAC-SHA1\"\n    );\n\n    RED.httpAdmin.get('/twitter-credentials/:id/auth', function(req, res) {\n        var credentials = {};\n        oa.getOAuthRequestToken({\n            oauth_callback: req.query.callback\n        },function(error, oauth_token, oauth_token_secret, results) {\n            if (error) {\n                var err = {statusCode: 401, data: \"dummy error\"};\n                var resp = RED._(\"twitter.errors.oautherror\",{statusCode: err.statusCode, errorData: err.data});\n                res.send(resp)\n            }\n            else {\n                credentials.oauth_token = oauth_token;\n                credentials.oauth_token_secret = oauth_token_secret;\n                res.redirect('https://api.twitter.com/oauth/authorize?oauth_token='+oauth_token)\n                RED.nodes.addCredentials(req.params.id,credentials);\n            }\n        });\n    });\n\n    RED.httpAdmin.get('/twitter-credentials/:id/auth/callback', function(req, res, next) {\n        var credentials = RED.nodes.getCredentials(req.params.id);\n        credentials.oauth_verifier = req.query.oauth_verifier;\n\n        oa.getOAuthAccessToken(\n            credentials.oauth_token,\n            credentials.token_secret,\n            credentials.oauth_verifier,\n            function(error, oauth_access_token, oauth_access_token_secret, results) {\n                if (error) {\n                    RED.log.error(error);\n                    res.send(RED._(\"twitter.errors.oauthbroke\"));\n                }\n                else {\n                    credentials = {};\n                    credentials.access_token = oauth_access_token;\n                    credentials.access_token_secret = oauth_access_token_secret;\n                    credentials.screen_name = \"@\"+results.screen_name;\n                    RED.nodes.addCredentials(req.params.id,credentials);\n                    res.send(RED._(\"twitter.errors.authorized\"));\n                }\n            }\n        );\n    });\n}\n"}