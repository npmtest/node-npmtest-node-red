{"/home/travis/build/npmtest/node-npmtest-node-red/test.js":"/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/lib.npmtest_node_red.js":"/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_red = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_red = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-red && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_red */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_red\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_red.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_node_red.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_red.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_node_red.__dirname +\n                    '/lib.npmtest_node_red.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/red.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar fs = require(\"fs\");\nvar path = require('path');\n\nvar runtime = require(\"./runtime\");\nvar api = require(\"./api\");\n\nprocess.env.NODE_RED_HOME = process.env.NODE_RED_HOME || path.resolve(__dirname+\"/..\");\n\nvar nodeApp = null;\nvar adminApp = null;\nvar server = null;\nvar apiEnabled = false;\n\nfunction checkVersion(userSettings) {\n    var semver = require('semver');\n    if (!semver.satisfies(process.version,\">=4.0.0\")) {\n        // TODO: in the future, make this a hard error.\n        // var e = new Error(\"Unsupported version of node.js\");\n        // e.code = \"unsupported_version\";\n        // throw e;\n        userSettings.UNSUPPORTED_VERSION = process.version;\n    }\n}\n\nfunction checkBuild() {\n    var editorFile = path.resolve(path.join(__dirname,\"..\",\"public\",\"red\",\"red.min.js\"));\n    try {\n        var stats = fs.statSync(editorFile);\n    } catch(err) {\n        var e = new Error(\"Node-RED not built\");\n        e.code = \"not_built\";\n        throw e;\n    }\n}\n\nmodule.exports = {\n    init: function(httpServer,userSettings) {\n        if (!userSettings) {\n            userSettings = httpServer;\n            httpServer = null;\n        }\n\n        if (!userSettings.SKIP_BUILD_CHECK) {\n            checkVersion(userSettings);\n            checkBuild();\n        }\n\n        if (!userSettings.coreNodesDir) {\n            userSettings.coreNodesDir = path.resolve(path.join(__dirname,\"..\",\"nodes\"));\n        }\n\n        if (userSettings.httpAdminRoot !== false) {\n            runtime.init(userSettings,api);\n            api.init(httpServer,runtime);\n            apiEnabled = true;\n        } else {\n            runtime.init(userSettings);\n            apiEnabled = false;\n        }\n        adminApp = runtime.adminApi.adminApp;\n        nodeApp = runtime.nodeApp;\n        server = runtime.adminApi.server;\n        return;\n    },\n    start: function() {\n        return runtime.start().then(function() {\n            if (apiEnabled) {\n                return api.start();\n            }\n        });\n    },\n    stop: function() {\n        return runtime.stop().then(function() {\n            if (apiEnabled) {\n                return api.stop();\n            }\n        })\n    },\n    nodes: runtime.nodes,\n    log: runtime.log,\n    settings:runtime.settings,\n    util: runtime.util,\n    version: runtime.version,\n\n    comms: api.comms,\n    library: api.library,\n    auth: api.auth,\n\n    get app() { console.log(\"Deprecated use of RED.app - use RED.httpAdmin instead\"); return runtime.app },\n    get httpAdmin() { return adminApp },\n    get httpNode() { return nodeApp },\n    get server() { return server }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require('when');\n\nvar redNodes = require(\"./nodes\");\nvar storage = require(\"./storage\");\nvar log = require(\"./log\");\nvar i18n = require(\"./i18n\");\nvar events = require(\"./events\");\nvar settings = require(\"./settings\");\n\nvar express = require(\"express\");\nvar path = require('path');\nvar fs = require(\"fs\");\nvar os = require(\"os\");\n\nvar runtimeMetricInterval = null;\n\nvar started = false;\n\nvar stubbedExpressApp = {\n    get: function() {},\n    post: function() {},\n    put: function() {},\n    delete: function() {}\n}\nvar adminApi = {\n    library: {\n        register: function() {}\n    },\n    auth: {\n        needsPermission: function() {}\n    },\n    comms: {\n        publish: function() {}\n    },\n    adminApp: stubbedExpressApp,\n    server: {}\n}\n\nvar nodeApp;\n\nfunction init(userSettings,_adminApi) {\n    userSettings.version = getVersion();\n    log.init(userSettings);\n    settings.init(userSettings);\n\n    nodeApp = express();\n\n    if (_adminApi) {\n        adminApi = _adminApi;\n    }\n    redNodes.init(runtime);\n}\n\nvar version;\n\nfunction getVersion() {\n    if (!version) {\n        version = require(path.join(__dirname,\"..\",\"..\",\"package.json\")).version;\n        /* istanbul ignore else */\n        try {\n            fs.statSync(path.join(__dirname,\"..\",\"..\",\".git\"));\n            version += \"-git\";\n        } catch(err) {\n            // No git directory\n        }\n    }\n    return version;\n}\n\nfunction start() {\n    return i18n.init()\n        .then(function() {\n            return i18n.registerMessageCatalog(\"runtime\",path.resolve(path.join(__dirname,\"locales\")),\"runtime.json\")\n        })\n        .then(function() { return storage.init(runtime)})\n        .then(function() { return settings.load(storage)})\n        .then(function() {\n\n            if (log.metric()) {\n                runtimeMetricInterval = setInterval(function() {\n                    reportMetrics();\n                }, settings.runtimeMetricInterval||15000);\n            }\n            log.info(\"\\n\\n\"+log._(\"runtime.welcome\")+\"\\n===================\\n\");\n            if (settings.version) {\n                log.info(log._(\"runtime.version\",{component:\"Node-RED\",version:\"v\"+settings.version}));\n            }\n            log.info(log._(\"runtime.version\",{component:\"Node.js \",version:process.version}));\n            if (settings.UNSUPPORTED_VERSION) {\n                log.error(\"*****************************************************************\");\n                log.error(\"* \"+log._(\"runtime.unsupported_version\",{component:\"Node.js\",version:process.version,requires: \">=4\"})+\" *\");\n                log.error(\"*****************************************************************\");\n                events.emit(\"runtime-event\",{id:\"runtime-unsupported-version\",type:\"error\",text:\"notification.errors.unsupportedVersion\"});\n            }\n            log.info(os.type()+\" \"+os.release()+\" \"+os.arch()+\" \"+os.endianness());\n            return redNodes.load().then(function() {\n\n                var i;\n                var nodeErrors = redNodes.getNodeList(function(n) { return n.err!=null;});\n                var nodeMissing = redNodes.getNodeList(function(n) { return n.module && n.enabled && !n.loaded && !n.err;});\n                if (nodeErrors.length > 0) {\n                    log.warn(\"------------------------------------------------------\");\n                    for (i=0;i<nodeErrors.length;i+=1) {\n                        log.warn(\"[\"+nodeErrors[i].name+\"] \"+nodeErrors[i].err);\n                    }\n                    log.warn(\"------------------------------------------------------\");\n                }\n                if (nodeMissing.length > 0) {\n                    log.warn(log._(\"server.missing-modules\"));\n                    var missingModules = {};\n                    for (i=0;i<nodeMissing.length;i++) {\n                        var missing = nodeMissing[i];\n                        missingModules[missing.module] = (missingModules[missing.module]||[]).concat(missing.types);\n                    }\n                    var promises = [];\n                    for (i in missingModules) {\n                        if (missingModules.hasOwnProperty(i)) {\n                            log.warn(\" - \"+i+\": \"+missingModules[i].join(\", \"));\n                            if (settings.autoInstallModules && i != \"node-red\") {\n                                redNodes.installModule(i).otherwise(function(err) {\n                                    // Error already reported. Need the otherwise handler\n                                    // to stop the error propagating any further\n                                });\n                            }\n                        }\n                    }\n                    if (!settings.autoInstallModules) {\n                        log.info(log._(\"server.removing-modules\"));\n                        redNodes.cleanModuleList();\n                    }\n                }\n                if (settings.settingsFile) {\n                    log.info(log._(\"runtime.paths.settings\",{path:settings.settingsFile}));\n                }\n                redNodes.loadFlows().then(redNodes.startFlows);\n                started = true;\n            }).otherwise(function(err) {\n                console.log(err);\n            });\n        });\n}\n\nfunction reportMetrics() {\n    var memUsage = process.memoryUsage();\n\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.rss\",\n        value: memUsage.rss\n    });\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.heapTotal\",\n        value: memUsage.heapTotal\n    });\n    log.log({\n        level: log.METRIC,\n        event: \"runtime.memory.heapUsed\",\n        value: memUsage.heapUsed\n    });\n}\n\nfunction stop() {\n    if (runtimeMetricInterval) {\n        clearInterval(runtimeMetricInterval);\n        runtimeMetricInterval = null;\n    }\n    started = false;\n    return redNodes.stopFlows();\n}\n\nvar runtime = module.exports = {\n    init: init,\n    start: start,\n    stop: stop,\n\n    version: getVersion,\n\n    log: log,\n    i18n: i18n,\n    settings: settings,\n    storage: storage,\n    events: events,\n    nodes: redNodes,\n    util: require(\"./util\"),\n    get adminApi() { return adminApi },\n    get nodeApp() { return nodeApp },\n    isStarted: function() {\n        return started;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar registry = require(\"./registry\");\nvar credentials = require(\"./credentials\");\nvar flows = require(\"./flows\");\nvar flowUtil = require(\"./flows/util\")\nvar context = require(\"./context\");\nvar Node = require(\"./Node\");\nvar log = require(\"../log\");\n\nvar events = require(\"../events\");\n\nvar child_process = require('child_process');\n\nvar settings;\n\n/**\n * Registers a node constructor\n * @param nodeSet - the nodeSet providing the node (module/set)\n * @param type - the string type name\n * @param constructor - the constructor function for this node type\n * @param opts - optional additional options for the node\n */\nfunction registerType(nodeSet,type,constructor,opts) {\n    if (typeof type !== \"string\") {\n        // This is someone calling the api directly, rather than via the\n        // RED object provided to a node. Log a warning\n        log.warn(\"[\"+nodeSet+\"] Deprecated call to RED.runtime.nodes.registerType - node-set name must be provided as first argument\");\n        opts = constructor;\n        constructor = type;\n        type = nodeSet;\n        nodeSet = \"\";\n    }\n    if (opts && opts.credentials) {\n        credentials.register(type,opts.credentials);\n    }\n    registry.registerType(nodeSet,type,constructor);\n}\n\n/**\n * Called from a Node's constructor function, invokes the super-class\n * constructor and attaches any credentials to the node.\n * @param node the node object being created\n * @param def the instance definition for the node\n */\nfunction createNode(node,def) {\n    Node.call(node,def);\n    var id = node.id;\n    if (def._alias) {\n        id = def._alias;\n    }\n    var creds = credentials.get(id);\n    if (creds) {\n        //console.log(\"Attaching credentials to \",node.id);\n        // allow $(foo) syntax to substitute env variables for credentials also...\n        for (var p in creds) {\n            if (creds.hasOwnProperty(p)) {\n                flowUtil.mapEnvVarProperties(creds,p);\n            }\n        }\n        node.credentials = creds;\n    } else if (credentials.getDefinition(node.type)) {\n        node.credentials = {};\n    }\n}\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    credentials.init(runtime);\n    flows.init(runtime);\n    registry.init(runtime);\n    context.init(runtime.settings);\n}\n\nfunction disableNode(id) {\n    flows.checkTypeInUse(id);\n    return registry.disableNode(id);\n}\n\nfunction uninstallModule(module) {\n    var info = registry.getModuleInfo(module);\n    if (!info) {\n        throw new Error(log._(\"nodes.index.unrecognised-module\", {module:module}));\n    } else {\n        for (var i=0;i<info.nodes.length;i++) {\n            flows.checkTypeInUse(module+\"/\"+info.nodes[i].name);\n        }\n        return registry.uninstallModule(module);\n    }\n}\n\nmodule.exports = {\n    // Lifecycle\n    init: init,\n    load: registry.load,\n\n    // Node registry\n    createNode: createNode,\n    getNode: flows.get,\n    eachNode: flows.eachNode,\n\n    paletteEditorEnabled: registry.paletteEditorEnabled,\n    installModule: registry.installModule,\n    uninstallModule: uninstallModule,\n\n    enableNode: registry.enableNode,\n    disableNode: disableNode,\n\n    // Node type registry\n    registerType: registerType,\n    getType: registry.get,\n\n    getNodeInfo: registry.getNodeInfo,\n    getNodeList: registry.getNodeList,\n\n    getModuleInfo: registry.getModuleInfo,\n\n    getNodeConfigs: registry.getNodeConfigs,\n    getNodeConfig: registry.getNodeConfig,\n\n    clearRegistry: registry.clear,\n    cleanModuleList: registry.cleanModuleList,\n\n    // Flow handling\n    loadFlows:  flows.load,\n    startFlows: flows.startFlows,\n    stopFlows:  flows.stopFlows,\n    setFlows:   flows.setFlows,\n    getFlows:   flows.getFlows,\n\n    addFlow:     flows.addFlow,\n    getFlow:     flows.getFlow,\n    updateFlow:  flows.updateFlow,\n    removeFlow:  flows.removeFlow,\n    // disableFlow: flows.disableFlow,\n    // enableFlow:  flows.enableFlow,\n\n    // Credentials\n    addCredentials: credentials.add,\n    getCredentials: credentials.get,\n    deleteCredentials: credentials.delete,\n    getCredentialDefinition: credentials.getDefinition\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar events = require(\"../../events\");\nvar registry = require(\"./registry\");\nvar loader = require(\"./loader\");\nvar installer = require(\"./installer\");\n\nvar settings;\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    installer.init(runtime.settings);\n    loader.init(runtime);\n    registry.init(settings,loader);\n}\n\nfunction load() {\n    registry.load();\n    return installer.checkPrereq().then(loader.load);\n}\n\nfunction addModule(module) {\n    return loader.addModule(module).then(function() {\n        return registry.getModuleInfo(module);\n    });\n}\n\nfunction enableNodeSet(typeOrId) {\n    return registry.enableNodeSet(typeOrId).then(function() {\n        var nodeSet = registry.getNodeInfo(typeOrId);\n        if (!nodeSet.loaded) {\n            return loader.loadNodeSet(registry.getFullNodeInfo(typeOrId)).then(function() {\n                return registry.getNodeInfo(typeOrId);\n            });\n        }\n        return when.resolve(nodeSet);\n    });\n}\n\nmodule.exports = {\n    init:init,\n    load:load,\n    clear: registry.clear,\n    registerType: registry.registerNodeConstructor,\n\n    get: registry.getNodeConstructor,\n    getNodeInfo: registry.getNodeInfo,\n    getNodeList: registry.getNodeList,\n\n    getModuleInfo: registry.getModuleInfo,\n    getModuleList: registry.getModuleList,\n\n    getNodeConfigs: registry.getAllNodeConfigs,\n    getNodeConfig: registry.getNodeConfig,\n\n    enableNode: enableNodeSet,\n    disableNode: registry.disableNodeSet,\n\n    addModule: addModule,\n    removeModule: registry.removeModule,\n\n    installModule: installer.installModule,\n    uninstallModule: installer.uninstallModule,\n\n    cleanModuleList: registry.cleanModuleList,\n\n    paletteEditorEnabled: installer.paletteEditorEnabled\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/events.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar events = require(\"events\"); \n\nmodule.exports = new events.EventEmitter(); \n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/registry.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n //var UglifyJS = require(\"uglify-js\");\nvar util = require(\"util\");\nvar when = require(\"when\");\nvar events = require(\"../../events\");\n\nvar settings;\n\nvar Node;\n\nvar loader;\n\nvar nodeConfigCache = null;\nvar moduleConfigs = {};\nvar nodeList = [];\nvar nodeConstructors = {};\nvar nodeTypeToId = {};\nvar moduleNodes = {};\n\nfunction init(_settings,_loader) {\n    settings = _settings;\n    loader = _loader;\n    moduleNodes = {};\n    nodeTypeToId = {};\n    nodeConstructors = {};\n    nodeList = [];\n    nodeConfigCache = null;\n    Node = require(\"../Node\");\n}\n\nfunction load() {\n    if (settings.available()) {\n        moduleConfigs = loadNodeConfigs();\n    } else {\n        moduleConfigs = {};\n    }\n}\n\nfunction filterNodeInfo(n) {\n    var r = {\n        id: n.id||n.module+\"/\"+n.name,\n        name: n.name,\n        types: n.types,\n        enabled: n.enabled,\n        local: n.local||false\n    };\n    if (n.hasOwnProperty(\"module\")) {\n        r.module = n.module;\n    }\n    if (n.hasOwnProperty(\"err\")) {\n        r.err = n.err.toString();\n    }\n    return r;\n}\n\n\n\nfunction getModule(id) {\n    var parts = id.split(\"/\");\n    return parts.slice(0,parts.length-1).join(\"/\");\n}\n\nfunction getNode(id) {\n    var parts = id.split(\"/\");\n    return parts[parts.length-1];\n}\n\nfunction saveNodeList() {\n    var moduleList = {};\n\n    for (var module in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(module)) {\n            if (Object.keys(moduleConfigs[module].nodes).length > 0) {\n                if (!moduleList[module]) {\n                    moduleList[module] = {\n                        name: module,\n                        version: moduleConfigs[module].version,\n                        local: moduleConfigs[module].local||false,\n                        nodes: {}\n                    };\n                }\n                var nodes = moduleConfigs[module].nodes;\n                for(var node in nodes) {\n                    /* istanbul ignore else */\n                    if (nodes.hasOwnProperty(node)) {\n                        var config = nodes[node];\n                        var n = filterNodeInfo(config);\n                        delete n.err;\n                        delete n.file;\n                        delete n.id;\n                        n.file = config.file;\n                        moduleList[module].nodes[node] = n;\n                    }\n                }\n            }\n        }\n    }\n    if (settings.available()) {\n        return settings.set(\"nodes\",moduleList);\n    } else {\n        return when.reject(\"Settings unavailable\");\n    }\n}\n\nfunction loadNodeConfigs() {\n    var configs = settings.get(\"nodes\");\n\n    if (!configs) {\n        return {};\n    } else if (configs['node-red']) {\n        return configs;\n    } else {\n        // Migrate from the 0.9.1 format of settings\n        var newConfigs = {};\n        for (var id in configs) {\n            /* istanbul ignore else */\n            if (configs.hasOwnProperty(id)) {\n                var nodeConfig = configs[id];\n                var moduleName;\n                var nodeSetName;\n\n                if (nodeConfig.module) {\n                    moduleName = nodeConfig.module;\n                    nodeSetName = nodeConfig.name.split(\":\")[1];\n                } else {\n                    moduleName = \"node-red\";\n                    nodeSetName = nodeConfig.name.replace(/^\\d+-/,\"\").replace(/\\.js$/,\"\");\n                }\n\n                if (!newConfigs[moduleName]) {\n                    newConfigs[moduleName] = {\n                        name: moduleName,\n                        nodes:{}\n                    };\n                }\n                newConfigs[moduleName].nodes[nodeSetName] = {\n                    name: nodeSetName,\n                    types: nodeConfig.types,\n                    enabled: nodeConfig.enabled,\n                    module: moduleName\n                };\n            }\n        }\n        settings.set(\"nodes\",newConfigs);\n        return newConfigs;\n    }\n}\n\nfunction addNodeSet(id,set,version) {\n    if (!set.err) {\n        set.types.forEach(function(t) {\n            nodeTypeToId[t] = id;\n        });\n    }\n    moduleNodes[set.module] = moduleNodes[set.module]||[];\n    moduleNodes[set.module].push(set.name);\n\n    if (!moduleConfigs[set.module]) {\n        moduleConfigs[set.module] = {\n            name: set.module,\n            nodes: {}\n        };\n    }\n\n    if (version) {\n        moduleConfigs[set.module].version = version;\n    }\n    moduleConfigs[set.module].local = set.local;\n\n    moduleConfigs[set.module].nodes[set.name] = set;\n    nodeList.push(id);\n    nodeConfigCache = null;\n}\n\nfunction removeNode(id) {\n    var config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n    if (!config) {\n        throw new Error(\"Unrecognised id: \"+id);\n    }\n    delete moduleConfigs[getModule(id)].nodes[getNode(id)];\n    var i = nodeList.indexOf(id);\n    if (i > -1) {\n        nodeList.splice(i,1);\n    }\n    config.types.forEach(function(t) {\n        var typeId = nodeTypeToId[t];\n        if (typeId === id) {\n            delete nodeConstructors[t];\n            delete nodeTypeToId[t];\n        }\n    });\n    config.enabled = false;\n    config.loaded = false;\n    nodeConfigCache = null;\n    return filterNodeInfo(config);\n}\n\nfunction removeModule(module) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var nodes = moduleNodes[module];\n    if (!nodes) {\n        throw new Error(\"Unrecognised module: \"+module);\n    }\n    var infoList = [];\n    for (var i=0;i<nodes.length;i++) {\n        infoList.push(removeNode(module+\"/\"+nodes[i]));\n    }\n    delete moduleNodes[module];\n    delete moduleConfigs[module];\n    saveNodeList();\n    return infoList;\n}\n\nfunction getNodeInfo(typeOrId) {\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    /* istanbul ignore else */\n    if (id) {\n        var module = moduleConfigs[getModule(id)];\n        if (module) {\n            var config = module.nodes[getNode(id)];\n            if (config) {\n                var info = filterNodeInfo(config);\n                if (config.hasOwnProperty(\"loaded\")) {\n                    info.loaded = config.loaded;\n                }\n                info.version = module.version;\n                return info;\n            }\n        }\n    }\n    return null;\n}\n\nfunction getFullNodeInfo(typeOrId) {\n    // Used by index.enableNodeSet so that .file can be retrieved to pass\n    // to loader.loadNodeSet\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    /* istanbul ignore else */\n    if (id) {\n        var module = moduleConfigs[getModule(id)];\n        if (module) {\n            return module.nodes[getNode(id)];\n        }\n    }\n    return null;\n}\n\nfunction getNodeList(filter) {\n    var list = [];\n    for (var module in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(module)) {\n            var nodes = moduleConfigs[module].nodes;\n            for (var node in nodes) {\n                /* istanbul ignore else */\n                if (nodes.hasOwnProperty(node)) {\n                    var nodeInfo = filterNodeInfo(nodes[node]);\n                    nodeInfo.version = moduleConfigs[module].version;\n                    if (!filter || filter(nodes[node])) {\n                        list.push(nodeInfo);\n                    }\n                }\n            }\n        }\n    }\n    return list;\n}\n\nfunction getModuleList() {\n    //var list = [];\n    //for (var module in moduleNodes) {\n    //    /* istanbul ignore else */\n    //    if (moduleNodes.hasOwnProperty(module)) {\n    //        list.push(registry.getModuleInfo(module));\n    //    }\n    //}\n    //return list;\n    return moduleConfigs;\n\n}\n\nfunction getModuleInfo(module) {\n    if (moduleNodes[module]) {\n        var nodes = moduleNodes[module];\n        var m = {\n            name: module,\n            version: moduleConfigs[module].version,\n            local: moduleConfigs[module].local,\n            nodes: []\n        };\n        for (var i = 0; i < nodes.length; ++i) {\n            var nodeInfo = filterNodeInfo(moduleConfigs[module].nodes[nodes[i]]);\n            nodeInfo.version = m.version;\n            m.nodes.push(nodeInfo);\n        }\n        return m;\n    } else {\n        return null;\n    }\n}\n\nfunction getCaller(){\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function(_, stack){ return stack; };\n    var err = new Error();\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    stack.shift();\n    stack.shift();\n    return stack[0].getFileName();\n}\n\nfunction inheritNode(constructor) {\n    if(Object.getPrototypeOf(constructor.prototype) === Object.prototype) {\n        util.inherits(constructor,Node);\n    } else {\n        var proto = constructor.prototype;\n        while(Object.getPrototypeOf(proto) !== Object.prototype) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        //TODO: This is a partial implementation of util.inherits >= node v5.0.0\n        //      which should be changed when support for node < v5.0.0 is dropped\n        //      see: https://github.com/nodejs/node/pull/3455\n        proto.constructor.super_ = Node;\n        if(Object.setPrototypeOf) {\n            Object.setPrototypeOf(proto, Node.prototype);\n        } else {\n            // hack for node v0.10\n            proto.__proto__ = Node.prototype;\n        }\n    }\n}\n\nfunction registerNodeConstructor(nodeSet,type,constructor) {\n    if (nodeConstructors.hasOwnProperty(type)) {\n        throw new Error(type+\" already registered\");\n    }\n    //TODO: Ensure type is known - but doing so will break some tests\n    //      that don't have a way to register a node template ahead\n    //      of registering the constructor\n    if(!(constructor.prototype instanceof Node)) {\n        inheritNode(constructor);\n    }\n\n    var nodeSetInfo = getFullNodeInfo(nodeSet);\n    if (nodeSetInfo) {\n        if (nodeSetInfo.types.indexOf(type) === -1) {\n            // A type is being registered for a known set, but for some reason\n            // we didn't spot it when parsing the HTML file.\n            // Registered a type is the definitive action - not the presence\n            // of an edit template. Ensure it is on the list of known types.\n            nodeSetInfo.types.push(type);\n        }\n    }\n\n    nodeConstructors[type] = constructor;\n    events.emit(\"type-registered\",type);\n}\n\nfunction getAllNodeConfigs(lang) {\n    if (!nodeConfigCache) {\n        var result = \"\";\n        var script = \"\";\n        for (var i=0;i<nodeList.length;i++) {\n            var id = nodeList[i];\n            var config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n            if (config.enabled && !config.err) {\n                result += config.config;\n                result += loader.getNodeHelp(config,lang||\"en-US\")||\"\";\n                //script += config.script;\n            }\n        }\n        //if (script.length > 0) {\n        //    result += '<script type=\"text/javascript\">';\n        //    result += UglifyJS.minify(script, {fromString: true}).code;\n        //    result += '</script>';\n        //}\n        nodeConfigCache = result;\n    }\n    return nodeConfigCache;\n}\n\nfunction getNodeConfig(id,lang) {\n    var config = moduleConfigs[getModule(id)];\n    if (!config) {\n        return null;\n    }\n    config = config.nodes[getNode(id)];\n    if (config) {\n        var result = config.config;\n        result += loader.getNodeHelp(config,lang||\"en-US\")\n\n        //if (config.script) {\n        //    result += '<script type=\"text/javascript\">'+config.script+'</script>';\n        //}\n        return result;\n    } else {\n        return null;\n    }\n}\n\nfunction getNodeConstructor(type) {\n    var id = nodeTypeToId[type];\n\n    var config;\n    if (typeof id === \"undefined\") {\n        config = undefined;\n    } else {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n    }\n\n    if (!config || (config.enabled && !config.err)) {\n        return nodeConstructors[type];\n    }\n    return null;\n}\n\nfunction clear() {\n    nodeConfigCache = null;\n    moduleConfigs = {};\n    nodeList = [];\n    nodeConstructors = {};\n    nodeTypeToId = {};\n}\n\nfunction getTypeId(type) {\n    if (nodeTypeToId.hasOwnProperty(type)) {\n        return nodeTypeToId[type];\n    } else {\n        return null;\n    }\n}\n\nfunction enableNodeSet(typeOrId) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    var config;\n    try {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n        delete config.err;\n        config.enabled = true;\n        nodeConfigCache = null;\n        return saveNodeList().then(function() {\n            return filterNodeInfo(config);\n        });\n    } catch (err) {\n        throw new Error(\"Unrecognised id: \"+typeOrId);\n    }\n}\n\nfunction disableNodeSet(typeOrId) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var id = typeOrId;\n    if (nodeTypeToId.hasOwnProperty(typeOrId)) {\n        id = nodeTypeToId[typeOrId];\n    }\n    var config;\n    try {\n        config = moduleConfigs[getModule(id)].nodes[getNode(id)];\n        // TODO: persist setting\n        config.enabled = false;\n        nodeConfigCache = null;\n        return saveNodeList().then(function() {\n            return filterNodeInfo(config);\n        });\n    } catch (err) {\n        throw new Error(\"Unrecognised id: \"+id);\n    }\n}\n\nfunction cleanModuleList() {\n    var removed = false;\n    for (var mod in moduleConfigs) {\n        /* istanbul ignore else */\n        if (moduleConfigs.hasOwnProperty(mod)) {\n            var nodes = moduleConfigs[mod].nodes;\n            var node;\n            if (mod == \"node-red\") {\n                // For core nodes, look for nodes that are enabled, !loaded and !errored\n                for (node in nodes) {\n                    /* istanbul ignore else */\n                    if (nodes.hasOwnProperty(node)) {\n                        var n = nodes[node];\n                        if (n.enabled && !n.err && !n.loaded) {\n                            removeNode(mod+\"/\"+node);\n                            removed = true;\n                        }\n                    }\n                }\n            } else {\n                if (moduleConfigs[mod] && !moduleNodes[mod]) {\n                    // For node modules, look for missing ones\n                    for (node in nodes) {\n                        /* istanbul ignore else */\n                        if (nodes.hasOwnProperty(node)) {\n                            removeNode(mod+\"/\"+node);\n                            removed = true;\n                        }\n                    }\n                    delete moduleConfigs[mod];\n                }\n            }\n        }\n    }\n    if (removed) {\n        saveNodeList();\n    }\n}\n\nvar registry = module.exports = {\n    init: init,\n    load: load,\n    clear: clear,\n\n    registerNodeConstructor: registerNodeConstructor,\n    getNodeConstructor: getNodeConstructor,\n\n    addNodeSet: addNodeSet,\n    enableNodeSet: enableNodeSet,\n    disableNodeSet: disableNodeSet,\n\n    removeModule: removeModule,\n\n    getNodeInfo: getNodeInfo,\n    getFullNodeInfo: getFullNodeInfo,\n    getNodeList: getNodeList,\n    getModuleList: getModuleList,\n    getModuleInfo: getModuleInfo,\n\n    /**\n     * Gets all of the node template configs\n     * @return all of the node templates in a single string\n     */\n    getAllNodeConfigs: getAllNodeConfigs,\n    getNodeConfig: getNodeConfig,\n\n    getTypeId: getTypeId,\n\n    saveNodeList: saveNodeList,\n\n    cleanModuleList: cleanModuleList\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/loader.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar semver = require(\"semver\");\n\nvar localfilesystem = require(\"./localfilesystem\");\nvar registry = require(\"./registry\");\n\nvar settings;\nvar runtime;\n\nfunction init(_runtime) {\n    runtime = _runtime;\n    settings = runtime.settings;\n    localfilesystem.init(runtime);\n}\n\nfunction load(defaultNodesDir,disableNodePathScan) {\n    // To skip node scan, the following line will use the stored node list.\n    // We should expose that as an option at some point, although the\n    // performance gains are minimal.\n    //return loadNodeFiles(registry.getModuleList());\n    runtime.log.info(runtime.log._(\"server.loading\"));\n\n    var nodeFiles = localfilesystem.getNodeFiles(defaultNodesDir,disableNodePathScan);\n    return loadNodeFiles(nodeFiles);\n}\n\nfunction copyObjectProperties(src,dst,copyList,blockList) {\n    if (!src) {\n        return;\n    }\n    if (copyList && !blockList) {\n        copyList.forEach(function(i) {\n            if (src.hasOwnProperty(i)) {\n                var propDescriptor = Object.getOwnPropertyDescriptor(src,i);\n                Object.defineProperty(dst,i,propDescriptor);\n            }\n        });\n    } else if (!copyList && blockList) {\n        for (var i in src) {\n            if (src.hasOwnProperty(i) && blockList.indexOf(i) === -1) {\n                var propDescriptor = Object.getOwnPropertyDescriptor(src,i);\n                Object.defineProperty(dst,i,propDescriptor);\n            }\n        }\n    }\n}\n\nfunction createNodeApi(node) {\n    var red = {\n        nodes: {},\n        log: {},\n        settings: {},\n        events: runtime.events,\n        util: runtime.util,\n        version: runtime.version,\n    }\n    copyObjectProperties(runtime.nodes,red.nodes,[\"createNode\",\"getNode\",\"eachNode\",\"addCredentials\",\"getCredentials\",\"deleteCredentials\" ]);\n    red.nodes.registerType = function(type,constructor,opts) {\n        runtime.nodes.registerType(node.id,type,constructor,opts);\n    }\n    copyObjectProperties(runtime.log,red.log,null,[\"init\"]);\n    copyObjectProperties(runtime.settings,red.settings,null,[\"init\",\"load\",\"reset\"]);\n    if (runtime.adminApi) {\n        red.comms = runtime.adminApi.comms;\n        red.library = runtime.adminApi.library;\n        red.auth = runtime.adminApi.auth;\n        red.httpAdmin = runtime.adminApi.adminApp;\n        red.httpNode = runtime.nodeApp;\n        red.server = runtime.adminApi.server;\n    } else {\n        //TODO: runtime.adminApi is always stubbed if not enabled, so this block\n        // is unused - but may be needed for the unit tests\n        red.comms = {\n            publish: function() {}\n        };\n        red.library = {\n            register: function() {}\n        };\n        red.auth = {\n            needsPermission: function() {}\n        };\n        // TODO: stub out httpAdmin/httpNode/server\n    }\n    red[\"_\"] = function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        if (args[0].indexOf(\":\") === -1) {\n            args[0] = node.namespace+\":\"+args[0];\n        }\n        return runtime.i18n._.apply(null,args);\n    }\n    return red;\n}\n\n\nfunction loadNodeFiles(nodeFiles) {\n    var promises = [];\n    for (var module in nodeFiles) {\n        /* istanbul ignore else */\n        if (nodeFiles.hasOwnProperty(module)) {\n            if (nodeFiles[module].redVersion &&\n                !semver.satisfies(runtime.version().replace(\"-git\",\"\"), nodeFiles[module].redVersion)) {\n                //TODO: log it\n                runtime.log.warn(\"[\"+module+\"] \"+runtime.log._(\"server.node-version-mismatch\",{version:nodeFiles[module].redVersion}));\n                continue;\n            }\n            if (module == \"node-red\" || !registry.getModuleInfo(module)) {\n                var first = true;\n                for (var node in nodeFiles[module].nodes) {\n                    /* istanbul ignore else */\n                    if (nodeFiles[module].nodes.hasOwnProperty(node)) {\n                        if (module != \"node-red\" && first) {\n                            // Check the module directory exists\n                            first = false;\n                            var fn = nodeFiles[module].nodes[node].file;\n                            var parts = fn.split(\"/\");\n                            var i = parts.length-1;\n                            for (;i>=0;i--) {\n                                if (parts[i] == \"node_modules\") {\n                                    break;\n                                }\n                            }\n                            var moduleFn = parts.slice(0,i+2).join(\"/\");\n\n                            try {\n                                var stat = fs.statSync(moduleFn);\n                            } catch(err) {\n                                // Module not found, don't attempt to load its nodes\n                                break;\n                            }\n                        }\n\n                        try {\n                            promises.push(loadNodeConfig(nodeFiles[module].nodes[node]))\n                        } catch(err) {\n                            //\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return when.settle(promises).then(function(results) {\n        var nodes = results.map(function(r) {\n            registry.addNodeSet(r.value.id,r.value,r.value.version);\n            return r.value;\n        });\n        return loadNodeSetList(nodes);\n    });\n}\n\nfunction loadNodeConfig(fileInfo) {\n    return when.promise(function(resolve) {\n        var file = fileInfo.file;\n        var module = fileInfo.module;\n        var name = fileInfo.name;\n        var version = fileInfo.version;\n\n        var id = module + \"/\" + name;\n        var info = registry.getNodeInfo(id);\n        var isEnabled = true;\n        if (info) {\n            if (info.hasOwnProperty(\"loaded\")) {\n                throw new Error(file+\" already loaded\");\n            }\n            isEnabled = info.enabled;\n        }\n\n        var node = {\n            id: id,\n            module: module,\n            name: name,\n            file: file,\n            template: file.replace(/\\.js$/,\".html\"),\n            enabled: isEnabled,\n            loaded:false,\n            version: version,\n            local: fileInfo.local\n        };\n        if (fileInfo.hasOwnProperty(\"types\")) {\n            node.types = fileInfo.types;\n        }\n\n        fs.readFile(node.template,'utf8', function(err,content) {\n            if (err) {\n                node.types = [];\n                if (err.code === 'ENOENT') {\n                    if (!node.types) {\n                        node.types = [];\n                    }\n                    node.err = \"Error: \"+node.template+\" does not exist\";\n                } else {\n                    node.types = [];\n                    node.err = err.toString();\n                }\n                resolve(node);\n            } else {\n                var types = [];\n\n                var regExp = /<script ([^>]*)data-template-name=['\"]([^'\"]*)['\"]/gi;\n                var match = null;\n\n                while ((match = regExp.exec(content)) !== null) {\n                    types.push(match[2]);\n                }\n                node.types = types;\n\n                var langRegExp = /^<script[^>]* data-lang=['\"](.+?)['\"]/i;\n                regExp = /(<script[^>]* data-help-name=[\\s\\S]*?<\\/script>)/gi;\n                match = null;\n                var mainContent = \"\";\n                var helpContent = {};\n                var index = 0;\n                while ((match = regExp.exec(content)) !== null) {\n                    mainContent += content.substring(index,regExp.lastIndex-match[1].length);\n                    index = regExp.lastIndex;\n                    var help = content.substring(regExp.lastIndex-match[1].length,regExp.lastIndex);\n\n                    var lang = runtime.i18n.defaultLang;\n                    if ((match = langRegExp.exec(help)) !== null) {\n                        lang = match[1];\n                    }\n                    if (!helpContent.hasOwnProperty(lang)) {\n                        helpContent[lang] = \"\";\n                    }\n\n                    helpContent[lang] += help;\n                }\n                mainContent += content.substring(index);\n\n                node.config = mainContent;\n                node.help = helpContent;\n                // TODO: parse out the javascript portion of the template\n                //node.script = \"\";\n                for (var i=0;i<node.types.length;i++) {\n                    if (registry.getTypeId(node.types[i])) {\n                        node.err = node.types[i]+\" already registered\";\n                        break;\n                    }\n                }\n                fs.stat(path.join(path.dirname(file),\"locales\"),function(err,stat) {\n                    if (!err) {\n                        node.namespace = node.id;\n                        runtime.i18n.registerMessageCatalog(node.id,\n                                path.join(path.dirname(file),\"locales\"),\n                                path.basename(file,\".js\")+\".json\")\n                            .then(function() {\n                                resolve(node);\n                            });\n                    } else {\n                        node.namespace = node.module;\n                        resolve(node);\n                    }\n                });\n            }\n        });\n    });\n}\n\n/**\n * Loads the specified node into the runtime\n * @param node a node info object - see loadNodeConfig\n * @return a promise that resolves to an update node info object. The object\n *         has the following properties added:\n *            err: any error encountered whilst loading the node\n *\n */\nfunction loadNodeSet(node) {\n    var nodeDir = path.dirname(node.file);\n    var nodeFn = path.basename(node.file);\n    if (!node.enabled) {\n        return when.resolve(node);\n    } else {\n    }\n    try {\n        var loadPromise = null;\n        var r = require(node.file);\n        if (typeof r === \"function\") {\n\n            var red = createNodeApi(node);\n            var promise = r(red);\n            if (promise != null && typeof promise.then === \"function\") {\n                loadPromise = promise.then(function() {\n                    node.enabled = true;\n                    node.loaded = true;\n                    return node;\n                }).otherwise(function(err) {\n                    node.err = err;\n                    return node;\n                });\n            }\n        }\n        if (loadPromise == null) {\n            node.enabled = true;\n            node.loaded = true;\n            loadPromise = when.resolve(node);\n        }\n        return loadPromise;\n    } catch(err) {\n        node.err = err;\n        return when.resolve(node);\n    }\n}\n\nfunction loadNodeSetList(nodes) {\n    var promises = [];\n    nodes.forEach(function(node) {\n        if (!node.err) {\n            promises.push(loadNodeSet(node));\n        } else {\n            promises.push(node);\n        }\n    });\n\n    return when.settle(promises).then(function() {\n        if (settings.available()) {\n            return registry.saveNodeList();\n        } else {\n            return;\n        }\n    });\n}\n\nfunction addModule(module) {\n    if (!settings.available()) {\n        throw new Error(\"Settings unavailable\");\n    }\n    var nodes = [];\n    if (registry.getModuleInfo(module)) {\n        // TODO: nls\n        var e = new Error(\"module_already_loaded\");\n        e.code = \"module_already_loaded\";\n        return when.reject(e);\n    }\n    try {\n        var moduleFiles = localfilesystem.getModuleFiles(module);\n        return loadNodeFiles(moduleFiles);\n    } catch(err) {\n        return when.reject(err);\n    }\n}\n\nfunction loadNodeHelp(node,lang) {\n    var dir = path.dirname(node.template);\n    var base = path.basename(node.template);\n    var localePath = path.join(dir,\"locales\",lang,base);\n    try {\n        // TODO: make this async\n        var content = fs.readFileSync(localePath, \"utf8\")\n        return content;\n    } catch(err) {\n        return null;\n    }\n}\n\nfunction getNodeHelp(node,lang) {\n    if (!node.help[lang]) {\n        var help = loadNodeHelp(node,lang);\n        if (help == null) {\n            var langParts = lang.split(\"-\");\n            if (langParts.length == 2) {\n                help = loadNodeHelp(node,langParts[0]);\n            }\n        }\n        if (help) {\n            node.help[lang] = help;\n        } else {\n            node.help[lang] = node.help[runtime.i18n.defaultLang];\n        }\n    }\n    return node.help[lang];\n}\n\nmodule.exports = {\n    init: init,\n    load: load,\n    addModule: addModule,\n    loadNodeSet: loadNodeSet,\n    getNodeHelp: getNodeHelp\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/localfilesystem.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar events;\nvar log;\nvar i18n;\n\nvar settings;\nvar disableNodePathScan = false;\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    events = runtime.events;\n    log = runtime.log;\n    i18n = runtime.i18n;\n}\n\nfunction isExcluded(name) {\n     if (settings.nodesExcludes) {\n        for (var i=0;i<settings.nodesExcludes.length;i++) {\n            if (settings.nodesExcludes[i] == name) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction getLocalFile(file) {\n    if (isExcluded(path.basename(file))) {\n        return null;\n    }\n    try {\n        fs.statSync(file.replace(/\\.js$/,\".html\"));\n        return {\n            file:    file,\n            module:  \"node-red\",\n            name:    path.basename(file).replace(/^\\d+-/,\"\").replace(/\\.js$/,\"\"),\n            version: settings.version\n        };\n    } catch(err) {\n        return null;\n    }\n}\n\n\n/**\n * Synchronously walks the directory looking for node files.\n * Emits 'node-icon-dir' events for an icon dirs found\n * @param dir the directory to search\n * @return an array of fully-qualified paths to .js files\n */\nfunction getLocalNodeFiles(dir) {\n    var result = [];\n    var files = [];\n    try {\n        files = fs.readdirSync(dir);\n    } catch(err) {\n        return result;\n    }\n    files.sort();\n    files.forEach(function(fn) {\n        var stats = fs.statSync(path.join(dir,fn));\n        if (stats.isFile()) {\n            if (/\\.js$/.test(fn)) {\n                var info = getLocalFile(path.join(dir,fn));\n                if (info) {\n                    result.push(info);\n                }\n            }\n        } else if (stats.isDirectory()) {\n            // Ignore /.dirs/, /lib/ /node_modules/\n            if (!/^(\\..*|lib|icons|node_modules|test|locales)$/.test(fn)) {\n                result = result.concat(getLocalNodeFiles(path.join(dir,fn)));\n            } else if (fn === \"icons\") {\n                events.emit(\"node-icon-dir\",path.join(dir,fn));\n            }\n        }\n    });\n    return result;\n}\n\nfunction scanDirForNodesModules(dir,moduleName) {\n    var results = [];\n    try {\n        var files = fs.readdirSync(dir);\n        for (var i=0;i<files.length;i++) {\n            var fn = files[i];\n            if (/^@/.test(fn)) {\n                results = results.concat(scanDirForNodesModules(path.join(dir,fn),moduleName));\n            } else {\n                if (!isExcluded(fn) && (!moduleName || fn == moduleName)) {\n                    var pkgfn = path.join(dir,fn,\"package.json\");\n                    try {\n                        var pkg = require(pkgfn);\n                        if (pkg['node-red']) {\n                            var moduleDir = path.join(dir,fn);\n                            results.push({dir:moduleDir,package:pkg});\n                        }\n                    } catch(err) {\n                        if (err.code != \"MODULE_NOT_FOUND\") {\n                            // TODO: handle unexpected error\n                        }\n                    }\n                    if (fn == moduleName) {\n                        break;\n                    }\n                }\n            }\n        }\n    } catch(err) {\n    }\n    return results;\n}\n\n/**\n * Scans the node_modules path for nodes\n * @param moduleName the name of the module to be found\n * @return a list of node modules: {dir,package}\n */\nfunction scanTreeForNodesModules(moduleName) {\n    var dir = settings.coreNodesDir;\n    var results = [];\n    var userDir;\n\n    if (settings.userDir) {\n        userDir = path.join(settings.userDir,\"node_modules\");\n        results = scanDirForNodesModules(userDir,moduleName);\n        results.forEach(function(r) { r.local = true; });\n    }\n\n    if (dir) {\n        var up = path.resolve(path.join(dir,\"..\"));\n        while (up !== dir) {\n            var pm = path.join(dir,\"node_modules\");\n            if (pm != userDir) {\n                results = results.concat(scanDirForNodesModules(pm,moduleName));\n            }\n            dir = up;\n            up = path.resolve(path.join(dir,\"..\"));\n        }\n    }\n    return results;\n}\n\nfunction getModuleNodeFiles(module) {\n\n    var moduleDir = module.dir;\n    var pkg = module.package;\n\n    var nodes = pkg['node-red'].nodes||{};\n    var results = [];\n    var iconDirs = [];\n\n    for (var n in nodes) {\n        /* istanbul ignore else */\n        if (nodes.hasOwnProperty(n)) {\n            var file = path.join(moduleDir,nodes[n]);\n            results.push({\n                file:    file,\n                module:  pkg.name,\n                name:    n,\n                version: pkg.version\n            });\n            var iconDir = path.join(moduleDir,path.dirname(nodes[n]),\"icons\");\n            if (iconDirs.indexOf(iconDir) == -1) {\n                try {\n                    fs.statSync(iconDir);\n                    events.emit(\"node-icon-dir\",iconDir);\n                    iconDirs.push(iconDir);\n                } catch(err) {\n                }\n            }\n        }\n    }\n    var examplesDir = path.join(moduleDir,\"examples\");\n    try {\n        fs.statSync(examplesDir)\n        events.emit(\"node-examples-dir\",{name:pkg.name,path:examplesDir});\n    } catch(err) {\n    }\n    return results;\n}\n\nfunction getNodeFiles(disableNodePathScan) {\n    var dir;\n    // Find all of the nodes to load\n    var nodeFiles = [];\n\n    if (settings.coreNodesDir) {\n        nodeFiles = getLocalNodeFiles(path.resolve(settings.coreNodesDir));\n        var defaultLocalesPath = path.resolve(path.join(settings.coreNodesDir,\"core\",\"locales\"));\n        i18n.registerMessageCatalog(\"node-red\",defaultLocalesPath,\"messages.json\");\n    }\n\n    if (settings.userDir) {\n        dir = path.join(settings.userDir,\"nodes\");\n        nodeFiles = nodeFiles.concat(getLocalNodeFiles(dir));\n    }\n    if (settings.nodesDir) {\n        dir = settings.nodesDir;\n        if (typeof settings.nodesDir == \"string\") {\n            dir = [dir];\n        }\n        for (var i=0;i<dir.length;i++) {\n            nodeFiles = nodeFiles.concat(getLocalNodeFiles(dir[i]));\n        }\n    }\n\n    var nodeList = {\n        \"node-red\": {\n            name: \"node-red\",\n            version: settings.version,\n            nodes: {}\n        }\n    }\n    nodeFiles.forEach(function(node) {\n        nodeList[\"node-red\"].nodes[node.name] = node;\n    });\n\n    if (!disableNodePathScan) {\n        var moduleFiles = scanTreeForNodesModules();\n        moduleFiles.forEach(function(moduleFile) {\n            var nodeModuleFiles = getModuleNodeFiles(moduleFile);\n            nodeList[moduleFile.package.name] = {\n                name: moduleFile.package.name,\n                version: moduleFile.package.version,\n                local: moduleFile.local||false,\n                nodes: {}\n            };\n            if (moduleFile.package['node-red'].version) {\n                nodeList[moduleFile.package.name].redVersion = moduleFile.package['node-red'].version;\n            }\n            nodeModuleFiles.forEach(function(node) {\n                node.local = moduleFile.local||false;\n                nodeList[moduleFile.package.name].nodes[node.name] = node;\n            });\n            nodeFiles = nodeFiles.concat(nodeModuleFiles);\n        });\n    } else {\n        console.log(\"node path scan disabled\");\n    }\n    return nodeList;\n}\n\nfunction getModuleFiles(module) {\n    var nodeList = {};\n\n    var moduleFiles = scanTreeForNodesModules(module);\n    if (moduleFiles.length === 0) {\n        var err = new Error(log._(\"nodes.registry.localfilesystem.module-not-found\", {module:module}));\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n    }\n\n    moduleFiles.forEach(function(moduleFile) {\n        var nodeModuleFiles = getModuleNodeFiles(moduleFile);\n        nodeList[moduleFile.package.name] = {\n            name: moduleFile.package.name,\n            version: moduleFile.package.version,\n            nodes: {}\n        };\n        if (moduleFile.package['node-red'].version) {\n            nodeList[moduleFile.package.name].redVersion = moduleFile.package['node-red'].version;\n        }\n        nodeModuleFiles.forEach(function(node) {\n            nodeList[moduleFile.package.name].nodes[node.name] = node;\n            nodeList[moduleFile.package.name].nodes[node.name].local = moduleFile.local || false;\n        });\n    });\n    return nodeList;\n}\n\n\nmodule.exports = {\n    init: init,\n    getNodeFiles: getNodeFiles,\n    getLocalFile: getLocalFile,\n    getModuleFiles: getModuleFiles\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/installer.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\n\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar registry = require(\"./registry\");\nvar log = require(\"../../log\");\n\nvar events = require(\"../../events\");\n\nvar child_process = require('child_process');\nvar npmCommand = process.platform === 'win32' ? 'npm.cmd' : 'npm';\nvar paletteEditorEnabled = false;\n\nvar settings;\n\nvar moduleRe = /^[^/]+$/;\nvar slashRe = process.platform === \"win32\" ? /\\\\|[/]/ : /[/]/;\n\nfunction init(_settings) {\n    settings = _settings;\n}\n\nfunction checkModulePath(folder) {\n    var moduleName;\n    var err;\n    var fullPath = path.resolve(folder);\n    var packageFile = path.join(fullPath,'package.json');\n    try {\n        var pkg = require(packageFile);\n        moduleName = pkg.name;\n        if (!pkg['node-red']) {\n            // TODO: nls\n            err = new Error(\"Invalid Node-RED module\");\n            err.code = 'invalid_module';\n            throw err;\n        }\n    } catch(err2) {\n        err = new Error(\"Module not found\");\n        err.code = 404;\n        throw err;\n    }\n    return moduleName;\n}\n\nfunction checkExistingModule(module) {\n    if (registry.getModuleInfo(module)) {\n        // TODO: nls\n        var err = new Error(\"Module already loaded\");\n        err.code = \"module_already_loaded\";\n        throw err;\n    }\n}\n\nfunction installModule(module) {\n    //TODO: ensure module is 'safe'\n    return when.promise(function(resolve,reject) {\n        var installName = module;\n\n        try {\n            if (moduleRe.test(module)) {\n                // Simple module name - assume it can be npm installed\n            } else if (slashRe.test(module)) {\n                // A path - check if there's a valid package.json\n                installName = module;\n                module = checkModulePath(module);\n            }\n            checkExistingModule(module);\n        } catch(err) {\n            return reject(err);\n        }\n        log.info(log._(\"server.install.installing\",{name: module}));\n\n        var installDir = settings.userDir || process.env.NODE_RED_HOME || \".\";\n        var child = child_process.execFile(npmCommand,['install','--production',installName],\n            {\n                cwd: installDir\n            },\n            function(err, stdin, stdout) {\n                if (err) {\n                    var lookFor404 = new RegExp(\" 404 .*\"+installName+\"$\",\"m\");\n                    if (lookFor404.test(stdout)) {\n                        log.warn(log._(\"server.install.install-failed-not-found\",{name:module}));\n                        var e = new Error(\"Module not found\");\n                        e.code = 404;\n                        reject(e);\n                    } else {\n                        log.warn(log._(\"server.install.install-failed-long\",{name:module}));\n                        log.warn(\"------------------------------------------\");\n                        log.warn(err.toString());\n                        log.warn(\"------------------------------------------\");\n                        reject(new Error(log._(\"server.install.install-failed\")));\n                    }\n                } else {\n                    log.info(log._(\"server.install.installed\",{name:module}));\n                    resolve(require(\"./index\").addModule(module).then(reportAddedModules));\n                }\n            }\n        );\n    });\n}\n\n\nfunction reportAddedModules(info) {\n    //comms.publish(\"node/added\",info.nodes,false);\n    if (info.nodes.length > 0) {\n        log.info(log._(\"server.added-types\"));\n        for (var i=0;i<info.nodes.length;i++) {\n            for (var j=0;j<info.nodes[i].types.length;j++) {\n                log.info(\" - \"+\n                    (info.nodes[i].module?info.nodes[i].module+\":\":\"\")+\n                    info.nodes[i].types[j]+\n                    (info.nodes[i].err?\" : \"+info.nodes[i].err:\"\")\n                );\n            }\n        }\n    }\n    return info;\n}\n\nfunction reportRemovedModules(removedNodes) {\n    //comms.publish(\"node/removed\",removedNodes,false);\n    log.info(log._(\"server.removed-types\"));\n    for (var j=0;j<removedNodes.length;j++) {\n        for (var i=0;i<removedNodes[j].types.length;i++) {\n            log.info(\" - \"+(removedNodes[j].module?removedNodes[j].module+\":\":\"\")+removedNodes[j].types[i]);\n        }\n    }\n    return removedNodes;\n}\n\nfunction uninstallModule(module) {\n    return when.promise(function(resolve,reject) {\n        if (/[\\s;]/.test(module)) {\n            reject(new Error(log._(\"server.install.invalid\")));\n            return;\n        }\n        var installDir = settings.userDir || process.env.NODE_RED_HOME || \".\";\n        var moduleDir = path.join(installDir,\"node_modules\",module);\n\n        try {\n            fs.statSync(moduleDir);\n        } catch(err) {\n            return reject(new Error(log._(\"server.install.uninstall-failed\",{name:module})));\n        }\n\n        var list = registry.removeModule(module);\n        log.info(log._(\"server.install.uninstalling\",{name:module}));\n        var child = child_process.execFile(npmCommand,['remove',module],\n            {\n                cwd: installDir\n            },\n            function(err, stdin, stdout) {\n                if (err) {\n                    log.warn(log._(\"server.install.uninstall-failed-long\",{name:module}));\n                    log.warn(\"------------------------------------------\");\n                    log.warn(err.toString());\n                    log.warn(\"------------------------------------------\");\n                    reject(new Error(log._(\"server.install.uninstall-failed\",{name:module})));\n                } else {\n                    log.info(log._(\"server.install.uninstalled\",{name:module}));\n                    reportRemovedModules(list);\n                    // TODO: tidy up internal event names\n                    events.emit(\"node-module-uninstalled\",module)\n                    resolve(list);\n                }\n            }\n        );\n    });\n}\n\nfunction checkPrereq() {\n    if (settings.hasOwnProperty('editorTheme') &&\n        settings.editorTheme.hasOwnProperty('palette') &&\n        settings.editorTheme.palette.hasOwnProperty('editable') &&\n        settings.editorTheme.palette.editable === false\n    ) {\n        log.info(log._(\"server.palette-editor.disabled\"));\n        paletteEditorEnabled = false;\n        return when.resolve();\n    } else {\n        return when.promise(function(resolve) {\n            child_process.execFile(npmCommand,['-v'],function(err) {\n                if (err) {\n                    log.info(log._(\"server.palette-editor.npm-not-found\"));\n                    paletteEditorEnabled = false;\n                } else {\n                    paletteEditorEnabled = true;\n                }\n                resolve();\n            });\n        })\n    }\n}\nmodule.exports = {\n    init: init,\n    checkPrereq: checkPrereq,\n    installModule: installModule,\n    uninstallModule: uninstallModule,\n    paletteEditorEnabled: function() {\n        return paletteEditorEnabled\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/log.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\n\nvar i18n = require(\"./i18n\");\n\nvar levels = {\n    off:    1,\n    fatal:  10,\n    error:  20,\n    warn:   30,\n    info:   40,\n    debug:  50,\n    trace:  60,\n    audit:  98,\n    metric: 99\n};\n\nvar levelNames = {\n    10: \"fatal\",\n    20: \"error\",\n    30: \"warn\",\n    40: \"info\",\n    50: \"debug\",\n    60: \"trace\",\n    98: \"audit\",\n    99: \"metric\"\n};\n\nvar logHandlers = [];\n\nvar metricsEnabled = false;\n\nvar LogHandler = function(settings) {\n    this.logLevel  = settings ? levels[settings.level]||levels.info : levels.info;\n    this.metricsOn = settings ? settings.metrics||false : false;\n    this.auditOn = settings ? settings.audit||false : false;\n\n    metricsEnabled = metricsEnabled || this.metricsOn;\n\n    this.handler   = (settings && settings.handler) ? settings.handler(settings) : consoleLogger;\n    this.on(\"log\",function(msg) {\n        if (this.shouldReportMessage(msg.level)) {\n            this.handler(msg);\n        }\n    });\n}\nutil.inherits(LogHandler, EventEmitter);\n\nLogHandler.prototype.shouldReportMessage = function(msglevel) {\n    return (msglevel == log.METRIC && this.metricsOn) ||\n           (msglevel == log.AUDIT && this.auditOn) ||\n           msglevel <= this.logLevel;\n}\n\nvar consoleLogger = function(msg) {\n    if (msg.level == log.METRIC || msg.level == log.AUDIT) {\n        util.log(\"[\"+levelNames[msg.level]+\"] \"+JSON.stringify(msg));\n    } else {\n        var message = msg.msg;\n        if (typeof message === 'object' && message.toString() === '[object Object]' && message.message) {\n            message = message.message;\n        }\n        util.log(\"[\"+levelNames[msg.level]+\"] \"+(msg.type?\"[\"+msg.type+\":\"+(msg.name||msg.id)+\"] \":\"\")+message);\n    }\n}\n\nvar log = module.exports = {\n    FATAL:  10,\n    ERROR:  20,\n    WARN:   30,\n    INFO:   40,\n    DEBUG:  50,\n    TRACE:  60,\n    AUDIT:  98,\n    METRIC: 99,\n\n    init: function(settings) {\n        metricsEnabled = false;\n        logHandlers = [];\n        var loggerSettings = {};\n        if (settings.logging) {\n            var keys = Object.keys(settings.logging);\n            if (keys.length === 0) {\n                log.addHandler(new LogHandler());\n            } else {\n                for (var i=0, l=keys.length; i<l; i++) {\n                    var config = settings.logging[keys[i]];\n                    loggerSettings = config || {};\n                    if ((keys[i] === \"console\") || config.handler) {\n                        log.addHandler(new LogHandler(loggerSettings));\n                    }\n                }\n            }\n        } else {\n            log.addHandler(new LogHandler());\n        }\n    },\n    addHandler: function(func) {\n        logHandlers.push(func);\n    },\n    removeHandler: function(func) {\n        var index = logHandlers.indexOf(func);\n        if (index > -1) {\n            logHandlers.splice(index,1);\n        }\n    },\n    log: function(msg) {\n        msg.timestamp = Date.now();\n        logHandlers.forEach(function(handler) {\n            handler.emit(\"log\",msg);\n        });\n    },\n    info: function(msg) {\n        log.log({level:log.INFO,msg:msg});\n    },\n    warn: function(msg) {\n        log.log({level:log.WARN,msg:msg});\n    },\n    error: function(msg) {\n        log.log({level:log.ERROR,msg:msg});\n    },\n    trace: function(msg) {\n        log.log({level:log.TRACE,msg:msg});\n    },\n    debug: function(msg) {\n        log.log({level:log.DEBUG,msg:msg});\n    },\n    metric: function() {\n        return metricsEnabled;\n    },\n\n    audit: function(msg,req) {\n        msg.level = log.AUDIT;\n        if (req) {\n            msg.user = req.user;\n            msg.path = req.path;\n            msg.ip = (req.headers && req.headers['x-forwarded-for']) || (req.connection && req.connection.remoteAddress) || undefined;\n        }\n        log.log(msg);\n    }\n}\n\nlog[\"_\"] = i18n._;\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/i18n.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar i18n = require(\"i18next\");\nvar when = require(\"when\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\n\nvar defaultLang = \"en-US\";\n\nvar resourceMap = {};\nvar resourceCache = {};\n\nfunction registerMessageCatalogs(catalogs) {\n    var promises = catalogs.map(function(catalog) {\n        return registerMessageCatalog(catalog.namespace,catalog.dir,catalog.file);\n    });\n    return when.settle(promises);\n}\n\nfunction registerMessageCatalog(namespace,dir,file) {\n    return when.promise(function(resolve,reject) {\n        resourceMap[namespace] = { basedir:dir, file:file};\n        i18n.loadNamespace(namespace,function() {\n            resolve();\n        });\n    });\n}\n\nfunction mergeCatalog(fallback,catalog) {\n    for (var k in fallback) {\n        if (fallback.hasOwnProperty(k)) {\n            if (!catalog[k]) {\n                catalog[k] = fallback[k];\n            } else if (typeof fallback[k] === 'object') {\n                mergeCatalog(fallback[k],catalog[k]);\n            }\n        }\n    }\n}\n\nvar MessageFileLoader = {\n    fetchOne: function(lng, ns, callback) {\n        if (resourceMap[ns]) {\n            var file = path.join(resourceMap[ns].basedir,lng,resourceMap[ns].file);\n            //console.log(file);\n            fs.readFile(file,\"utf8\",function(err,content) {\n                if (err) {\n                    callback(err);\n                } else {\n                    try {\n                        resourceCache[ns] = resourceCache[ns]||{};\n                        resourceCache[ns][lng] = JSON.parse(content.replace(/^\\uFEFF/, ''));\n                        //console.log(resourceCache[ns][lng]);\n                        if (lng !== defaultLang) {\n                            mergeCatalog(resourceCache[ns][defaultLang],resourceCache[ns][lng]);\n                        }\n                        callback(null, resourceCache[ns][lng]);\n                    } catch(e) {\n                        callback(e);\n                    }\n                }\n            });\n        } else {\n            callback(new Error(\"Unrecognised namespace\"));\n        }\n    }\n\n}\n\nfunction init() {\n    return when.promise(function(resolve,reject) {\n        i18n.backend(MessageFileLoader);\n        i18n.init({\n            ns: {\n                namespaces: [],\n                defaultNs: \"runtime\"\n            },\n            fallbackLng: [defaultLang]\n        },function() {\n            resolve();\n        });\n    });\n}\n\nfunction getCatalog(namespace,lang) {\n    var result = null;\n    if (resourceCache.hasOwnProperty(namespace)) {\n        result = resourceCache[namespace][lang];\n        if (!result) {\n            var langParts = lang.split(\"-\");\n            if (langParts.length == 2) {\n                result = resourceCache[namespace][langParts[0]];\n            }\n            if (!result) {\n                return resourceCache[namespace][defaultLang];\n            }\n        }\n    }\n    return result;\n}\n\nvar obj = module.exports = {\n    init: init,\n    registerMessageCatalog: registerMessageCatalog,\n    registerMessageCatalogs: registerMessageCatalogs,\n    catalog: getCatalog,\n    i: i18n,\n    defaultLang: defaultLang\n}\n\nobj['_'] = function() {\n    //var opts = {};\n    //if (def) {\n    //    opts.defaultValue = def;\n    //}\n    //console.log(arguments);\n    return i18n.t.apply(null,arguments);\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/credentials.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar crypto = require('crypto');\nvar settings;\nvar log;\n\nvar encryptedCredentials = null;\nvar credentialCache = {};\nvar credentialsDef = {};\nvar dirty = false;\n\nvar removeDefaultKey = false;\nvar encryptionEnabled = null;\nvar encryptionAlgorithm = \"aes-256-ctr\";\nvar encryptionKey;\n\nfunction decryptCredentials(key,credentials) {\n    var creds = credentials[\"$\"];\n    var initVector = new Buffer(creds.substring(0, 32),'hex');\n    creds = creds.substring(32);\n    var decipher = crypto.createDecipheriv(encryptionAlgorithm, key, initVector);\n    var decrypted = decipher.update(creds, 'base64', 'utf8') + decipher.final('utf8');\n    return JSON.parse(decrypted);\n}\n\nvar api = module.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n        settings = runtime.settings;\n        dirty = false;\n        credentialCache = {};\n        credentialsDef = {};\n        encryptionEnabled = null;\n    },\n\n    /**\n     * Sets the credentials from storage.\n     */\n    load: function (credentials) {\n        dirty = false;\n        /*\n          - if encryptionEnabled === null, check the current configuration\n        */\n        var credentialsEncrypted = credentials.hasOwnProperty(\"$\") && Object.keys(credentials).length === 1;\n        var setupEncryptionPromise = when.resolve();\n        if (encryptionEnabled === null) {\n            var defaultKey;\n            try {\n                defaultKey = settings.get('_credentialSecret');\n            } catch(err) {\n            }\n            if (defaultKey) {\n                defaultKey = crypto.createHash('sha256').update(defaultKey).digest();\n            }\n            var userKey;\n            try {\n                userKey = settings.get('credentialSecret');\n            } catch(err) {\n                userKey = false;\n            }\n            if (userKey === false) {\n                log.debug(\"red/runtime/nodes/credentials.load : user disabled encryption\");\n                // User has disabled encryption\n                encryptionEnabled = false;\n                // Check if we have a generated _credSecret to decrypt with and remove\n                if (defaultKey) {\n                    log.debug(\"red/runtime/nodes/credentials.load : default key present. Will migrate\");\n                    if (credentialsEncrypted) {\n                        try {\n                            credentials = decryptCredentials(defaultKey,credentials)\n                        } catch(err) {\n                            credentials = {};\n                            log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                        }\n                    }\n                    dirty = true;\n                    removeDefaultKey = true;\n                }\n            } else if (typeof userKey === 'string') {\n                log.debug(\"red/runtime/nodes/credentials.load : user provided key\");\n                // User has provided own encryption key, get the 32-byte hash of it\n                encryptionKey = crypto.createHash('sha256').update(userKey).digest();\n                encryptionEnabled = true;\n\n                if (defaultKey) {\n                    log.debug(\"red/runtime/nodes/credentials.load : default key present. Will migrate\");\n                    // User has provided their own key, but we already have a default key\n                    // Decrypt using default key\n                    if (credentialsEncrypted) {\n                        try {\n                            credentials = decryptCredentials(defaultKey,credentials)\n                        } catch(err) {\n                            credentials = {};\n                            log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                        }\n                    }\n                    dirty = true;\n                    removeDefaultKey = true;\n                }\n            } else {\n                log.debug(\"red/runtime/nodes/credentials.load : no user key present\");\n                // User has not provide their own key\n                encryptionKey = defaultKey;\n                encryptionEnabled = true;\n                if (encryptionKey === undefined) {\n                    log.debug(\"red/runtime/nodes/credentials.load : no default key present - generating one\");\n                    // No user-provided key, no generated key\n                    // Generate a new key\n                    defaultKey = crypto.randomBytes(32).toString('hex');\n                    try {\n                        setupEncryptionPromise = settings.set('_credentialSecret',defaultKey);\n                        encryptionKey = crypto.createHash('sha256').update(defaultKey).digest();\n                    } catch(err) {\n                        log.debug(\"red/runtime/nodes/credentials.load : settings unavailable - disabling encryption\");\n                        // Settings unavailable\n                        encryptionEnabled = false;\n                        encryptionKey = null;\n                    }\n                    dirty = true;\n                } else {\n                    log.debug(\"red/runtime/nodes/credentials.load : using default key\");\n                }\n            }\n        }\n        if (encryptionEnabled && !dirty) {\n            encryptedCredentials = credentials;\n        }\n        return setupEncryptionPromise.then(function() {\n            if (credentials.hasOwnProperty(\"$\")) {\n                // These are encrypted credentials\n                try {\n                    credentialCache = decryptCredentials(encryptionKey,credentials)\n                } catch(err) {\n                    credentialCache = {};\n                    dirty = true;\n                    log.warn(log._(\"nodes.credentials.error\",{message:err.toString()}))\n                }\n            } else {\n                credentialCache = credentials;\n            }\n        });\n    },\n\n    /**\n     * Adds a set of credentials for the given node id.\n     * @param id the node id for the credentials\n     * @param creds an object of credential key/value pairs\n     * @return a promise for backwards compatibility TODO: can this be removed?\n     */\n    add: function (id, creds) {\n        if (!credentialCache.hasOwnProperty(id) || JSON.stringify(creds) !== JSON.stringify(credentialCache[id])) {\n            credentialCache[id] = creds;\n            dirty = true;\n        }\n        return when.resolve();\n    },\n\n    /**\n     * Gets the credentials for the given node id.\n     * @param id the node id for the credentials\n     * @return the credentials\n     */\n    get: function (id) {\n        return credentialCache[id];\n    },\n\n    /**\n     * Deletes the credentials for the given node id.\n     * @param id the node id for the credentials\n     * @return a promise for the saving of credentials to storage\n     */\n    delete: function (id) {\n        delete credentialCache[id];\n        dirty = true;\n    },\n\n    /**\n     * Deletes any credentials for nodes that no longer exist\n     * @param config a flow config\n     * @return a promise for the saving of credentials to storage\n     */\n    clean: function (config) {\n        var existingIds = {};\n        config.forEach(function(n) {\n            existingIds[n.id] = true;\n            if (n.credentials) {\n                api.extract(n);\n            }\n        });\n        var deletedCredentials = false;\n        for (var c in credentialCache) {\n            if (credentialCache.hasOwnProperty(c)) {\n                if (!existingIds[c]) {\n                    deletedCredentials = true;\n                    delete credentialCache[c];\n                }\n            }\n        }\n        if (deletedCredentials) {\n            dirty = true;\n        }\n        return when.resolve();\n    },\n\n    /**\n     * Registers a node credential definition.\n     * @param type the node type\n     * @param definition the credential definition\n     */\n    register: function (type, definition) {\n        var dashedType = type.replace(/\\s+/g, '-');\n        credentialsDef[dashedType] = definition;\n    },\n\n    /**\n     * Extracts and stores any credential updates in the provided node.\n     * The provided node may have a .credentials property that contains\n     * new credentials for the node.\n     * This function loops through the credentials in the definition for\n     * the node-type and applies any of the updates provided in the node.\n     *\n     * This function does not save the credentials to disk as it is expected\n     * to be called multiple times when a new flow is deployed.\n     *\n     * @param node the node to extract credentials from\n     */\n    extract: function(node) {\n        var nodeID = node.id;\n        var nodeType = node.type;\n        var newCreds = node.credentials;\n        if (newCreds) {\n            delete node.credentials;\n            var savedCredentials = credentialCache[nodeID] || {};\n            var dashedType = nodeType.replace(/\\s+/g, '-');\n            var definition = credentialsDef[dashedType];\n            if (!definition) {\n                log.warn(log._(\"nodes.credentials.not-registered\",{type:nodeType}));\n                return;\n            }\n\n            for (var cred in definition) {\n                if (definition.hasOwnProperty(cred)) {\n                    if (newCreds[cred] === undefined) {\n                        continue;\n                    }\n                    if (definition[cred].type == \"password\" && newCreds[cred] == '__PWRD__') {\n                        continue;\n                    }\n                    if (0 === newCreds[cred].length || /^\\s*$/.test(newCreds[cred])) {\n                        delete savedCredentials[cred];\n                        dirty = true;\n                        continue;\n                    }\n                    if (!savedCredentials.hasOwnProperty(cred) || JSON.stringify(savedCredentials[cred]) !== JSON.stringify(newCreds[cred])) {\n                        savedCredentials[cred] = newCreds[cred];\n                        dirty = true;\n                    }\n                }\n            }\n            credentialCache[nodeID] = savedCredentials;\n        }\n    },\n\n    /**\n     * Gets the credential definition for the given node type\n     * @param type the node type\n     * @return the credential definition\n     */\n    getDefinition: function (type) {\n        return credentialsDef[type];\n    },\n\n    dirty: function() {\n        return dirty;\n    },\n\n    export: function() {\n        var result = credentialCache;\n        if (encryptionEnabled) {\n            if (dirty) {\n                try {\n                    log.debug(\"red/runtime/nodes/credentials.export : encrypting\");\n                    var initVector = crypto.randomBytes(16);\n                    var cipher = crypto.createCipheriv(encryptionAlgorithm, encryptionKey, initVector);\n                    result = {\"$\":initVector.toString('hex') + cipher.update(JSON.stringify(credentialCache), 'utf8', 'base64') + cipher.final('base64')};\n                } catch(err) {\n                    log.warn(log._(\"nodes.credentials.error-saving\",{message:err.toString()}))\n                }\n            } else {\n                result = encryptedCredentials;\n            }\n        }\n        dirty = false;\n        if (removeDefaultKey) {\n            log.debug(\"red/runtime/nodes/credentials.export : removing unused default key\");\n            return settings.delete('_credentialSecret').then(function() {\n                removeDefaultKey = false;\n                return result;\n            })\n        } else {\n            return when.resolve(result);\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/flows/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar when = require(\"when\");\n\nvar Flow = require('./Flow');\n\nvar typeRegistry = require(\"../registry\");\nvar context = require(\"../context\")\nvar credentials = require(\"../credentials\");\n\nvar flowUtil = require(\"./util\");\nvar log = require(\"../../log\");\nvar events = require(\"../../events\");\nvar redUtil = require(\"../../util\");\nvar deprecated = require(\"../registry/deprecated\");\n\nvar storage = null;\nvar settings = null;\n\nvar activeConfig = null;\nvar activeFlowConfig = null;\n\nvar activeFlows = {};\nvar started = false;\n\nvar activeNodesToFlow = {};\nvar subflowInstanceNodeMap = {};\n\nvar typeEventRegistered = false;\n\nfunction init(runtime) {\n    if (started) {\n        throw new Error(\"Cannot init without a stop\");\n    }\n    settings = runtime.settings;\n    storage = runtime.storage;\n    started = false;\n    if (!typeEventRegistered) {\n        events.on('type-registered',function(type) {\n            if (activeFlowConfig && activeFlowConfig.missingTypes.length > 0) {\n                var i = activeFlowConfig.missingTypes.indexOf(type);\n                if (i != -1) {\n                    log.info(log._(\"nodes.flows.registered-missing\", {type:type}));\n                    activeFlowConfig.missingTypes.splice(i,1);\n                    if (activeFlowConfig.missingTypes.length === 0 && started) {\n                        events.emit(\"runtime-event\",{id:\"runtime-state\"});\n                        start();\n                    }\n                }\n            }\n        });\n        typeEventRegistered = true;\n    }\n}\n\nfunction loadFlows() {\n    return storage.getFlows().then(function(config) {\n        log.debug(\"loaded flow revision: \"+config.rev);\n        return credentials.load(config.credentials).then(function() {\n            return config;\n        });\n    }).otherwise(function(err) {\n        log.warn(log._(\"nodes.flows.error\",{message:err.toString()}));\n        console.log(err.stack);\n    });\n}\nfunction load() {\n    return setFlows(null,\"load\",false);\n}\n\n/*\n * _config - new node array configuration\n * type - full/nodes/flows/load (default full)\n * muteLog - don't emit the standard log messages (used for individual flow api)\n */\nfunction setFlows(_config,type,muteLog) {\n    type = type||\"full\";\n\n    var configSavePromise = null;\n    var config = null;\n    var diff;\n    var newFlowConfig;\n    var isLoad = false;\n    if (type === \"load\") {\n        isLoad = true;\n        configSavePromise = loadFlows().then(function(_config) {\n            config = clone(_config.flows);\n            newFlowConfig = flowUtil.parseConfig(clone(config));\n            type = \"full\";\n            return _config.rev;\n        });\n    } else {\n        config = clone(_config);\n        newFlowConfig = flowUtil.parseConfig(clone(config));\n        if (type !== 'full') {\n            diff = flowUtil.diffConfigs(activeFlowConfig,newFlowConfig);\n        }\n        credentials.clean(config);\n        var credsDirty = credentials.dirty();\n        configSavePromise = credentials.export().then(function(creds) {\n            var saveConfig = {\n                flows: config,\n                credentialsDirty:credsDirty,\n                credentials: creds\n            }\n            return storage.saveFlows(saveConfig);\n        });\n    }\n\n    return configSavePromise\n        .then(function(flowRevision) {\n            if (!isLoad) {\n                log.debug(\"saved flow revision: \"+flowRevision);\n            }\n            activeConfig = {\n                flows:config,\n                rev:flowRevision\n            };\n            activeFlowConfig = newFlowConfig;\n            if (started) {\n                return stop(type,diff,muteLog).then(function() {\n                    context.clean(activeFlowConfig);\n                    start(type,diff,muteLog);\n                    return flowRevision;\n                }).otherwise(function(err) {\n                })\n            }\n        });\n}\n\nfunction getNode(id) {\n    var node;\n    if (activeNodesToFlow[id] && activeFlows[activeNodesToFlow[id]]) {\n        return activeFlows[activeNodesToFlow[id]].getNode(id);\n    }\n    for (var flowId in activeFlows) {\n        if (activeFlows.hasOwnProperty(flowId)) {\n            node = activeFlows[flowId].getNode(id);\n            if (node) {\n                return node;\n            }\n        }\n    }\n    return null;\n}\n\nfunction eachNode(cb) {\n    for (var id in activeFlowConfig.allNodes) {\n        if (activeFlowConfig.allNodes.hasOwnProperty(id)) {\n            cb(activeFlowConfig.allNodes[id]);\n        }\n    }\n}\n\nfunction getFlows() {\n    return activeConfig;\n}\n\nfunction delegateError(node,logMessage,msg) {\n    if (activeFlows[node.z]) {\n        activeFlows[node.z].handleError(node,logMessage,msg);\n    } else if (activeNodesToFlow[node.z] && activeFlows[activeNodesToFlow[node.z]]) {\n        activeFlows[activeNodesToFlow[node.z]].handleError(node,logMessage,msg);\n    } else if (activeFlowConfig.subflows[node.z] && subflowInstanceNodeMap[node.id]) {\n        subflowInstanceNodeMap[node.id].forEach(function(n) {\n            delegateError(getNode(n),logMessage,msg);\n        });\n    }\n}\nfunction handleError(node,logMessage,msg) {\n    if (node.z) {\n        delegateError(node,logMessage,msg);\n    } else {\n        if (activeFlowConfig.configs[node.id]) {\n            activeFlowConfig.configs[node.id]._users.forEach(function(id) {\n                var userNode = activeFlowConfig.allNodes[id];\n                delegateError(userNode,logMessage,msg);\n            })\n        }\n    }\n}\n\nfunction delegateStatus(node,statusMessage) {\n    if (activeFlows[node.z]) {\n        activeFlows[node.z].handleStatus(node,statusMessage);\n    } else if (activeNodesToFlow[node.z] && activeFlows[activeNodesToFlow[node.z]]) {\n        activeFlows[activeNodesToFlow[node.z]].handleStatus(node,statusMessage);\n    }\n}\nfunction handleStatus(node,statusMessage) {\n    events.emit(\"node-status\",{\n        id: node.id,\n        status:statusMessage\n    });\n    if (node.z) {\n        delegateStatus(node,statusMessage);\n    } else {\n        if (activeFlowConfig.configs[node.id]) {\n            activeFlowConfig.configs[node.id]._users.forEach(function(id) {\n                var userNode = activeFlowConfig.allNodes[id];\n                delegateStatus(userNode,statusMessage);\n            })\n        }\n    }\n}\n\n\nfunction start(type,diff,muteLog) {\n    //dumpActiveNodes();\n    type = type||\"full\";\n    started = true;\n    var i;\n    if (activeFlowConfig.missingTypes.length > 0) {\n        log.info(log._(\"nodes.flows.missing-types\"));\n        var knownUnknowns = 0;\n        for (i=0;i<activeFlowConfig.missingTypes.length;i++) {\n            var nodeType = activeFlowConfig.missingTypes[i];\n            var info = deprecated.get(nodeType);\n            if (info) {\n                log.info(log._(\"nodes.flows.missing-type-provided\",{type:activeFlowConfig.missingTypes[i],module:info.module}));\n                knownUnknowns += 1;\n            } else {\n                log.info(\" - \"+activeFlowConfig.missingTypes[i]);\n            }\n        }\n        if (knownUnknowns > 0) {\n            log.info(log._(\"nodes.flows.missing-type-install-1\"));\n            log.info(\"  npm install <module name>\");\n            log.info(log._(\"nodes.flows.missing-type-install-2\"));\n            log.info(\"  \"+settings.userDir);\n        }\n        events.emit(\"runtime-event\",{id:\"runtime-state\",type:\"warning\",text:\"notification.warnings.missing-types\"});\n        return when.resolve();\n    }\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.starting-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.starting-flows\"));\n        }\n    }\n    var id;\n    if (!diff) {\n        if (!activeFlows['global']) {\n            activeFlows['global'] = Flow.create(activeFlowConfig);\n        }\n        for (id in activeFlowConfig.flows) {\n            if (activeFlowConfig.flows.hasOwnProperty(id)) {\n                if (!activeFlows[id]) {\n                    activeFlows[id] = Flow.create(activeFlowConfig,activeFlowConfig.flows[id]);\n                }\n            }\n        }\n    } else {\n        activeFlows['global'].update(activeFlowConfig,activeFlowConfig);\n        for (id in activeFlowConfig.flows) {\n            if (activeFlowConfig.flows.hasOwnProperty(id)) {\n                if (activeFlows[id]) {\n                    activeFlows[id].update(activeFlowConfig,activeFlowConfig.flows[id]);\n                } else {\n                    activeFlows[id] = Flow.create(activeFlowConfig,activeFlowConfig.flows[id]);\n                }\n            }\n        }\n    }\n\n    for (id in activeFlows) {\n        if (activeFlows.hasOwnProperty(id)) {\n            activeFlows[id].start(diff);\n            var activeNodes = activeFlows[id].getActiveNodes();\n            Object.keys(activeNodes).forEach(function(nid) {\n                activeNodesToFlow[nid] = id;\n                if (activeNodes[nid]._alias) {\n                    subflowInstanceNodeMap[activeNodes[nid]._alias] = subflowInstanceNodeMap[activeNodes[nid]._alias] || [];\n                    subflowInstanceNodeMap[activeNodes[nid]._alias].push(nid);\n                }\n            });\n\n        }\n    }\n    events.emit(\"nodes-started\");\n    events.emit(\"runtime-event\",{id:\"runtime-state\"});\n\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.started-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.started-flows\"));\n        }\n    }\n    return when.resolve();\n}\n\nfunction stop(type,diff,muteLog) {\n    type = type||\"full\";\n    if (!muteLog) {\n        if (diff) {\n            log.info(log._(\"nodes.flows.stopping-modified-\"+type));\n        } else {\n            log.info(log._(\"nodes.flows.stopping-flows\"));\n        }\n    }\n    started = false;\n    var promises = [];\n    var stopList;\n    if (type === 'nodes') {\n        stopList = diff.changed.concat(diff.removed);\n    } else if (type === 'flows') {\n        stopList = diff.changed.concat(diff.removed).concat(diff.linked);\n    }\n    for (var id in activeFlows) {\n        if (activeFlows.hasOwnProperty(id)) {\n            promises = promises.concat(activeFlows[id].stop(stopList));\n            if (!diff || diff.removed.indexOf(id)!==-1) {\n                delete activeFlows[id];\n            }\n        }\n    }\n\n    return when.promise(function(resolve,reject) {\n        when.settle(promises).then(function() {\n            for (id in activeNodesToFlow) {\n                if (activeNodesToFlow.hasOwnProperty(id)) {\n                    if (!activeFlows[activeNodesToFlow[id]]) {\n                        delete activeNodesToFlow[id];\n                    }\n                }\n            }\n            if (stopList) {\n                stopList.forEach(function(id) {\n                    delete activeNodesToFlow[id];\n                });\n            }\n            // Ideally we'd prune just what got stopped - but mapping stopList\n            // id to the list of subflow instance nodes is something only Flow\n            // can do... so cheat by wiping the map knowing it'll be rebuilt\n            // in start()\n            subflowInstanceNodeMap = {};\n            if (!muteLog) {\n                if (diff) {\n                    log.info(log._(\"nodes.flows.stopped-modified-\"+type));\n                } else {\n                    log.info(log._(\"nodes.flows.stopped-flows\"));\n                }\n            }\n            resolve();\n        });\n    });\n}\n\n\nfunction checkTypeInUse(id) {\n    var nodeInfo = typeRegistry.getNodeInfo(id);\n    if (!nodeInfo) {\n        throw new Error(log._(\"nodes.index.unrecognised-id\", {id:id}));\n    } else {\n        var inUse = {};\n        var config = getFlows();\n        config.flows.forEach(function(n) {\n            inUse[n.type] = (inUse[n.type]||0)+1;\n        });\n        var nodesInUse = [];\n        nodeInfo.types.forEach(function(t) {\n            if (inUse[t]) {\n                nodesInUse.push(t);\n            }\n        });\n        if (nodesInUse.length > 0) {\n            var msg = nodesInUse.join(\", \");\n            var err = new Error(log._(\"nodes.index.type-in-use\", {msg:msg}));\n            err.code = \"type_in_use\";\n            throw err;\n        }\n    }\n}\n\nfunction updateMissingTypes() {\n    var subflowInstanceRE = /^subflow:(.+)$/;\n    activeFlowConfig.missingTypes = [];\n\n    for (var id in activeFlowConfig.allNodes) {\n        if (activeFlowConfig.allNodes.hasOwnProperty(id)) {\n            var node = activeFlowConfig.allNodes[id];\n            if (node.type !== 'tab' && node.type !== 'subflow') {\n                var subflowDetails = subflowInstanceRE.exec(node.type);\n                if ( (subflowDetails && !activeFlowConfig.subflows[subflowDetails[1]]) || (!subflowDetails && !typeRegistry.get(node.type)) ) {\n                    if (activeFlowConfig.missingTypes.indexOf(node.type) === -1) {\n                        activeFlowConfig.missingTypes.push(node.type);\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction addFlow(flow) {\n    var i,node;\n    if (!flow.hasOwnProperty('nodes')) {\n        throw new Error('missing nodes property');\n    }\n    flow.id = redUtil.generateId();\n\n    var nodes = [{\n        type:'tab',\n        label:flow.label,\n        id:flow.id\n    }];\n\n    for (i=0;i<flow.nodes.length;i++) {\n        node = flow.nodes[i];\n        if (activeFlowConfig.allNodes[node.id]) {\n            // TODO nls\n            return when.reject(new Error('duplicate id'));\n        }\n        if (node.type === 'tab' || node.type === 'subflow') {\n            return when.reject(new Error('invalid node type: '+node.type));\n        }\n        node.z = flow.id;\n        nodes.push(node);\n    }\n    if (flow.configs) {\n        for (i=0;i<flow.configs.length;i++) {\n            node = flow.configs[i];\n            if (activeFlowConfig.allNodes[node.id]) {\n                // TODO nls\n                return when.reject(new Error('duplicate id'));\n            }\n            if (node.type === 'tab' || node.type === 'subflow') {\n                return when.reject(new Error('invalid node type: '+node.type));\n            }\n            node.z = flow.id;\n            nodes.push(node);\n        }\n    }\n    var newConfig = clone(activeConfig.flows);\n    newConfig = newConfig.concat(nodes);\n\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.added-flow\",{label:(flow.label?flow.label+\" \":\"\")+\"[\"+flow.id+\"]\"}));\n        return flow.id;\n    });\n}\n\nfunction getFlow(id) {\n    var flow;\n    if (id === 'global') {\n        flow = activeFlowConfig;\n    } else {\n        flow = activeFlowConfig.flows[id];\n    }\n    if (!flow) {\n        return null;\n    }\n    var result = {\n        id: id\n    };\n    if (flow.label) {\n        result.label = flow.label;\n    }\n    if (id !== 'global') {\n        result.nodes = [];\n    }\n    if (flow.nodes) {\n        var nodeIds = Object.keys(flow.nodes);\n        if (nodeIds.length > 0) {\n            result.nodes = nodeIds.map(function(nodeId) {\n                var node = clone(flow.nodes[nodeId]);\n                if (node.type === 'link out') {\n                    delete node.wires;\n                }\n                return node;\n            })\n        }\n    }\n    if (flow.configs) {\n        var configIds = Object.keys(flow.configs);\n        result.configs = configIds.map(function(configId) {\n            return clone(flow.configs[configId]);\n        })\n        if (result.configs.length === 0) {\n            delete result.configs;\n        }\n    }\n    if (flow.subflows) {\n        var subflowIds = Object.keys(flow.subflows);\n        result.subflows = subflowIds.map(function(subflowId) {\n            var subflow = clone(flow.subflows[subflowId]);\n            var nodeIds = Object.keys(subflow.nodes);\n            subflow.nodes = nodeIds.map(function(id) {\n                return subflow.nodes[id];\n            });\n            if (subflow.configs) {\n                var configIds = Object.keys(subflow.configs);\n                subflow.configs = configIds.map(function(id) {\n                    return subflow.configs[id];\n                })\n            }\n            delete subflow.instances;\n            return subflow;\n        });\n        if (result.subflows.length === 0) {\n            delete result.subflows;\n        }\n    }\n    return result;\n}\n\nfunction updateFlow(id,newFlow) {\n    var label = id;\n    if (id !== 'global') {\n        if (!activeFlowConfig.flows[id]) {\n            var e = new Error();\n            e.code = 404;\n            throw e;\n        }\n        label = activeFlowConfig.flows[id].label;\n    }\n    var newConfig = clone(activeConfig.flows);\n    var nodes;\n\n    if (id === 'global') {\n        // Remove all nodes whose z is not a known flow\n        // When subflows can be owned by a flow, this logic will have to take\n        // that into account\n        newConfig = newConfig.filter(function(node) {\n            return node.type === 'tab' || (node.hasOwnProperty('z') && activeFlowConfig.flows.hasOwnProperty(node.z));\n        })\n\n        // Add in the new config nodes\n        nodes = newFlow.configs||[];\n        if (newFlow.subflows) {\n            // Add in the new subflows\n            newFlow.subflows.forEach(function(sf) {\n                nodes = nodes.concat(sf.nodes||[]).concat(sf.configs||[]);\n                delete sf.nodes;\n                delete sf.configs;\n                nodes.push(sf);\n            });\n        }\n    } else {\n        newConfig = newConfig.filter(function(node) {\n            return node.z !== id && node.id !== id;\n        });\n        var tabNode = {\n            type:'tab',\n            label:newFlow.label,\n            id:id\n        }\n        nodes = [tabNode].concat(newFlow.nodes||[]).concat(newFlow.configs||[]);\n        nodes.forEach(function(n) {\n            n.z = id;\n        });\n    }\n\n    newConfig = newConfig.concat(nodes);\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.updated-flow\",{label:(label?label+\" \":\"\")+\"[\"+id+\"]\"}));\n    })\n}\n\nfunction removeFlow(id) {\n    if (id === 'global') {\n        // TODO: nls + error code\n        throw new Error('not allowed to remove global');\n    }\n    var flow = activeFlowConfig.flows[id];\n    if (!flow) {\n        var e = new Error();\n        e.code = 404;\n        throw e;\n    }\n\n    var newConfig = clone(activeConfig.flows);\n    newConfig = newConfig.filter(function(node) {\n        return node.z !== id && node.id !== id;\n    });\n\n    return setFlows(newConfig,'flows',true).then(function() {\n        log.info(log._(\"nodes.flows.removed-flow\",{label:(flow.label?flow.label+\" \":\"\")+\"[\"+flow.id+\"]\"}));\n    });\n}\n\nmodule.exports = {\n    init: init,\n\n    /**\n     * Load the current flow configuration from storage\n     * @return a promise for the loading of the config\n     */\n    load: load,\n\n    get:getNode,\n    eachNode: eachNode,\n\n    /**\n     * Gets the current flow configuration\n     */\n    getFlows: getFlows,\n\n    /**\n     * Sets the current active config.\n     * @param config the configuration to enable\n     * @param type the type of deployment to do: full (default), nodes, flows, load\n     * @return a promise for the saving/starting of the new flow\n     */\n    setFlows: setFlows,\n\n    /**\n     * Starts the current flow configuration\n     */\n    startFlows: start,\n\n    /**\n     * Stops the current flow configuration\n     * @return a promise for the stopping of the flow\n     */\n    stopFlows: stop,\n\n    get started() { return started },\n\n    handleError: handleError,\n    handleStatus: handleStatus,\n\n    checkTypeInUse: checkTypeInUse,\n\n    addFlow: addFlow,\n    getFlow: getFlow,\n    updateFlow: updateFlow,\n    removeFlow: removeFlow,\n    disableFlow:null,\n    enableFlow:null\n\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/flows/Flow.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar clone = require(\"clone\");\nvar typeRegistry = require(\"../registry\");\nvar Log = require(\"../../log\");\nvar redUtil = require(\"../../util\");\nvar flowUtil = require(\"./util\");\n\nfunction Flow(global,flow) {\n    if (typeof flow === 'undefined') {\n        flow = global;\n    }\n    var activeNodes = {};\n    var subflowInstanceNodes = {};\n    var catchNodeMap = {};\n    var statusNodeMap = {};\n\n    this.start = function(diff) {\n        var node;\n        var newNode;\n        var id;\n        catchNodeMap = {};\n        statusNodeMap = {};\n\n        var configNodes = Object.keys(flow.configs);\n        var configNodeAttempts = {};\n        while (configNodes.length > 0) {\n            id = configNodes.shift();\n            node = flow.configs[id];\n            if (!activeNodes[id]) {\n                var readyToCreate = true;\n                // This node doesn't exist.\n                // Check it doesn't reference another non-existent config node\n                for (var prop in node) {\n                    if (node.hasOwnProperty(prop) && prop !== 'id' && prop !== 'wires' && prop !== '_users' && flow.configs[node[prop]]) {\n                        if (!activeNodes[node[prop]]) {\n                            // References a non-existent config node\n                            // Add it to the back of the list to try again later\n                            configNodes.push(id);\n                            configNodeAttempts[id] = (configNodeAttempts[id]||0)+1;\n                            if (configNodeAttempts[id] === 100) {\n                                throw new Error(\"Circular config node dependency detected: \"+id);\n                            }\n                            readyToCreate = false;\n                            break;\n                        }\n                    }\n                }\n                if (readyToCreate) {\n                    newNode = createNode(node.type,node);\n                    if (newNode) {\n                        activeNodes[id] = newNode;\n                    }\n                }\n            }\n        }\n\n        if (diff && diff.rewired) {\n            for (var j=0;j<diff.rewired.length;j++) {\n                var rewireNode = activeNodes[diff.rewired[j]];\n                if (rewireNode) {\n                    rewireNode.updateWires(flow.nodes[rewireNode.id].wires);\n                }\n            }\n        }\n\n        for (id in flow.nodes) {\n            if (flow.nodes.hasOwnProperty(id)) {\n                node = flow.nodes[id];\n                if (!node.subflow) {\n                    if (!activeNodes[id]) {\n                        newNode = createNode(node.type,node);\n                        if (newNode) {\n                            activeNodes[id] = newNode;\n                        }\n                    }\n                } else {\n                    if (!subflowInstanceNodes[id]) {\n                        try {\n                            var nodes = createSubflow(flow.subflows[node.subflow]||global.subflows[node.subflow],node,flow.subflows,global.subflows,activeNodes);\n                            subflowInstanceNodes[id] = nodes.map(function(n) { return n.id});\n                            for (var i=0;i<nodes.length;i++) {\n                                if (nodes[i]) {\n                                    activeNodes[nodes[i].id] = nodes[i];\n                                }\n                            }\n                        } catch(err) {\n                            console.log(err.stack)\n                        }\n                    }\n                }\n            }\n        }\n\n        for (id in activeNodes) {\n            if (activeNodes.hasOwnProperty(id)) {\n                node = activeNodes[id];\n                if (node.type === \"catch\") {\n                    catchNodeMap[node.z] = catchNodeMap[node.z] || [];\n                    catchNodeMap[node.z].push(node);\n                } else if (node.type === \"status\") {\n                    statusNodeMap[node.z] = statusNodeMap[node.z] || [];\n                    statusNodeMap[node.z].push(node);\n                }\n            }\n        }\n    }\n\n    this.stop = function(stopList) {\n        return when.promise(function(resolve) {\n            var i;\n            if (stopList) {\n                for (i=0;i<stopList.length;i++) {\n                    if (subflowInstanceNodes[stopList[i]]) {\n                        // The first in the list is the instance node we already\n                        // know about\n                        stopList = stopList.concat(subflowInstanceNodes[stopList[i]].slice(1))\n                    }\n                }\n            } else {\n                stopList = Object.keys(activeNodes);\n            }\n            var promises = [];\n            for (i=0;i<stopList.length;i++) {\n                var node = activeNodes[stopList[i]];\n                if (node) {\n                    delete activeNodes[stopList[i]];\n                    if (subflowInstanceNodes[stopList[i]]) {\n                        delete subflowInstanceNodes[stopList[i]];\n                    }\n                    try {\n                        var p = node.close();\n                        if (p) {\n                            promises.push(p);\n                        }\n                    } catch(err) {\n                        node.error(err);\n                    }\n                }\n            }\n            when.settle(promises).then(function() {\n                resolve();\n            });\n        });\n    }\n\n    this.update = function(_global,_flow) {\n        global = _global;\n        flow = _flow;\n    }\n\n    this.getNode = function(id) {\n        return activeNodes[id];\n    }\n\n    this.getActiveNodes = function() {\n        return activeNodes;\n    }\n\n    this.handleStatus = function(node,statusMessage) {\n        var targetStatusNodes = null;\n        var reportingNode = node;\n        var handled = false;\n        while (reportingNode && !handled) {\n            targetStatusNodes = statusNodeMap[reportingNode.z];\n            if (targetStatusNodes) {\n                targetStatusNodes.forEach(function(targetStatusNode) {\n                    if (targetStatusNode.scope && targetStatusNode.scope.indexOf(node.id) === -1) {\n                        return;\n                    }\n                    var message = {\n                        status: {\n                            text: \"\",\n                            source: {\n                                id: node.id,\n                                type: node.type,\n                                name: node.name\n                            }\n                        }\n                    };\n                    if (statusMessage.hasOwnProperty(\"text\")) {\n                        message.status.text = statusMessage.text.toString();\n                    }\n                    targetStatusNode.receive(message);\n                    handled = true;\n                });\n            }\n            if (!handled) {\n                reportingNode = activeNodes[reportingNode.z];\n            }\n        }\n    }\n\n    this.handleError = function(node,logMessage,msg) {\n        var count = 1;\n        if (msg && msg.hasOwnProperty(\"error\")) {\n            if (msg.error.hasOwnProperty(\"source\")) {\n                if (msg.error.source.id === node.id) {\n                    count = msg.error.source.count+1;\n                    if (count === 10) {\n                        node.warn(Log._(\"nodes.flow.error-loop\"));\n                        return;\n                    }\n                }\n            }\n        }\n        var targetCatchNodes = null;\n        var throwingNode = node;\n        var handled = false;\n        while (throwingNode && !handled) {\n            targetCatchNodes = catchNodeMap[throwingNode.z];\n            if (targetCatchNodes) {\n                targetCatchNodes.forEach(function(targetCatchNode) {\n                    if (targetCatchNode.scope && targetCatchNode.scope.indexOf(throwingNode.id) === -1) {\n                        return;\n                    }\n                    var errorMessage;\n                    if (msg) {\n                        errorMessage = redUtil.cloneMessage(msg);\n                    } else {\n                        errorMessage = {};\n                    }\n                    if (errorMessage.hasOwnProperty(\"error\")) {\n                        errorMessage._error = errorMessage.error;\n                    }\n                    errorMessage.error = {\n                        message: logMessage.toString(),\n                        source: {\n                            id: node.id,\n                            type: node.type,\n                            name: node.name,\n                            count: count\n                        }\n                    };\n                    if (logMessage.hasOwnProperty('stack')) {\n                        errorMessage.error.stack = logMessage.stack;\n                    }\n                    targetCatchNode.receive(errorMessage);\n                    handled = true;\n                });\n            }\n            if (!handled) {\n                throwingNode = activeNodes[throwingNode.z];\n            }\n        }\n    }\n}\n\nfunction createNode(type,config) {\n    var nn = null;\n    var nt = typeRegistry.get(type);\n    if (nt) {\n        var conf = clone(config);\n        delete conf.credentials;\n        for (var p in conf) {\n            if (conf.hasOwnProperty(p)) {\n                flowUtil.mapEnvVarProperties(conf,p);\n            }\n        }\n        try {\n            nn = new nt(conf);\n        }\n        catch (err) {\n            Log.log({\n                level: Log.ERROR,\n                id:conf.id,\n                type: type,\n                msg: err\n            });\n        }\n    } else {\n        Log.error(Log._(\"nodes.flow.unknown-type\", {type:type}));\n    }\n    return nn;\n}\n\nfunction createSubflow(sf,sfn,subflows,globalSubflows,activeNodes) {\n    //console.log(\"CREATE SUBFLOW\",sf.id,sfn.id);\n    var nodes = [];\n    var node_map = {};\n    var newNodes = [];\n    var node;\n    var wires;\n    var i,j,k;\n\n    var createNodeInSubflow = function(def) {\n        node = clone(def);\n        var nid = redUtil.generateId();\n        node_map[node.id] = node;\n        node._alias = node.id;\n        node.id = nid;\n        node.z = sfn.id;\n        newNodes.push(node);\n    }\n\n    // Clone all of the subflow node definitions and give them new IDs\n    for (i in sf.configs) {\n        if (sf.configs.hasOwnProperty(i)) {\n            createNodeInSubflow(sf.configs[i]);\n        }\n    }\n    // Clone all of the subflow node definitions and give them new IDs\n    for (i in sf.nodes) {\n        if (sf.nodes.hasOwnProperty(i)) {\n            createNodeInSubflow(sf.nodes[i]);\n        }\n    }\n\n    // Look for any catch/status nodes and update their scope ids\n    // Update all subflow interior wiring to reflect new node IDs\n    for (i=0;i<newNodes.length;i++) {\n        node = newNodes[i];\n        if (node.wires) {\n            var outputs = node.wires;\n            for (j=0;j<outputs.length;j++) {\n                wires = outputs[j];\n                for (k=0;k<wires.length;k++) {\n                    outputs[j][k] = node_map[outputs[j][k]].id\n                }\n            }\n            if ((node.type === 'catch' || node.type === 'status') && node.scope) {\n                node.scope = node.scope.map(function(id) {\n                    return node_map[id]?node_map[id].id:\"\"\n                })\n            } else {\n                for (var prop in node) {\n                    if (node.hasOwnProperty(prop) && prop !== '_alias') {\n                        if (node_map[node[prop]]) {\n                            //console.log(\"Mapped\",node.type,node.id,prop,node_map[node[prop]].id);\n                            node[prop] = node_map[node[prop]].id;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Create a subflow node to accept inbound messages and route appropriately\n    var Node = require(\"../Node\");\n    var subflowInstance = {\n        id: sfn.id,\n        type: sfn.type,\n        z: sfn.z,\n        name: sfn.name,\n        wires: []\n    }\n    if (sf.in) {\n        subflowInstance.wires = sf.in.map(function(n) { return n.wires.map(function(w) { return node_map[w.id].id;})})\n        subflowInstance._originalWires = clone(subflowInstance.wires);\n    }\n    var subflowNode = new Node(subflowInstance);\n\n    subflowNode.on(\"input\", function(msg) { this.send(msg);});\n\n\n    subflowNode._updateWires = subflowNode.updateWires;\n\n    subflowNode.updateWires = function(newWires) {\n        // Wire the subflow outputs\n        if (sf.out) {\n            var node,wires,i,j;\n            // Restore the original wiring to the internal nodes\n            subflowInstance.wires = clone(subflowInstance._originalWires);\n            for (i=0;i<sf.out.length;i++) {\n                wires = sf.out[i].wires;\n                for (j=0;j<wires.length;j++) {\n                    if (wires[j].id != sf.id) {\n                        node = node_map[wires[j].id];\n                        if (node._originalWires) {\n                            node.wires = clone(node._originalWires);\n                        }\n                    }\n                }\n            }\n\n            var modifiedNodes = {};\n            var subflowInstanceModified = false;\n\n            for (i=0;i<sf.out.length;i++) {\n                wires = sf.out[i].wires;\n                for (j=0;j<wires.length;j++) {\n                    if (wires[j].id === sf.id) {\n                        subflowInstance.wires[wires[j].port] = subflowInstance.wires[wires[j].port].concat(newWires[i]);\n                        subflowInstanceModified = true;\n                    } else {\n                        node = node_map[wires[j].id];\n                        node.wires[wires[j].port] = node.wires[wires[j].port].concat(newWires[i]);\n                        modifiedNodes[node.id] = node;\n                    }\n                }\n            }\n            Object.keys(modifiedNodes).forEach(function(id) {\n                var node = modifiedNodes[id];\n                subflowNode.instanceNodes[id].updateWires(node.wires);\n            });\n            if (subflowInstanceModified) {\n                subflowNode._updateWires(subflowInstance.wires);\n            }\n        }\n    }\n\n    nodes.push(subflowNode);\n\n    // Wire the subflow outputs\n    if (sf.out) {\n        var modifiedNodes = {};\n        for (i=0;i<sf.out.length;i++) {\n            wires = sf.out[i].wires;\n            for (j=0;j<wires.length;j++) {\n                if (wires[j].id === sf.id) {\n                    // A subflow input wired straight to a subflow output\n                    subflowInstance.wires[wires[j].port] = subflowInstance.wires[wires[j].port].concat(sfn.wires[i])\n                    subflowNode._updateWires(subflowInstance.wires);\n                } else {\n                    node = node_map[wires[j].id];\n                    modifiedNodes[node.id] = node;\n                    if (!node._originalWires) {\n                        node._originalWires = clone(node.wires);\n                    }\n                    node.wires[wires[j].port] = (node.wires[wires[j].port]||[]).concat(sfn.wires[i]);\n                }\n            }\n        }\n    }\n\n    // Instantiate the nodes\n    for (i=0;i<newNodes.length;i++) {\n        node = newNodes[i];\n        var type = node.type;\n\n        var m = /^subflow:(.+)$/.exec(type);\n        if (!m) {\n            var newNode = createNode(type,node);\n            if (newNode) {\n                activeNodes[node.id] = newNode;\n                nodes.push(newNode);\n            }\n        } else {\n            var subflowId = m[1];\n            nodes = nodes.concat(createSubflow(subflows[subflowId]||globalSubflows[subflowId],node,subflows,globalSubflows,activeNodes));\n        }\n    }\n\n    subflowNode.instanceNodes = {};\n\n    nodes.forEach(function(node) {\n        subflowNode.instanceNodes[node.id] = node;\n    });\n    return nodes;\n}\n\nmodule.exports = {\n    create: function(global,conf) {\n        return new Flow(global,conf);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/util.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar jsonata = require(\"jsonata\");\n\nfunction generateId() {\n    return (1+Math.random()*4294967295).toString(16);\n}\n\nfunction ensureString(o) {\n    if (Buffer.isBuffer(o)) {\n        return o.toString();\n    } else if (typeof o === \"object\") {\n        return JSON.stringify(o);\n    } else if (typeof o === \"string\") {\n        return o;\n    }\n    return \"\"+o;\n}\n\nfunction ensureBuffer(o) {\n    if (Buffer.isBuffer(o)) {\n        return o;\n    } else if (typeof o === \"object\") {\n        o = JSON.stringify(o);\n    } else if (typeof o !== \"string\") {\n        o = \"\"+o;\n    }\n    return new Buffer(o);\n}\n\nfunction cloneMessage(msg) {\n    // Temporary fix for #97\n    // TODO: remove this http-node-specific fix somehow\n    var req = msg.req;\n    var res = msg.res;\n    delete msg.req;\n    delete msg.res;\n    var m = clone(msg);\n    if (req) {\n        m.req = req;\n        msg.req = req;\n    }\n    if (res) {\n        m.res = res;\n        msg.res = res;\n    }\n    return m;\n}\n\nfunction compareObjects(obj1,obj2) {\n    var i;\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n\n    var isArray1 = Array.isArray(obj1);\n    var isArray2 = Array.isArray(obj2);\n    if (isArray1 != isArray2) {\n        return false;\n    }\n    if (isArray1 && isArray2) {\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (i=0;i<obj1.length;i++) {\n            if (!compareObjects(obj1[i],obj2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    var isBuffer1 = Buffer.isBuffer(obj1);\n    var isBuffer2 = Buffer.isBuffer(obj2);\n    if (isBuffer1 != isBuffer2) {\n        return false;\n    }\n    if (isBuffer1 && isBuffer2) {\n        if (obj1.equals) {\n            // For node 0.12+ - use the native equals\n            return obj1.equals(obj2);\n        } else {\n            if (obj1.length !== obj2.length) {\n                return false;\n            }\n            for (i=0;i<obj1.length;i++) {\n                if (obj1.readUInt8(i) !== obj2.readUInt8(i)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {\n        return false;\n    }\n    var keys1 = Object.keys(obj1);\n    var keys2 = Object.keys(obj2);\n    if (keys1.length != keys2.length) {\n        return false;\n    }\n    for (var k in obj1) {\n        /* istanbul ignore else */\n        if (obj1.hasOwnProperty(k)) {\n            if (!compareObjects(obj1[k],obj2[k])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction normalisePropertyExpression(str) {\n    // This must be kept in sync with validatePropertyExpression\n    // in editor/js/ui/utils.js\n\n    var length = str.length;\n    if (length === 0) {\n        throw new Error(\"Invalid property expression: zero-length\");\n    }\n    var parts = [];\n    var start = 0;\n    var inString = false;\n    var inBox = false;\n    var quoteChar;\n    var v;\n    for (var i=0;i<length;i++) {\n        var c = str[i];\n        if (!inString) {\n            if (c === \"'\" || c === '\"') {\n                if (i != start) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                inString = true;\n                quoteChar = c;\n                start = i+1;\n            } else if (c === '.') {\n                if (i===0) {\n                    throw new Error(\"Invalid property expression: unexpected . at position 0\");\n                }\n                if (start != i) {\n                    v = str.substring(start,i);\n                    if (/^\\d+$/.test(v)) {\n                        parts.push(parseInt(v));\n                    } else {\n                        parts.push(v);\n                    }\n                }\n                if (i===length-1) {\n                    throw new Error(\"Invalid property expression: unterminated expression\");\n                }\n                // Next char is first char of an identifier: a-z 0-9 $ _\n                if (!/[a-z0-9\\$\\_]/i.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" at position \"+(i+1));\n                }\n                start = i+1;\n            } else if (c === '[') {\n                if (i === 0) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                if (start != i) {\n                    parts.push(str.substring(start,i));\n                }\n                if (i===length-1) {\n                    throw new Error(\"Invalid property expression: unterminated expression\");\n                }\n                // Next char is either a quote or a number\n                if (!/[\"'\\d]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" at position \"+(i+1));\n                }\n                start = i+1;\n                inBox = true;\n            } else if (c === ']') {\n                if (!inBox) {\n                    throw new Error(\"Invalid property expression: unexpected \"+c+\" at position \"+i);\n                }\n                if (start != i) {\n                    v = str.substring(start,i);\n                    if (/^\\d+$/.test(v)) {\n                        parts.push(parseInt(v));\n                    } else {\n                        throw new Error(\"Invalid property expression: unexpected array expression at position \"+start);\n                    }\n                }\n                start = i+1;\n                inBox = false;\n            } else if (c === ' ') {\n                throw new Error(\"Invalid property expression: unexpected ' ' at position \"+i);\n            }\n        } else {\n            if (c === quoteChar) {\n                if (i-start === 0) {\n                    throw new Error(\"Invalid property expression: zero-length string at position \"+start);\n                }\n                parts.push(str.substring(start,i));\n                // If inBox, next char must be a ]. Otherwise it may be [ or .\n                if (inBox && !/\\]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected array expression at position \"+start);\n                } else if (!inBox && i+1!==length && !/[\\[\\.]/.test(str[i+1])) {\n                    throw new Error(\"Invalid property expression: unexpected \"+str[i+1]+\" expression at position \"+(i+1));\n                }\n                start = i+1;\n                inString = false;\n            }\n        }\n\n    }\n    if (inBox || inString) {\n        throw new Error(\"Invalid property expression: unterminated expression\");\n    }\n    if (start < length) {\n        parts.push(str.substring(start));\n    }\n    return parts;\n}\n\nfunction getMessageProperty(msg,expr) {\n    var result = null;\n    if (expr.indexOf('msg.')===0) {\n        expr = expr.substring(4);\n    }\n    var msgPropParts = normalisePropertyExpression(expr);\n    var m;\n    msgPropParts.reduce(function(obj, key) {\n        result = (typeof obj[key] !== \"undefined\" ? obj[key] : undefined);\n        return result;\n    }, msg);\n    return result;\n}\n\nfunction setMessageProperty(msg,prop,value,createMissing) {\n    if (typeof createMissing === 'undefined') {\n        createMissing = (typeof value !== 'undefined');\n    }\n    if (prop.indexOf('msg.')===0) {\n        prop = prop.substring(4);\n    }\n    var msgPropParts = normalisePropertyExpression(prop);\n    var depth = 0;\n    var length = msgPropParts.length;\n    var obj = msg;\n    var key;\n    for (var i=0;i<length-1;i++) {\n        key = msgPropParts[i];\n        if (typeof key === 'string' || (typeof key === 'number' && !Array.isArray(obj))) {\n            if (obj.hasOwnProperty(key)) {\n                obj = obj[key];\n            } else if (createMissing) {\n                if (typeof msgPropParts[i+1] === 'string') {\n                    obj[key] = {};\n                } else {\n                    obj[key] = [];\n                }\n                obj = obj[key];\n            } else {\n                return null;\n            }\n        } else if (typeof key === 'number') {\n            // obj is an array\n            if (obj[key] === undefined) {\n                if (createMissing) {\n                    if (typeof msgPropParts[i+1] === 'string') {\n                        obj[key] = {};\n                    } else {\n                        obj[key] = [];\n                    }\n                    obj = obj[key];\n                } else {\n                    return null\n                }\n            } else {\n                obj = obj[key];\n            }\n        }\n    }\n    key = msgPropParts[length-1];\n    if (typeof value === \"undefined\") {\n        if (typeof key === 'number' && Array.isArray(obj)) {\n            obj.splice(key,1);\n        } else {\n            delete obj[key]\n        }\n    } else {\n        obj[key] = value;\n    }\n}\n\nfunction evaluateNodeProperty(value, type, node, msg) {\n    if (type === 'str') {\n        return \"\"+value;\n    } else if (type === 'num') {\n        return Number(value);\n    } else if (type === 'json') {\n        return JSON.parse(value);\n    } else if (type === 're') {\n        return new RegExp(value);\n    } else if (type === 'date') {\n        return Date.now();\n    } else if (type === 'msg' && msg) {\n        return getMessageProperty(msg,value);\n    } else if (type === 'flow' && node) {\n        return node.context().flow.get(value);\n    } else if (type === 'global' && node) {\n        return node.context().global.get(value);\n    } else if (type === 'bool') {\n        return /^true$/i.test(value);\n    } else if (type === 'jsonata') {\n        return jsonata(value).evaluate({msg:msg});\n    }\n    return value;\n}\n\n\nmodule.exports = {\n    ensureString: ensureString,\n    ensureBuffer: ensureBuffer,\n    cloneMessage: cloneMessage,\n    compareObjects: compareObjects,\n    generateId: generateId,\n    getMessageProperty: getMessageProperty,\n    setMessageProperty: setMessageProperty,\n    evaluateNodeProperty: evaluateNodeProperty,\n    normalisePropertyExpression: normalisePropertyExpression\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/flows/util.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar clone = require(\"clone\");\nvar redUtil = require(\"../../util\");\nvar subflowInstanceRE = /^subflow:(.+)$/;\nvar typeRegistry = require(\"../registry\");\n\nfunction diffNodes(oldNode,newNode) {\n    if (oldNode == null) {\n        return true;\n    }\n    var oldKeys = Object.keys(oldNode).filter(function(p) { return p != \"x\" && p != \"y\" && p != \"wires\" });\n    var newKeys = Object.keys(newNode).filter(function(p) { return p != \"x\" && p != \"y\" && p != \"wires\" });\n    if (oldKeys.length != newKeys.length) {\n        return true;\n    }\n    for (var i=0;i<newKeys.length;i++) {\n        var p = newKeys[i];\n        if (!redUtil.compareObjects(oldNode[p],newNode[p])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nvar EnvVarPropertyRE = /^\\$\\((\\S+)\\)$/;\n\nfunction mapEnvVarProperties(obj,prop) {\n    if (Buffer.isBuffer(obj[prop])) {\n        return;\n    } else if (Array.isArray(obj[prop])) {\n        for (var i=0;i<obj[prop].length;i++) {\n            mapEnvVarProperties(obj[prop],i);\n        }\n    } else if (typeof obj[prop] === 'string') {\n        var m;\n        if ( (m = EnvVarPropertyRE.exec(obj[prop])) !== null) {\n            if (process.env.hasOwnProperty(m[1])) {\n                obj[prop] = process.env[m[1]];\n            }\n        }\n    } else {\n        for (var p in obj[prop]) {\n            if (obj[prop].hasOwnProperty(p)) {\n                mapEnvVarProperties(obj[prop],p);\n            }\n        }\n    }\n}\n\nmodule.exports = {\n\n    diffNodes: diffNodes,\n    mapEnvVarProperties: mapEnvVarProperties,\n\n    parseConfig: function(config) {\n        var flow = {};\n        flow.allNodes = {};\n        flow.subflows = {};\n        flow.configs = {};\n        flow.flows = {};\n        flow.missingTypes = [];\n\n        config.forEach(function(n) {\n            flow.allNodes[n.id] = clone(n);\n            if (n.type === 'tab') {\n                flow.flows[n.id] = n;\n                flow.flows[n.id].subflows = {};\n                flow.flows[n.id].configs = {};\n                flow.flows[n.id].nodes = {};\n            }\n        });\n\n        config.forEach(function(n) {\n            if (n.type === 'subflow') {\n                flow.subflows[n.id] = n;\n                flow.subflows[n.id].configs = {};\n                flow.subflows[n.id].nodes = {};\n                flow.subflows[n.id].instances = [];\n            }\n        });\n        var linkWires = {};\n        var linkOutNodes = [];\n        config.forEach(function(n) {\n            if (n.type !== 'subflow' && n.type !== 'tab') {\n                var subflowDetails = subflowInstanceRE.exec(n.type);\n\n                if ( (subflowDetails && !flow.subflows[subflowDetails[1]]) || (!subflowDetails && !typeRegistry.get(n.type)) ) {\n                    if (flow.missingTypes.indexOf(n.type) === -1) {\n                        flow.missingTypes.push(n.type);\n                    }\n                }\n                var container = null;\n                if (flow.flows[n.z]) {\n                    container = flow.flows[n.z];\n                } else if (flow.subflows[n.z]) {\n                    container = flow.subflows[n.z];\n                }\n                if (n.hasOwnProperty('x') && n.hasOwnProperty('y')) {\n                    if (subflowDetails) {\n                        var subflowType = subflowDetails[1]\n                        n.subflow = subflowType;\n                        flow.subflows[subflowType].instances.push(n)\n                    }\n                    if (container) {\n                        container.nodes[n.id] = n;\n                    }\n                } else {\n                    if (container) {\n                        container.configs[n.id] = n;\n                    } else {\n                        flow.configs[n.id] = n;\n                        flow.configs[n.id]._users = [];\n                    }\n                }\n                if (n.type === 'link in' && n.links) {\n                    // Ensure wires are present in corresponding link out nodes\n                    n.links.forEach(function(id) {\n                        linkWires[id] = linkWires[id]||{};\n                        linkWires[id][n.id] = true;\n                    })\n                } else if (n.type === 'link out' && n.links) {\n                    linkWires[n.id] = linkWires[n.id]||{};\n                    n.links.forEach(function(id) {\n                        linkWires[n.id][id] = true;\n                    })\n                    linkOutNodes.push(n);\n                }\n            }\n        });\n        linkOutNodes.forEach(function(n) {\n            var links = linkWires[n.id];\n            var targets = Object.keys(links);\n            n.wires = [targets];\n        });\n\n\n        var addedTabs = {};\n        config.forEach(function(n) {\n            if (n.type !== 'subflow' && n.type !== 'tab') {\n                for (var prop in n) {\n                    if (n.hasOwnProperty(prop) && prop !== 'id' && prop !== 'wires' && prop !== 'type' && prop !== '_users' && flow.configs.hasOwnProperty(n[prop])) {\n                        // This property references a global config node\n                        flow.configs[n[prop]]._users.push(n.id)\n                    }\n                }\n                if (n.z && !flow.subflows[n.z]) {\n\n                    if (!flow.flows[n.z]) {\n                        flow.flows[n.z] = {type:'tab',id:n.z};\n                        flow.flows[n.z].subflows = {};\n                        flow.flows[n.z].configs = {};\n                        flow.flows[n.z].nodes = {};\n                        addedTabs[n.z] = flow.flows[n.z];\n                    }\n                    if (addedTabs[n.z]) {\n                        if (n.hasOwnProperty('x') && n.hasOwnProperty('y')) {\n                            addedTabs[n.z].nodes[n.id] = n;\n                        } else {\n                            addedTabs[n.z].configs[n.id] = n;\n                        }\n                    }\n                }\n            }\n        });\n        return flow;\n    },\n\n    diffConfigs: function(oldConfig, newConfig) {\n        var id;\n        var node;\n        var nn;\n        var wires;\n        var j,k;\n\n        var changedSubflows = {};\n\n        var added = {};\n        var removed = {};\n        var changed = {};\n        var wiringChanged = {};\n\n        var linkMap = {};\n\n        for (id in oldConfig.allNodes) {\n            if (oldConfig.allNodes.hasOwnProperty(id)) {\n                node = oldConfig.allNodes[id];\n                // build the map of what this node was previously wired to\n                if (node.wires) {\n                    linkMap[node.id] = linkMap[node.id] || [];\n                    for (j=0;j<node.wires.length;j++) {\n                        wires = node.wires[j];\n                        for (k=0;k<wires.length;k++) {\n                            linkMap[node.id].push(wires[k]);\n                            nn = oldConfig.allNodes[wires[k]];\n                            if (nn) {\n                                linkMap[nn.id] = linkMap[nn.id] || [];\n                                linkMap[nn.id].push(node.id);\n                            }\n                        }\n                    }\n                }\n                // This node has been removed\n                if (!newConfig.allNodes.hasOwnProperty(id)) {\n                    removed[id] = node;\n                    // Mark the container as changed\n                    if (newConfig.allNodes[removed[id].z]) {\n                        changed[removed[id].z] = newConfig.allNodes[removed[id].z];\n                        if (changed[removed[id].z].type === \"subflow\") {\n                            changedSubflows[removed[id].z] = changed[removed[id].z];\n                            //delete removed[id];\n                        }\n                    }\n                } else {\n                    // This node has a material configuration change\n                    if (diffNodes(node,newConfig.allNodes[id]) || newConfig.allNodes[id].credentials) {\n                        changed[id] = newConfig.allNodes[id];\n                        if (changed[id].type === \"subflow\") {\n                            changedSubflows[id] = changed[id];\n                        }\n                        // Mark the container as changed\n                        if (newConfig.allNodes[changed[id].z]) {\n                            changed[changed[id].z] = newConfig.allNodes[changed[id].z];\n                            if (changed[changed[id].z].type === \"subflow\") {\n                                changedSubflows[changed[id].z] = changed[changed[id].z];\n                                delete changed[id];\n                            }\n                        }\n                    }\n                    // This node's wiring has changed\n                    if (!redUtil.compareObjects(node.wires,newConfig.allNodes[id].wires)) {\n                        wiringChanged[id] = newConfig.allNodes[id];\n                        // Mark the container as changed\n                        if (newConfig.allNodes[wiringChanged[id].z]) {\n                            changed[wiringChanged[id].z] = newConfig.allNodes[wiringChanged[id].z];\n                            if (changed[wiringChanged[id].z].type === \"subflow\") {\n                                changedSubflows[wiringChanged[id].z] = changed[wiringChanged[id].z];\n                                delete wiringChanged[id];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // Look for added nodes\n        for (id in newConfig.allNodes) {\n            if (newConfig.allNodes.hasOwnProperty(id)) {\n                node = newConfig.allNodes[id];\n                // build the map of what this node is now wired to\n                if (node.wires) {\n                    linkMap[node.id] = linkMap[node.id] || [];\n                    for (j=0;j<node.wires.length;j++) {\n                        wires = node.wires[j];\n                        for (k=0;k<wires.length;k++) {\n                            if (linkMap[node.id].indexOf(wires[k]) === -1) {\n                                linkMap[node.id].push(wires[k]);\n                            }\n                            nn = newConfig.allNodes[wires[k]];\n                            if (nn) {\n                                linkMap[nn.id] = linkMap[nn.id] || [];\n                                if (linkMap[nn.id].indexOf(node.id) === -1) {\n                                    linkMap[nn.id].push(node.id);\n                                }\n                            }\n                        }\n                    }\n                }\n                // This node has been added\n                if (!oldConfig.allNodes.hasOwnProperty(id)) {\n                    added[id] = node;\n                    // Mark the container as changed\n                    if (newConfig.allNodes[added[id].z]) {\n                        changed[added[id].z] = newConfig.allNodes[added[id].z];\n                        if (changed[added[id].z].type === \"subflow\") {\n                            changedSubflows[added[id].z] = changed[added[id].z];\n                            delete added[id];\n                        }\n                    }\n                }\n            }\n        }\n\n        var madeChange;\n        // Loop through the nodes looking for references to changed config nodes\n        // Repeat the loop if anything is marked as changed as it may need to be\n        // propagated to parent nodes.\n        // TODO: looping through all nodes every time is a bit inefficient - could be more targeted\n        do {\n            madeChange = false;\n            for (id in newConfig.allNodes) {\n                if (newConfig.allNodes.hasOwnProperty(id)) {\n                    node = newConfig.allNodes[id];\n                    for (var prop in node) {\n                        if (node.hasOwnProperty(prop) && prop != \"z\" && prop != \"id\" && prop != \"wires\") {\n                            // This node has a property that references a changed/removed node\n                            // Assume it is a config node change and mark this node as\n                            // changed.\n                            if (changed[node[prop]] || removed[node[prop]]) {\n                                if (!changed[node.id]) {\n                                    madeChange = true;\n                                    changed[node.id] = node;\n                                    // This node exists within subflow template\n                                    // Mark the template as having changed\n                                    if (newConfig.allNodes[node.z]) {\n                                        changed[node.z] = newConfig.allNodes[node.z];\n                                        if (changed[node.z].type === \"subflow\") {\n                                            changedSubflows[node.z] = changed[node.z];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } while (madeChange===true)\n\n        // Find any nodes that exist on a subflow template and remove from changed\n        // list as the parent subflow will now be marked as containing a change\n        for (id in newConfig.allNodes) {\n            if (newConfig.allNodes.hasOwnProperty(id)) {\n                node = newConfig.allNodes[id];\n                if (newConfig.allNodes[node.z] && newConfig.allNodes[node.z].type === \"subflow\") {\n                    delete changed[node.id];\n                }\n            }\n        }\n\n        // Recursively mark all instances of changed subflows as changed\n        var changedSubflowStack = Object.keys(changedSubflows);\n        while (changedSubflowStack.length > 0) {\n            var subflowId = changedSubflowStack.pop();\n            for (id in newConfig.allNodes) {\n                if (newConfig.allNodes.hasOwnProperty(id)) {\n                    node = newConfig.allNodes[id];\n                    if (node.type === 'subflow:'+subflowId) {\n                        if (!changed[node.id]) {\n                            changed[node.id] = node;\n                            if (!changed[changed[node.id].z] && newConfig.allNodes[changed[node.id].z]) {\n                                changed[changed[node.id].z] = newConfig.allNodes[changed[node.id].z];\n                                if (newConfig.allNodes[changed[node.id].z].type === \"subflow\") {\n                                    // This subflow instance is inside a subflow. Add the\n                                    // containing subflow to the stack to mark\n                                    changedSubflowStack.push(changed[node.id].z);\n                                    delete changed[node.id];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        var diff = {\n            added:Object.keys(added),\n            changed:Object.keys(changed),\n            removed:Object.keys(removed),\n            rewired:Object.keys(wiringChanged),\n            linked:[]\n        }\n\n        // Traverse the links of all modified nodes to mark the connected nodes\n        var modifiedNodes = diff.added.concat(diff.changed).concat(diff.removed).concat(diff.rewired);\n        var visited = {};\n        while (modifiedNodes.length > 0) {\n            node = modifiedNodes.pop();\n            if (!visited[node]) {\n                visited[node] = true;\n                if (linkMap[node]) {\n                    if (!changed[node] && !added[node] && !removed[node] && !wiringChanged[node]) {\n                        diff.linked.push(node);\n                    }\n                    modifiedNodes = modifiedNodes.concat(linkMap[node]);\n                }\n            }\n        }\n        // for (id in newConfig.allNodes) {\n        //     console.log(\n        //         (added[id]?\"+\":(changed[id]?\"!\":\" \"))+(wiringChanged[id]?\"w\":\" \")+(diff.linked.indexOf(id)!==-1?\"~\":\" \"),\n        //         id,\n        //         newConfig.allNodes[id].type,\n        //         newConfig.allNodes[id].name||newConfig.allNodes[id].label||\"\"\n        //     );\n        // }\n        // for (id in removed) {\n        //     console.log(\n        //         \"- \"+(diff.linked.indexOf(id)!==-1?\"~\":\" \"),\n        //         id,\n        //         oldConfig.allNodes[id].type,\n        //         oldConfig.allNodes[id].name||oldConfig.allNodes[id].label||\"\"\n        //     );\n        // }\n\n        return diff;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/context.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar clone = require(\"clone\");\nvar when = require(\"when\");\nvar util = require(\"../util\");\n\nfunction createContext(id,seed) {\n    var data = seed || {};\n    var obj = seed || {};\n    obj.get = function get(key) {\n        return util.getMessageProperty(data,key);\n    };\n    obj.set = function set(key, value) {\n        util.setMessageProperty(data,key,value);\n    }\n    return obj;\n}\n\nvar contexts = {};\nvar globalContext = null;\n\nfunction getContext(localId,flowId) {\n    var contextId = localId;\n    if (flowId) {\n        contextId = localId+\":\"+flowId;\n    }\n    if (contexts.hasOwnProperty(contextId)) {\n        return contexts[contextId];\n    }\n    var newContext = createContext(contextId);\n    if (flowId) {\n        newContext.flow = getContext(flowId);\n        if (globalContext) {\n            newContext.global = globalContext;\n        }\n    }\n    contexts[contextId] = newContext;\n    return newContext;\n}\nfunction deleteContext(id,flowId) {\n    var contextId = id;\n    if (flowId) {\n        contextId = id+\":\"+flowId;\n    }\n    delete contexts[contextId];\n}\nfunction clean(flowConfig) {\n    var activeIds = {};\n    var contextId;\n    var node;\n    for (var id in contexts) {\n        if (contexts.hasOwnProperty(id)) {\n            var idParts = id.split(\":\");\n            if (!flowConfig.allNodes.hasOwnProperty(idParts[0])) {\n                delete contexts[id];\n            }\n        }\n    }\n}\nmodule.exports = {\n    init: function(settings) {\n        globalContext = createContext(\"global\",settings.functionGlobalContext || {});\n    },\n    get: getContext,\n    delete: deleteContext,\n    clean:clean\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/registry/deprecated.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n \nvar nodes = {\n    \"irc in\":     {module:\"node-red-node-irc\"},\n    \"irc out\":    {module:\"node-red-node-irc\"},\n    \"irc-server\": {module:\"node-red-node-irc\"},\n    \n    \"arduino in\":    {module:\"node-red-node-arduino\"},\n    \"arduino out\":   {module:\"node-red-node-arduino\"},\n    \"arduino-board\": {module:\"node-red-node-arduino\"},\n    \n    \"redis out\": {module:\"node-red-node-redis\"},\n    \n    \"mongodb\": {module:\"node-red-node-mongodb\"},\n    \"mongodb out\": {module:\"node-red-node-mongodb\"},\n    \n    \"serial in\": {module:\"node-red-node-serialport\"},\n    \"serial out\": {module:\"node-red-node-serialport\"},\n    \"serial-port\": {module:\"node-red-node-serialport\"},\n    \n    \"twitter-credentials\": {module:\"node-red-node-twitter\"},\n    \"twitter in\": {module:\"node-red-node-twitter\"},\n    \"twitter out\": {module:\"node-red-node-twitter\"},\n    \n    \"e-mail\": {module:\"node-red-node-email\"},\n    \"e-mail in\": {module:\"node-red-node-email\"},\n    \n    \"feedparse\": {module:\"node-red-node-feedparser\"}\n}\n\nmodule.exports = {\n    get: function(id) {\n        return nodes[id];\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/nodes/Node.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar when = require(\"when\");\n\nvar redUtil = require(\"../util\");\nvar Log = require(\"../log\");\nvar context = require(\"./context\");\nvar flows = require(\"./flows\");\n\nfunction Node(n) {\n    this.id = n.id;\n    this.type = n.type;\n    this.z = n.z;\n    this._closeCallbacks = [];\n\n    if (n.name) {\n        this.name = n.name;\n    }\n    if (n._alias) {\n        this._alias = n._alias;\n    }\n    this.updateWires(n.wires);\n}\n\nutil.inherits(Node, EventEmitter);\n\nNode.prototype.updateWires = function(wires) {\n    //console.log(\"UPDATE\",this.id);\n    this.wires = wires || [];\n    delete this._wire;\n\n    var wc = 0;\n    this.wires.forEach(function(w) {\n        wc+=w.length;\n    });\n    this._wireCount = wc;\n    if (wc === 0) {\n        // With nothing wired to the node, no-op send\n        this.send = function(msg) {}\n    } else {\n        this.send = Node.prototype.send;\n        if (this.wires.length === 1 && this.wires[0].length === 1) {\n            // Single wire, so we can shortcut the send when\n            // a single message is sent\n            this._wire = this.wires[0][0];\n        }\n    }\n\n}\nNode.prototype.context = function() {\n    if (!this._context) {\n         this._context = context.get(this._alias||this.id,this.z);\n    }\n    return this._context;\n}\n\nNode.prototype._on = Node.prototype.on;\n\nNode.prototype.on = function(event, callback) {\n    var node = this;\n    if (event == \"close\") {\n        this._closeCallbacks.push(callback);\n    } else {\n        this._on(event, callback);\n    }\n};\n\nNode.prototype.close = function() {\n    var promises = [];\n    var node = this;\n    for (var i=0;i<this._closeCallbacks.length;i++) {\n        var callback = this._closeCallbacks[i];\n        if (callback.length == 1) {\n            promises.push(\n                when.promise(function(resolve) {\n                    callback.call(node, function() {\n                        resolve();\n                    });\n                })\n            );\n        } else {\n            callback.call(node);\n        }\n    }\n    if (promises.length > 0) {\n        return when.settle(promises).then(function() {\n            if (this._context) {\n                 context.delete(this._alias||this.id,this.z);\n            }\n        });\n    } else {\n        if (this._context) {\n             context.delete(this._alias||this.id,this.z);\n        }\n        return;\n    }\n};\n\nNode.prototype.send = function(msg) {\n    var msgSent = false;\n    var node;\n\n    if (msg === null || typeof msg === \"undefined\") {\n        return;\n    } else if (!util.isArray(msg)) {\n        if (this._wire) {\n            // A single message and a single wire on output 0\n            // TODO: pre-load flows.get calls - cannot do in constructor\n            //       as not all nodes are defined at that point\n            if (!msg._msgid) {\n                msg._msgid = redUtil.generateId();\n            }\n            this.metric(\"send\",msg);\n            node = flows.get(this._wire);\n            /* istanbul ignore else */\n            if (node) {\n                node.receive(msg);\n            }\n            return;\n        } else {\n            msg = [msg];\n        }\n    }\n\n    var numOutputs = this.wires.length;\n\n    // Build a list of send events so that all cloning is done before\n    // any calls to node.receive\n    var sendEvents = [];\n\n    var sentMessageId = null;\n\n    // for each output of node eg. [msgs to output 0, msgs to output 1, ...]\n    for (var i = 0; i < numOutputs; i++) {\n        var wires = this.wires[i]; // wires leaving output i\n        /* istanbul ignore else */\n        if (i < msg.length) {\n            var msgs = msg[i]; // msgs going to output i\n            if (msgs !== null && typeof msgs !== \"undefined\") {\n                if (!util.isArray(msgs)) {\n                    msgs = [msgs];\n                }\n                var k = 0;\n                // for each recipent node of that output\n                for (var j = 0; j < wires.length; j++) {\n                    node = flows.get(wires[j]); // node at end of wire j\n                    if (node) {\n                        // for each msg to send eg. [[m1, m2, ...], ...]\n                        for (k = 0; k < msgs.length; k++) {\n                            var m = msgs[k];\n                            if (m !== null && m !== undefined) {\n                                /* istanbul ignore else */\n                                if (!sentMessageId) {\n                                    sentMessageId = m._msgid;\n                                }\n                                if (msgSent) {\n                                    var clonedmsg = redUtil.cloneMessage(m);\n                                    sendEvents.push({n:node,m:clonedmsg});\n                                } else {\n                                    sendEvents.push({n:node,m:m});\n                                    msgSent = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /* istanbul ignore else */\n    if (!sentMessageId) {\n        sentMessageId = redUtil.generateId();\n    }\n    this.metric(\"send\",{_msgid:sentMessageId});\n\n    for (i=0;i<sendEvents.length;i++) {\n        var ev = sendEvents[i];\n        /* istanbul ignore else */\n        if (!ev.m._msgid) {\n            ev.m._msgid = sentMessageId;\n        }\n        ev.n.receive(ev.m);\n    }\n};\n\nNode.prototype.receive = function(msg) {\n    if (!msg) {\n        msg = {};\n    }\n    if (!msg._msgid) {\n        msg._msgid = redUtil.generateId();\n    }\n    this.metric(\"receive\",msg);\n    try {\n        this.emit(\"input\", msg);\n    } catch(err) {\n        this.error(err,msg);\n    }\n};\n\nfunction log_helper(self, level, msg) {\n    var o = {\n        level: level,\n        id: self.id,\n        type: self.type,\n        msg: msg\n    };\n    if (self.name) {\n        o.name = self.name;\n    }\n    Log.log(o);\n}\n\nNode.prototype.log = function(msg) {\n    log_helper(this, Log.INFO, msg);\n};\n\nNode.prototype.warn = function(msg) {\n    log_helper(this, Log.WARN, msg);\n};\n\nNode.prototype.error = function(logMessage,msg) {\n    if (typeof logMessage != 'boolean') {\n        logMessage = logMessage || \"\";\n    }\n    log_helper(this, Log.ERROR, logMessage);\n    /* istanbul ignore else */\n    if (msg) {\n        flows.handleError(this,logMessage,msg);\n    }\n};\n\n/**\n * If called with no args, returns whether metric collection is enabled\n */\nNode.prototype.metric = function(eventname, msg, metricValue) {\n    if (typeof eventname === \"undefined\") {\n        return Log.metric();\n    }\n    var metrics = {};\n    metrics.level = Log.METRIC;\n    metrics.nodeid = this.id;\n    metrics.event = \"node.\"+this.type+\".\"+eventname;\n    metrics.msgid = msg._msgid;\n    metrics.value = metricValue;\n    Log.log(metrics);\n}\n\n/**\n * status: { fill:\"red|green\", shape:\"dot|ring\", text:\"blah\" }\n */\nNode.prototype.status = function(status) {\n    flows.handleStatus(this,status);\n};\nmodule.exports = Node;\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/storage/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require('when');\nvar Path = require('path');\nvar crypto = require('crypto');\n\nvar log = require(\"../log\");\n\nvar runtime;\nvar storageModule;\nvar settingsAvailable;\nvar sessionsAvailable;\n\nfunction moduleSelector(aSettings) {\n    var toReturn;\n    if (aSettings.storageModule) {\n        if (typeof aSettings.storageModule === \"string\") {\n            // TODO: allow storage modules to be specified by absolute path\n            toReturn = require(\"./\"+aSettings.storageModule);\n        } else {\n            toReturn = aSettings.storageModule;\n        }\n    } else {\n        toReturn = require(\"./localfilesystem\");\n    }\n    return toReturn;\n}\n\nfunction is_malicious(path) {\n    return path.indexOf('../') != -1 || path.indexOf('..\\\\') != -1;\n}\n\nvar storageModuleInterface = {\n        init: function(_runtime) {\n            runtime = _runtime;\n            try {\n                storageModule = moduleSelector(runtime.settings);\n                settingsAvailable = storageModule.hasOwnProperty(\"getSettings\") && storageModule.hasOwnProperty(\"saveSettings\");\n                sessionsAvailable = storageModule.hasOwnProperty(\"getSessions\") && storageModule.hasOwnProperty(\"saveSessions\");\n            } catch (e) {\n                return when.reject(e);\n            }\n            return storageModule.init(runtime.settings);\n        },\n        getFlows: function() {\n            return storageModule.getFlows().then(function(flows) {\n                return storageModule.getCredentials().then(function(creds) {\n                    var result = {\n                        flows: flows,\n                        credentials: creds\n                    };\n                    result.rev = crypto.createHash('md5').update(JSON.stringify(result)).digest(\"hex\");\n                    return result;\n                })\n            });\n        },\n        saveFlows: function(config) {\n            var flows = config.flows;\n            var credentials = config.credentials;\n            var credentialSavePromise;\n            if (config.credentialsDirty) {\n                credentialSavePromise = storageModule.saveCredentials(credentials);\n            } else {\n                credentialSavePromise = when.resolve();\n            }\n            delete config.credentialsDirty;\n\n            return credentialSavePromise.then(function() {\n                return storageModule.saveFlows(flows).then(function() {\n                    return crypto.createHash('md5').update(JSON.stringify(config)).digest(\"hex\");\n                })\n            });\n        },\n        // getCredentials: function() {\n        //     return storageModule.getCredentials();\n        // },\n        // saveCredentials: function(credentials) {\n        //     return storageModule.saveCredentials(credentials);\n        // },\n        getSettings: function() {\n            if (settingsAvailable) {\n                return storageModule.getSettings();\n            } else {\n                return when.resolve(null);\n            }\n        },\n        saveSettings: function(settings) {\n            if (settingsAvailable) {\n                return storageModule.saveSettings(settings);\n            } else {\n                return when.resolve();\n            }\n        },\n        getSessions: function() {\n            if (sessionsAvailable) {\n                return storageModule.getSessions();\n            } else {\n                return when.resolve(null);\n            }\n        },\n        saveSessions: function(sessions) {\n            if (sessionsAvailable) {\n                return storageModule.saveSessions(sessions);\n            } else {\n                return when.resolve();\n            }\n        },\n\n        /* Library Functions */\n\n        getLibraryEntry: function(type, path) {\n            if (is_malicious(path)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            return storageModule.getLibraryEntry(type, path);\n        },\n        saveLibraryEntry: function(type, path, meta, body) {\n            if (is_malicious(path)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            return storageModule.saveLibraryEntry(type, path, meta, body);\n        },\n\n/* Deprecated functions */\n        getAllFlows: function() {\n            if (storageModule.hasOwnProperty(\"getAllFlows\")) {\n                return storageModule.getAllFlows();\n            } else {\n                return listFlows(\"/\");\n            }\n        },\n        getFlow: function(fn) {\n            if (is_malicious(fn)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            if (storageModule.hasOwnProperty(\"getFlow\")) {\n                return storageModule.getFlow(fn);\n            } else {\n                return storageModule.getLibraryEntry(\"flows\",fn);\n            }\n\n        },\n        saveFlow: function(fn, data) {\n            if (is_malicious(fn)) {\n                var err = new Error();\n                err.code = \"forbidden\";\n                return when.reject(err);\n            }\n            if (storageModule.hasOwnProperty(\"saveFlow\")) {\n                return storageModule.saveFlow(fn, data);\n            } else {\n                return storageModule.saveLibraryEntry(\"flows\",fn,{},data);\n            }\n        }\n/* End deprecated functions */\n\n}\n\n\nfunction listFlows(path) {\n    return storageModule.getLibraryEntry(\"flows\",path).then(function(res) {\n        return when.promise(function(resolve) {\n            var promises = [];\n            res.forEach(function(r) {\n                if (typeof r === \"string\") {\n                    promises.push(listFlows(Path.join(path,r)));\n                } else {\n                    promises.push(when.resolve(r));\n                }\n            });\n            var i=0;\n            when.settle(promises).then(function(res2) {\n                var result = {};\n                res2.forEach(function(r) {\n                    // TODO: name||fn\n                    if (r.value.fn) {\n                        var name = r.value.name;\n                        if (!name) {\n                            name = r.value.fn.split(\".\")[0];\n                        }\n                        result.f = result.f || [];\n                        result.f.push(name);\n                    } else {\n                        result.d = result.d || {};\n                        result.d[res[i]] = r.value;\n                        //console.log(\">\",r.value);\n                    }\n                    i++;\n                });\n                resolve(result);\n            });\n        });\n    });\n}\n\n\n\nmodule.exports = storageModuleInterface;\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/runtime/settings.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar clone = require(\"clone\");\nvar assert = require(\"assert\");\nvar log = require(\"./log\");\n\nvar userSettings = null;\nvar globalSettings = null;\nvar storage = null;\n\nvar persistentSettings = {\n    init: function(settings) {\n        userSettings = settings;\n        for (var i in settings) {\n            /* istanbul ignore else */\n            if (settings.hasOwnProperty(i) && i !== 'load' && i !== 'get' && i !== 'set' && i !== 'available' && i !== 'reset') {\n                // Don't allow any of the core functions get replaced via settings\n                (function() {\n                    var j = i;\n                    persistentSettings.__defineGetter__(j,function() { return userSettings[j]; });\n                    persistentSettings.__defineSetter__(j,function() { throw new Error(\"Property '\"+j+\"' is read-only\"); });\n                })();\n            }\n        }\n        globalSettings = null;\n    },\n    load: function(_storage) {\n        storage = _storage;\n        return storage.getSettings().then(function(_settings) {\n            globalSettings = _settings;\n        });\n    },\n    get: function(prop) {\n        if (userSettings.hasOwnProperty(prop)) {\n            return clone(userSettings[prop]);\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        return clone(globalSettings[prop]);\n    },\n\n    set: function(prop,value) {\n        if (userSettings.hasOwnProperty(prop)) {\n            throw new Error(log._(\"settings.property-read-only\", {prop:prop}));\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        var current = globalSettings[prop];\n        globalSettings[prop] = value;\n        try {\n            assert.deepEqual(current,value);\n            return when.resolve();\n        } catch(err) {\n            return storage.saveSettings(globalSettings);\n        }\n    },\n    delete: function(prop) {\n        if (userSettings.hasOwnProperty(prop)) {\n            throw new Error(log._(\"settings.property-read-only\", {prop:prop}));\n        }\n        if (globalSettings === null) {\n            throw new Error(log._(\"settings.not-available\"));\n        }\n        if (globalSettings.hasOwnProperty(prop)) {\n            delete globalSettings[prop];\n            return storage.saveSettings(globalSettings);\n        }\n        return when.resolve();\n    },\n\n    available: function() {\n        return (globalSettings !== null);\n    },\n\n    reset: function() {\n        for (var i in userSettings) {\n            /* istanbul ignore else */\n            if (userSettings.hasOwnProperty(i)) {\n                delete persistentSettings[i];\n            }\n        }\n        userSettings = null;\n        globalSettings = null;\n        storage = null;\n    }\n}\n\nmodule.exports = persistentSettings;\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar express = require(\"express\");\nvar bodyParser = require(\"body-parser\");\nvar util = require('util');\nvar path = require('path');\nvar passport = require('passport');\nvar when = require('when');\nvar cors = require('cors');\n\nvar ui = require(\"./ui\");\nvar nodes = require(\"./nodes\");\nvar flows = require(\"./flows\");\nvar flow = require(\"./flow\");\nvar library = require(\"./library\");\nvar info = require(\"./info\");\nvar theme = require(\"./theme\");\nvar locales = require(\"./locales\");\nvar credentials = require(\"./credentials\");\nvar comms = require(\"./comms\");\n\nvar auth = require(\"./auth\");\nvar needsPermission = auth.needsPermission;\n\nvar i18n;\nvar log;\nvar adminApp;\nvar server;\nvar runtime;\n\nvar errorHandler = function(err,req,res,next) {\n    if (err.message === \"request entity too large\") {\n        log.error(err);\n    } else {\n        console.log(err.stack);\n    }\n    log.audit({event: \"api.error\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n    res.status(400).json({error:\"unexpected_error\", message:err.toString()});\n};\n\nvar ensureRuntimeStarted = function(req,res,next) {\n    if (!runtime.isStarted()) {\n        log.error(\"Node-RED runtime not started\");\n        res.status(503).send(\"Not started\");\n    } else {\n        next();\n    }\n}\n\nfunction init(_server,_runtime) {\n    server = _server;\n    runtime = _runtime;\n    var settings = runtime.settings;\n    i18n = runtime.i18n;\n    log = runtime.log;\n    if (settings.httpAdminRoot !== false) {\n        comms.init(server,runtime);\n        adminApp = express();\n        auth.init(runtime);\n        credentials.init(runtime);\n        flows.init(runtime);\n        flow.init(runtime);\n        info.init(runtime);\n        library.init(adminApp,runtime);\n        locales.init(runtime);\n        nodes.init(runtime);\n\n        // Editor\n        if (!settings.disableEditor) {\n            ui.init(runtime);\n            var editorApp = express();\n            if (settings.requireHttps === true) {\n                editorApp.enable('trust proxy');\n                editorApp.use(function (req, res, next) {\n                    if (req.secure) {\n                        next();\n                    } else {\n                        res.redirect('https://' + req.headers.host + req.originalUrl);\n                    }\n                });\n            }\n            editorApp.get(\"/\",ensureRuntimeStarted,ui.ensureSlash,ui.editor);\n            editorApp.get(\"/icons/:icon\",ui.icon);\n            theme.init(runtime);\n            if (settings.editorTheme) {\n                editorApp.use(\"/theme\",theme.app());\n            }\n            editorApp.use(\"/\",ui.editorResources);\n            adminApp.use(editorApp);\n        }\n        var maxApiRequestSize = settings.apiMaxLength || '5mb';\n        adminApp.use(bodyParser.json({limit:maxApiRequestSize}));\n        adminApp.use(bodyParser.urlencoded({limit:maxApiRequestSize,extended:true}));\n\n        adminApp.get(\"/auth/login\",auth.login,errorHandler);\n\n        if (settings.adminAuth) {\n            //TODO: all passport references ought to be in ./auth\n            adminApp.use(passport.initialize());\n            adminApp.post(\"/auth/token\",\n                auth.ensureClientSecret,\n                auth.authenticateClient,\n                auth.getToken,\n                auth.errorHandler\n            );\n            adminApp.post(\"/auth/revoke\",needsPermission(\"\"),auth.revoke,errorHandler);\n        }\n        if (settings.httpAdminCors) {\n            var corsHandler = cors(settings.httpAdminCors);\n            adminApp.use(corsHandler);\n        }\n\n        // Flows\n        adminApp.get(\"/flows\",needsPermission(\"flows.read\"),flows.get,errorHandler);\n        adminApp.post(\"/flows\",needsPermission(\"flows.write\"),flows.post,errorHandler);\n\n        adminApp.get(\"/flow/:id\",needsPermission(\"flows.read\"),flow.get,errorHandler);\n        adminApp.post(\"/flow\",needsPermission(\"flows.write\"),flow.post,errorHandler);\n        adminApp.delete(\"/flow/:id\",needsPermission(\"flows.write\"),flow.delete,errorHandler);\n        adminApp.put(\"/flow/:id\",needsPermission(\"flows.write\"),flow.put,errorHandler);\n\n        // Nodes\n        adminApp.get(\"/nodes\",needsPermission(\"nodes.read\"),nodes.getAll,errorHandler);\n        adminApp.post(\"/nodes\",needsPermission(\"nodes.write\"),nodes.post,errorHandler);\n\n        adminApp.get(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.read\"),nodes.getModule,errorHandler);\n        adminApp.put(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.putModule,errorHandler);\n        adminApp.delete(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.delete,errorHandler);\n\n        adminApp.get(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)\\/([^\\/]+)$/,needsPermission(\"nodes.read\"),nodes.getSet,errorHandler);\n        adminApp.put(/\\/nodes\\/((@[^\\/]+\\/)?[^\\/]+)\\/([^\\/]+)$/,needsPermission(\"nodes.write\"),nodes.putSet,errorHandler);\n\n        adminApp.get('/credentials/:type/:id', needsPermission(\"credentials.read\"),credentials.get,errorHandler);\n\n        adminApp.get(/locales\\/(.+)\\/?$/,locales.get,errorHandler);\n\n        // Library\n        adminApp.post(new RegExp(\"/library/flows\\/(.*)\"),needsPermission(\"library.write\"),library.post,errorHandler);\n        adminApp.get(\"/library/flows\",needsPermission(\"library.read\"),library.getAll,errorHandler);\n        adminApp.get(new RegExp(\"/library/flows\\/(.*)\"),needsPermission(\"library.read\"),library.get,errorHandler);\n\n        // Settings\n        adminApp.get(\"/settings\",needsPermission(\"settings.read\"),info.settings,errorHandler);\n\n        // Error Handler\n        //adminApp.use(errorHandler);\n    }\n}\nfunction start() {\n    var catalogPath = path.resolve(path.join(__dirname,\"locales\"));\n    return i18n.registerMessageCatalogs([\n        {namespace: \"editor\",   dir: catalogPath, file:\"editor.json\"},\n        {namespace: \"jsonata\",  dir: catalogPath, file:\"jsonata.json\"},\n        {namespace: \"infotips\", dir: catalogPath, file:\"infotips.json\"}\n    ]).then(function(){\n        comms.start();\n    });\n}\nfunction stop() {\n    comms.stop();\n    return when.resolve();\n}\nmodule.exports = {\n    init: init,\n    start: start,\n    stop: stop,\n    library: {\n        register: library.register\n    },\n    auth: {\n        needsPermission: auth.needsPermission\n    },\n    comms: {\n        publish: comms.publish\n    },\n    get adminApp() { return adminApp; },\n    get server() { return server; }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/ui.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar express = require('express');\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar theme = require(\"./theme\");\n\nvar Mustache = require(\"mustache\");\n\nvar icon_paths = [path.resolve(__dirname + '/../../public/icons')];\nvar iconCache = {};\n//TODO: create a default icon\nvar defaultIcon = path.resolve(__dirname + '/../../public/icons/arrow-in.png');\nvar templateDir = path.resolve(__dirname+\"/../../editor/templates\");\nvar editorTemplate;\n\nfunction nodeIconDir(dir) {\n    icon_paths.push(path.resolve(dir));\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        editorTemplate = fs.readFileSync(path.join(templateDir,\"index.mst\"),\"utf8\");\n        Mustache.parse(editorTemplate);\n        // TODO: this allows init to be called multiple times without\n        //       registering multiple instances of the listener.\n        //       It isn't.... ideal.\n        runtime.events.removeListener(\"node-icon-dir\",nodeIconDir);\n        runtime.events.on(\"node-icon-dir\",nodeIconDir);\n    },\n\n    ensureSlash: function(req,res,next) {\n        var parts = req.originalUrl.split(\"?\");\n        if (parts[0].slice(-1) != \"/\") {\n            parts[0] += \"/\";\n            var redirect = parts.join(\"?\");\n            res.redirect(301,redirect);\n        } else {\n            next();\n        }\n    },\n    icon: function(req,res) {\n        if (iconCache[req.params.icon]) {\n            res.sendFile(iconCache[req.params.icon]); // if not found, express prints this to the console and serves 404\n        } else {\n            for (var p=0;p<icon_paths.length;p++) {\n                var iconPath = path.join(icon_paths[p],req.params.icon);\n                try {\n                    fs.statSync(iconPath);\n                    res.sendFile(iconPath);\n                    iconCache[req.params.icon] = iconPath;\n                    return;\n                } catch(err) {\n                    // iconPath doesn't exist\n                }\n            }\n            res.sendFile(defaultIcon);\n        }\n    },\n    editor: function(req,res) {\n        res.send(Mustache.render(editorTemplate,theme.context()));\n    },\n    editorResources: express.static(__dirname + '/../../public')\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/theme.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar express = require(\"express\");\nvar util = require(\"util\");\nvar path = require(\"path\");\nvar fs = require(\"fs\");\nvar clone = require(\"clone\");\n\nvar defaultContext = {\n    page: {\n        title: \"Node-RED\",\n        favicon: \"favicon.ico\",\n        tabicon: \"red/images/node-red-icon-black.svg\"\n    },\n    header: {\n        title: \"Node-RED\",\n        image: \"red/images/node-red.png\"\n    },\n    asset: {\n        red: (process.env.NODE_ENV == \"development\")? \"red/red.js\":\"red/red.min.js\",\n        main: (process.env.NODE_ENV == \"development\")? \"red/main.js\":\"red/main.min.js\",\n\n    }\n};\n\nvar theme = null;\nvar themeContext = clone(defaultContext);\nvar themeSettings = null;\nvar runtime = null;\n\nfunction serveFile(app,baseUrl,file) {\n    try {\n        var stats = fs.statSync(file);\n        var url = baseUrl+path.basename(file);\n        //console.log(url,\"->\",file);\n        app.get(url,function(req, res) {\n            res.sendFile(file);\n        });\n        return \"theme\"+url;\n    } catch(err) {\n        //TODO: log filenotfound\n        return null;\n    }\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        var settings = runtime.settings;\n        themeContext = clone(defaultContext);\n        if (runtime.version) {\n            themeContext.version = runtime.version();\n        }\n        themeSettings = null;\n        theme = settings.editorTheme;\n    },\n\n    app: function() {\n        var i;\n        var url;\n        themeSettings = {};\n\n        var themeApp = express();\n\n        if (theme.page) {\n            if (theme.page.css) {\n                var styles = theme.page.css;\n                if (!util.isArray(styles)) {\n                    styles = [styles];\n                }\n                themeContext.page.css = [];\n\n                for (i=0;i<styles.length;i++) {\n                    url = serveFile(themeApp,\"/css/\",styles[i]);\n                    if (url) {\n                        themeContext.page.css.push(url);\n                    }\n                }\n            }\n\n            if (theme.page.favicon) {\n                url = serveFile(themeApp,\"/favicon/\",theme.page.favicon)\n                if (url) {\n                    themeContext.page.favicon = url;\n                }\n            }\n\n            if (theme.page.tabicon) {\n                url = serveFile(themeApp,\"/tabicon/\",theme.page.tabicon)\n                if (url) {\n                    themeContext.page.tabicon = url;\n                }\n            }\n\n            themeContext.page.title = theme.page.title || themeContext.page.title;\n        }\n\n        if (theme.header) {\n\n            themeContext.header.title = theme.header.title || themeContext.header.title;\n\n            if (theme.header.hasOwnProperty(\"url\")) {\n                themeContext.header.url = theme.header.url;\n            }\n\n            if (theme.header.hasOwnProperty(\"image\")) {\n                if (theme.header.image) {\n                    url = serveFile(themeApp,\"/header/\",theme.header.image);\n                    if (url) {\n                        themeContext.header.image = url;\n                    }\n                } else {\n                    themeContext.header.image = null;\n                }\n            }\n        }\n\n        if (theme.deployButton) {\n            if (theme.deployButton.type == \"simple\") {\n                themeSettings.deployButton = {\n                    type: \"simple\"\n                }\n                if (theme.deployButton.label) {\n                    themeSettings.deployButton.label = theme.deployButton.label;\n                }\n                if (theme.deployButton.icon) {\n                    url = serveFile(themeApp,\"/deploy/\",theme.deployButton.icon);\n                    if (url) {\n                        themeSettings.deployButton.icon = url;\n                    }\n                }\n            }\n        }\n\n        if (theme.hasOwnProperty(\"userMenu\")) {\n            themeSettings.userMenu = theme.userMenu;\n        }\n\n        if (theme.login) {\n            if (theme.login.image) {\n                url = serveFile(themeApp,\"/login/\",theme.login.image);\n                if (url) {\n                    themeContext.login = {\n                        image: url\n                    }\n                }\n            }\n        }\n\n        if (theme.hasOwnProperty(\"menu\")) {\n            themeSettings.menu = theme.menu;\n        }\n\n        if (theme.hasOwnProperty(\"palette\")) {\n            themeSettings.palette = theme.palette;\n        }\n        return themeApp;\n    },\n    context: function() {\n        return themeContext;\n    },\n    settings: function() {\n        return themeSettings;\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/nodes.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\nvar comms = require(\"./comms\");\nvar locales = require(\"./locales\");\nvar redNodes;\nvar log;\nvar i18n;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        redNodes = runtime.nodes;\n        log = runtime.log;\n        i18n = runtime.i18n;\n        settings = runtime.settings;\n    },\n    getAll: function(req,res) {\n        if (req.get(\"accept\") == \"application/json\") {\n            log.audit({event: \"nodes.list.get\"},req);\n            res.json(redNodes.getNodeList());\n        } else {\n            var lang = locales.determineLangFromHeaders(req.acceptsLanguages());\n            log.audit({event: \"nodes.configs.get\"},req);\n            res.send(redNodes.getNodeConfigs(lang));\n        }\n    },\n\n    post: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.install\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var node = req.body;\n        var promise;\n        if (node.module) {\n            var module = redNodes.getModuleInfo(node.module);\n            if (module) {\n                log.audit({event: \"nodes.install\",module:node.module,error:\"module_already_loaded\"},req);\n                res.status(400).json({error:\"module_already_loaded\", message:\"Module already loaded\"});\n                return;\n            }\n            promise = redNodes.installModule(node.module);\n        } else {\n            log.audit({event: \"nodes.install\",module:node.module,error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        promise.then(function(info) {\n            comms.publish(\"node/added\",info.nodes,false);\n            if (node.module) {\n                log.audit({event: \"nodes.install\",module:node.module},req);\n                res.json(info);\n            }\n        }).otherwise(function(err) {\n            if (err.code === 404) {\n                log.audit({event: \"nodes.install\",module:node.module,error:\"not_found\"},req);\n                res.status(404).end();\n            } else if (err.code) {\n                log.audit({event: \"nodes.install\",module:node.module,error:err.code},req);\n                res.status(400).json({error:err.code, message:err.message});\n            } else {\n                log.audit({event: \"nodes.install\",module:node.module,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        });\n    },\n\n    delete: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.remove\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var mod = req.params[0];\n        try {\n            var promise = null;\n            var module = redNodes.getModuleInfo(mod);\n            if (!module) {\n                log.audit({event: \"nodes.remove\",module:mod,error:\"not_found\"},req);\n                res.status(404).end();\n                return;\n            } else {\n                promise = redNodes.uninstallModule(mod);\n            }\n\n            promise.then(function(list) {\n                comms.publish(\"node/removed\",list,false);\n                log.audit({event: \"nodes.remove\",module:mod},req);\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.audit({event: \"nodes.remove\",module:mod,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            });\n        } catch(err) {\n            log.audit({event: \"nodes.remove\",module:mod,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    },\n\n    getSet: function(req,res) {\n        var id = req.params[0] + \"/\" + req.params[2];\n        var result = null;\n        if (req.get(\"accept\") === \"application/json\") {\n            result = redNodes.getNodeInfo(id);\n            if (result) {\n                log.audit({event: \"nodes.info.get\",id:id},req);\n                delete result.loaded;\n                res.send(result);\n            } else {\n                log.audit({event: \"nodes.info.get\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            }\n        } else {\n            var lang = locales.determineLangFromHeaders(req.acceptsLanguages());\n            result = redNodes.getNodeConfig(id,lang);\n            if (result) {\n                log.audit({event: \"nodes.config.get\",id:id},req);\n                res.send(result);\n            } else {\n                log.audit({event: \"nodes.config.get\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            }\n        }\n    },\n\n    getModule: function(req,res) {\n        var module = req.params[0];\n        var result = redNodes.getModuleInfo(module);\n        if (result) {\n            log.audit({event: \"nodes.module.get\",module:module},req);\n            res.json(result);\n        } else {\n            log.audit({event: \"nodes.module.get\",module:module,error:\"not_found\"},req);\n            res.status(404).end();\n        }\n    },\n\n    putSet: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.info.set\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var body = req.body;\n        if (!body.hasOwnProperty(\"enabled\")) {\n            log.audit({event: \"nodes.info.set\",error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        var id = req.params[0] + \"/\" + req.params[2];\n        try {\n            var node = redNodes.getNodeInfo(id);\n            var info;\n            if (!node) {\n                log.audit({event: \"nodes.info.set\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                delete node.loaded;\n                putNode(node, body.enabled).then(function(result) {\n                    log.audit({event: \"nodes.info.set\",id:id,enabled:body.enabled},req);\n                    res.json(result);\n                });\n            }\n        } catch(err) {\n            log.audit({event: \"nodes.info.set\",id:id,enabled:body.enabled,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    },\n\n    putModule: function(req,res) {\n        if (!settings.available()) {\n            log.audit({event: \"nodes.module.set\",error:\"settings_unavailable\"},req);\n            res.status(400).json({error:\"settings_unavailable\", message:\"Settings unavailable\"});\n            return;\n        }\n        var body = req.body;\n        if (!body.hasOwnProperty(\"enabled\")) {\n            log.audit({event: \"nodes.module.set\",error:\"invalid_request\"},req);\n            res.status(400).json({error:\"invalid_request\", message:\"Invalid request\"});\n            return;\n        }\n        var mod = req.params[0];\n        try {\n            var module = redNodes.getModuleInfo(mod);\n            if (!module) {\n                log.audit({event: \"nodes.module.set\",module:mod,error:\"not_found\"},req);\n                return res.status(404).end();\n            }\n\n            var nodes = module.nodes;\n            var promises = [];\n            for (var i = 0; i < nodes.length; ++i) {\n                promises.push(putNode(nodes[i],body.enabled));\n            }\n            when.settle(promises).then(function() {\n                res.json(redNodes.getModuleInfo(mod));\n            });\n        } catch(err) {\n            log.audit({event: \"nodes.module.set\",module:mod,enabled:body.enabled,error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        }\n    }\n};\n\nfunction putNode(node, enabled) {\n    var info;\n    var promise;\n    if (!node.err && node.enabled === enabled) {\n        promise = when.resolve(node);\n    } else {\n        if (enabled) {\n            promise = redNodes.enableNode(node.id);\n        } else {\n            promise = redNodes.disableNode(node.id);\n        }\n\n        return promise.then(function(info) {\n            if (info.enabled === enabled && !info.err) {\n                comms.publish(\"node/\"+(enabled?\"enabled\":\"disabled\"),info,false);\n                log.info(\" \"+log._(\"api.nodes.\"+(enabled?\"enabled\":\"disabled\")));\n                for (var i=0;i<info.types.length;i++) {\n                    log.info(\" - \"+info.types[i]);\n                }\n            } else if (enabled && info.err) {\n            log.warn(log._(\"api.nodes.error-enable\"));\n                log.warn(\" - \"+info.name+\" : \"+info.err);\n            }\n            return info;\n        });\n    }\n\n    return promise;\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/comms.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar ws = require(\"ws\");\nvar log;\n\nvar server;\nvar settings;\n\nvar wsServer;\nvar pendingConnections = [];\nvar activeConnections = [];\n\nvar retained = {};\n\nvar heartbeatTimer;\nvar lastSentTime;\n\nfunction handleStatus(event) {\n    publish(\"status/\"+event.id,event.status,true);\n}\nfunction handleRuntimeEvent(event) {\n    publish(\"notification/\"+event.id,event,true);\n}\nfunction init(_server,runtime) {\n    server = _server;\n    settings = runtime.settings;\n    log = runtime.log;\n\n    runtime.events.removeListener(\"node-status\",handleStatus);\n    runtime.events.on(\"node-status\",handleStatus);\n\n    runtime.events.removeListener(\"runtime-event\",handleRuntimeEvent);\n    runtime.events.on(\"runtime-event\",handleRuntimeEvent);\n}\n\nfunction start() {\n    var Tokens = require(\"./auth/tokens\");\n    var Users = require(\"./auth/users\");\n    var Permissions = require(\"./auth/permissions\");\n    if (!settings.disableEditor) {\n        Users.default().then(function(anonymousUser) {\n            var webSocketKeepAliveTime = settings.webSocketKeepAliveTime || 15000;\n            var path = settings.httpAdminRoot || \"/\";\n            path = (path.slice(0,1) != \"/\" ? \"/\":\"\") + path + (path.slice(-1) == \"/\" ? \"\":\"/\") + \"comms\";\n            wsServer = new ws.Server({\n                server:server,\n                path:path,\n                // Disable the deflate option due to this issue\n                //  https://github.com/websockets/ws/pull/632\n                // that is fixed in the 1.x release of the ws module\n                // that we cannot currently pickup as it drops node 0.10 support\n                perMessageDeflate: false\n            });\n\n            wsServer.on('connection',function(ws) {\n                log.audit({event: \"comms.open\"});\n                var pendingAuth = (settings.adminAuth != null);\n                if (!pendingAuth) {\n                    activeConnections.push(ws);\n                } else {\n                    pendingConnections.push(ws);\n                }\n                ws.on('close',function() {\n                    log.audit({event: \"comms.close\",user:ws.user});\n                    removeActiveConnection(ws);\n                    removePendingConnection(ws);\n                });\n                ws.on('message', function(data,flags) {\n                    var msg = null;\n                    try {\n                        msg = JSON.parse(data);\n                    } catch(err) {\n                        log.trace(\"comms received malformed message : \"+err.toString());\n                        return;\n                    }\n                    if (!pendingAuth) {\n                        if (msg.subscribe) {\n                            handleRemoteSubscription(ws,msg.subscribe);\n                        }\n                    } else {\n                        var completeConnection = function(userScope,sendAck) {\n                            try {\n                                if (!userScope || !Permissions.hasPermission(userScope,\"status.read\")) {\n                                    ws.send(JSON.stringify({auth:\"fail\"}));\n                                    ws.close();\n                                } else {\n                                    pendingAuth = false;\n                                    removePendingConnection(ws);\n                                    activeConnections.push(ws);\n                                    if (sendAck) {\n                                        ws.send(JSON.stringify({auth:\"ok\"}));\n                                    }\n                                }\n                            } catch(err) {\n                                // Just in case the socket closes before we attempt\n                                // to send anything.\n                            }\n                        }\n                        if (msg.auth) {\n                            Tokens.get(msg.auth).then(function(client) {\n                                if (client) {\n                                    Users.get(client.user).then(function(user) {\n                                        if (user) {\n                                            ws.user = user;\n                                            log.audit({event: \"comms.auth\",user:ws.user});\n                                            completeConnection(client.scope,true);\n                                        } else {\n                                            log.audit({event: \"comms.auth.fail\"});\n                                            completeConnection(null,false);\n                                        }\n                                    });\n                                } else {\n                                    log.audit({event: \"comms.auth.fail\"});\n                                    completeConnection(null,false);\n                                }\n                            });\n                        } else {\n                            if (anonymousUser) {\n                                log.audit({event: \"comms.auth\",user:anonymousUser});\n                                completeConnection(anonymousUser.permissions,false);\n                            } else {\n                                log.audit({event: \"comms.auth.fail\"});\n                                completeConnection(null,false);\n                            }\n                            //TODO: duplicated code - pull non-auth message handling out\n                            if (msg.subscribe) {\n                                handleRemoteSubscription(ws,msg.subscribe);\n                            }\n                        }\n                    }\n                });\n                ws.on('error', function(err) {\n                    log.warn(log._(\"comms.error\",{message:err.toString()}));\n                });\n            });\n\n            wsServer.on('error', function(err) {\n                log.warn(log._(\"comms.error-server\",{message:err.toString()}));\n            });\n\n            lastSentTime = Date.now();\n\n            heartbeatTimer = setInterval(function() {\n                var now = Date.now();\n                if (now-lastSentTime > webSocketKeepAliveTime) {\n                    publish(\"hb\",lastSentTime);\n                }\n            }, webSocketKeepAliveTime);\n        });\n    }\n}\n\nfunction stop() {\n    if (heartbeatTimer) {\n        clearInterval(heartbeatTimer);\n        heartbeatTimer = null;\n    }\n    if (wsServer) {\n        wsServer.close();\n        wsServer = null;\n    }\n}\n\nfunction publish(topic,data,retain) {\n    if (server) {\n        if (retain) {\n            retained[topic] = data;\n        } else {\n            delete retained[topic];\n        }\n        lastSentTime = Date.now();\n        activeConnections.forEach(function(conn) {\n            publishTo(conn,topic,data);\n        });\n    }\n}\n\nfunction publishTo(ws,topic,data) {\n    var msg = JSON.stringify({topic:topic,data:data});\n    try {\n        ws.send(msg);\n    } catch(err) {\n        removeActiveConnection(ws);\n        removePendingConnection(ws);\n        log.warn(log._(\"comms.error-send\",{message:err.toString()}));\n    }\n}\n\nfunction handleRemoteSubscription(ws,topic) {\n    var re = new RegExp(\"^\"+topic.replace(/([\\[\\]\\?\\(\\)\\\\\\\\$\\^\\*\\.|])/g,\"\\\\$1\").replace(/\\+/g,\"[^/]+\").replace(/\\/#$/,\"(\\/.*)?\")+\"$\");\n    for (var t in retained) {\n        if (re.test(t)) {\n            publishTo(ws,t,retained[t]);\n        }\n    }\n}\n\nfunction removeActiveConnection(ws) {\n    for (var i=0;i<activeConnections.length;i++) {\n        if (activeConnections[i] === ws) {\n            activeConnections.splice(i,1);\n            break;\n        }\n    }\n}\nfunction removePendingConnection(ws) {\n    for (var i=0;i<pendingConnections.length;i++) {\n        if (pendingConnections[i] === ws) {\n            pendingConnections.splice(i,1);\n            break;\n        }\n    }\n}\n\nmodule.exports = {\n    init:init,\n    start:start,\n    stop:stop,\n    publish:publish\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/locales.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar fs = require('fs');\nvar path = require('path');\nvar i18n;\nvar supportedLangs = [];\n\nvar apiLocalDir = path.resolve(path.join(__dirname,\"locales\"));\n\nvar initSupportedLangs = function() {\n    fs.readdir(apiLocalDir, function(err,files) {\n        if(!err) {\n            supportedLangs = files;\n        }\n    });\n}\n\nfunction determineLangFromHeaders(acceptedLanguages){\n    var lang = i18n.defaultLang;\n    acceptedLanguages = acceptedLanguages || [];\n    for (var i=0;i<acceptedLanguages.length;i++){\n        if (supportedLangs.indexOf(acceptedLanguages[i]) !== -1){\n            lang = acceptedLanguages[i];\n            break;\n        // check the language without the country code\n        } else if (supportedLangs.indexOf(acceptedLanguages[i].split(\"-\")[0]) !== -1) {\n            lang = acceptedLanguages[i].split(\"-\")[0];\n            break;\n        }\n    }\n    return lang;\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        i18n = runtime.i18n;\n        initSupportedLangs();\n    },\n    get: function(req,res) {\n        var namespace = req.params[0];\n        namespace = namespace.replace(/\\.json$/,\"\");\n        var lang = determineLangFromHeaders(req.acceptsLanguages() || []);\n        var prevLang = i18n.i.lng();\n        i18n.i.setLng(lang, function(){\n            var catalog = i18n.catalog(namespace,lang);\n            res.json(catalog||{});\n        });\n        i18n.i.setLng(prevLang);\n    },\n    determineLangFromHeaders: determineLangFromHeaders\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/flows.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar redNodes;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        settings = runtime.settings;\n        redNodes = runtime.nodes;\n        log = runtime.log;\n    },\n    get: function(req,res) {\n        var version = req.get(\"Node-RED-API-Version\")||\"v1\";\n        if (version === \"v1\") {\n            log.audit({event: \"flows.get\",version:\"v1\"},req);\n            res.json(redNodes.getFlows().flows);\n        } else if (version === \"v2\") {\n            log.audit({event: \"flows.get\",version:\"v2\"},req);\n            res.json(redNodes.getFlows());\n        } else {\n            log.audit({event: \"flows.get\",version:version,error:\"invalid_api_version\"},req);\n            res.status(400).json({code:\"invalid_api_version\", message:\"Invalid API Version requested\"});\n        }\n    },\n    post: function(req,res) {\n        var version = req.get(\"Node-RED-API-Version\")||\"v1\";\n        var flows = req.body;\n        var deploymentType = req.get(\"Node-RED-Deployment-Type\")||\"full\";\n        log.audit({event: \"flows.set\",type:deploymentType,version:version},req);\n        if (deploymentType === 'reload') {\n            redNodes.loadFlows().then(function() {\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.flows.error-reload\",{message:err.message}));\n                log.warn(err.stack);\n                res.status(500).json({error:\"unexpected_error\", message:err.message});\n            });\n        } else {\n            var flowConfig = flows;\n            if (version === \"v2\") {\n                flowConfig = flows.flows;\n                if (flows.hasOwnProperty('rev')) {\n                    var currentVersion = redNodes.getFlows().rev;\n                    if (currentVersion !== flows.rev) {\n                        //TODO: log warning\n                        return res.status(409).json({code:\"version_mismatch\"});\n                    }\n                }\n            } else if (version !== 'v1') {\n                log.audit({event: \"flows.set\",version:version,error:\"invalid_api_version\"},req);\n                res.status(400).json({code:\"invalid_api_version\", message:\"Invalid API Version requested\"});\n            }\n            redNodes.setFlows(flowConfig,deploymentType).then(function(flowId) {\n                if (version === \"v1\") {\n                    res.status(204).end();\n                } else if (version === \"v2\") {\n                    res.json({rev:flowId});\n                } else {\n                    // TODO: invalid version\n                }\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.flows.error-save\",{message:err.message}));\n                log.warn(err.stack);\n                res.status(500).json({error:\"unexpected_error\", message:err.message});\n            });\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/flow.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar redNodes;\nvar settings;\n\nmodule.exports = {\n    init: function(runtime) {\n        settings = runtime.settings;\n        redNodes = runtime.nodes;\n        log = runtime.log;\n    },\n    get: function(req,res) {\n        var id = req.params.id;\n        var flow = redNodes.getFlow(id);\n        if (flow) {\n            log.audit({event: \"flow.get\",id:id},req);\n            res.json(flow);\n        } else {\n            log.audit({event: \"flow.get\",id:id,error:\"not_found\"},req);\n            res.status(404).end();\n        }\n    },\n    post: function(req,res) {\n        var flow = req.body;\n        redNodes.addFlow(flow).then(function(id) {\n            log.audit({event: \"flow.add\",id:id},req);\n            res.json({id:id});\n        }).otherwise(function(err) {\n            log.audit({event: \"flow.add\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n            res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n        })\n\n    },\n    put: function(req,res) {\n        var id = req.params.id;\n        var flow = req.body;\n        try {\n            redNodes.updateFlow(id,flow).then(function() {\n                log.audit({event: \"flow.update\",id:id},req);\n                res.json({id:id});\n            }).otherwise(function(err) {\n                log.audit({event: \"flow.update\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            })\n        } catch(err) {\n            if (err.code === 404) {\n                log.audit({event: \"flow.update\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                log.audit({event: \"flow.update\",error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        }\n    },\n    delete: function(req,res) {\n        var id = req.params.id;\n        try {\n            redNodes.removeFlow(id).then(function() {\n                log.audit({event: \"flow.remove\",id:id},req);\n                res.status(204).end();\n            })\n        } catch(err) {\n            if (err.code === 404) {\n                log.audit({event: \"flow.remove\",id:id,error:\"not_found\"},req);\n                res.status(404).end();\n            } else {\n                log.audit({event: \"flow.remove\",id:id,error:err.code||\"unexpected_error\",message:err.toString()},req);\n                res.status(400).json({error:err.code||\"unexpected_error\", message:err.toString()});\n            }\n        }\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/library.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar fs = require('fs');\nvar fspath = require('path');\nvar when = require('when');\n\nvar redApp = null;\nvar storage;\nvar log;\nvar needsPermission = require(\"./auth\").needsPermission;\n\nfunction createLibrary(type) {\n    if (redApp) {\n        redApp.get(new RegExp(\"/library/\"+type+\"($|\\/(.*))\"),needsPermission(\"library.read\"),function(req,res) {\n            var path = req.params[1]||\"\";\n            storage.getLibraryEntry(type,path).then(function(result) {\n                log.audit({event: \"library.get\",type:type},req);\n                if (typeof result === \"string\") {\n                    res.writeHead(200, {'Content-Type': 'text/plain'});\n                    res.write(result);\n                    res.end();\n                } else {\n                    res.json(result);\n                }\n            }).otherwise(function(err) {\n                if (err) {\n                    log.warn(log._(\"api.library.error-load-entry\",{path:path,message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                        log.audit({event: \"library.get\",type:type,error:\"forbidden\"},req);\n                        res.status(403).end();\n                        return;\n                    }\n                }\n                log.audit({event: \"library.get\",type:type,error:\"not_found\"},req);\n                res.status(404).end();\n            });\n        });\n\n        redApp.post(new RegExp(\"/library/\"+type+\"\\/(.*)\"),needsPermission(\"library.write\"),function(req,res) {\n            var path = req.params[0];\n            var meta = req.body;\n            var text = meta.text;\n            delete meta.text;\n\n            storage.saveLibraryEntry(type,path,meta,text).then(function() {\n                log.audit({event: \"library.set\",type:type},req);\n                res.status(204).end();\n            }).otherwise(function(err) {\n                log.warn(log._(\"api.library.error-save-entry\",{path:path,message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                    log.audit({event: \"library.set\",type:type,error:\"forbidden\"},req);\n                    res.status(403).end();\n                    return;\n                }\n                log.audit({event: \"library.set\",type:type,error:\"unexpected_error\",message:err.toString()},req);\n                res.status(500).json({error:\"unexpected_error\", message:err.toString()});\n            });\n        });\n    }\n}\n\nvar exampleRoots = {};\nvar exampleFlows = {d:{}};\nvar exampleCount = 0;\n\nfunction getFlowsFromPath(path) {\n    return when.promise(function(resolve,reject) {\n        var result = {};\n        fs.readdir(path,function(err,files) {\n            var promises = [];\n            var validFiles = [];\n            files.forEach(function(file) {\n                var fullPath = fspath.join(path,file);\n                var stats = fs.lstatSync(fullPath);\n                if (stats.isDirectory()) {\n                    validFiles.push(file);\n                    promises.push(getFlowsFromPath(fullPath));\n                } else if (/\\.json$/.test(file)){\n                    validFiles.push(file);\n                    exampleCount++;\n                    promises.push(when.resolve(file.split(\".\")[0]))\n                }\n            })\n            var i=0;\n            when.all(promises).then(function(results) {\n                results.forEach(function(r) {\n                    if (typeof r === 'string') {\n                        result.f = result.f||[];\n                        result.f.push(r);\n                    } else {\n                        result.d = result.d||{};\n                        result.d[validFiles[i]] = r;\n                    }\n                    i++;\n                })\n\n                resolve(result);\n            })\n        });\n    })\n}\n\nfunction addNodeExamplesDir(module) {\n    exampleRoots[module.name] = module.path;\n    getFlowsFromPath(module.path).then(function(result) {\n        exampleFlows.d[module.name] = result;\n    });\n}\nfunction removeNodeExamplesDir(module) {\n    delete exampleRoots[module];\n    delete exampleFlows.d[module];\n}\n\nmodule.exports = {\n    init: function(app,runtime) {\n        redApp = app;\n        log = runtime.log;\n        storage = runtime.storage;\n        // TODO: this allows init to be called multiple times without\n        //       registering multiple instances of the listener.\n        //       It isn't.... ideal.\n        runtime.events.removeListener(\"node-examples-dir\",addNodeExamplesDir);\n        runtime.events.on(\"node-examples-dir\",addNodeExamplesDir);\n        runtime.events.removeListener(\"node-module-uninstalled\",removeNodeExamplesDir);\n        runtime.events.on(\"node-module-uninstalled\",removeNodeExamplesDir);\n\n    },\n    register: createLibrary,\n\n    getAll: function(req,res) {\n        storage.getAllFlows().then(function(flows) {\n            log.audit({event: \"library.get.all\",type:\"flow\"},req);\n            if (exampleCount > 0) {\n                flows.d = flows.d||{};\n                flows.d._examples_ = exampleFlows;\n            }\n            res.json(flows);\n        });\n    },\n    get: function(req,res) {\n        if (req.params[0].indexOf(\"_examples_/\") === 0) {\n            var m = /^_examples_\\/([^\\/]+)\\/(.*)$/.exec(req.params[0]);\n            if (m) {\n                var module = m[1];\n                var path = m[2]+\".json\";\n                if (exampleRoots[module]) {\n                    var fullPath = fspath.join(exampleRoots[module],path);\n                    try {\n                        fs.statSync(fullPath);\n                        log.audit({event: \"library.get\",type:\"flow\",path:req.params[0]},req);\n                        return res.sendFile(fullPath,{\n                            headers:{\n                                'Content-Type': 'application/json'\n                            }\n                        })\n                    } catch(err) {\n                        console.log(err);\n                    }\n                }\n            }\n            // IF we get here, we didn't find the file\n            log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"not_found\"},req);\n            return res.status(404).end();\n        } else {\n            storage.getFlow(req.params[0]).then(function(data) {\n                // data is already a JSON string\n                log.audit({event: \"library.get\",type:\"flow\",path:req.params[0]},req);\n                res.set('Content-Type', 'application/json');\n                res.send(data);\n            }).otherwise(function(err) {\n                if (err) {\n                    log.warn(log._(\"api.library.error-load-flow\",{path:req.params[0],message:err.toString()}));\n                    if (err.code === 'forbidden') {\n                        log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n                        res.status(403).end();\n                        return;\n                    }\n                }\n                log.audit({event: \"library.get\",type:\"flow\",path:req.params[0],error:\"not_found\"},req);\n                res.status(404).end();\n            });\n        }\n    },\n    post: function(req,res) {\n        // if (req.params[0].indexOf(\"_examples_/\") === 0) {\n        //     log.warn(log._(\"api.library.error-save-flow\",{path:req.params[0],message:\"forbidden\"}));\n        //     log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n        //     return res.status(403).send({error:\"unexpected_error\", message:\"forbidden\"});\n        // }\n        var flow = JSON.stringify(req.body);\n        storage.saveFlow(req.params[0],flow).then(function() {\n            log.audit({event: \"library.set\",type:\"flow\",path:req.params[0]},req);\n            res.status(204).end();\n        }).otherwise(function(err) {\n            log.warn(log._(\"api.library.error-save-flow\",{path:req.params[0],message:err.toString()}));\n            if (err.code === 'forbidden') {\n                log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"forbidden\"},req);\n                res.status(403).end();\n                return;\n            }\n            log.audit({event: \"library.set\",type:\"flow\",path:req.params[0],error:\"unexpected_error\",message:err.toString()},req);\n            res.status(500).send({error:\"unexpected_error\", message:err.toString()});\n        });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/index.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar passport = require(\"passport\");\nvar oauth2orize = require(\"oauth2orize\");\n\nvar strategies = require(\"./strategies\");\nvar Tokens = require(\"./tokens\");\nvar Users = require(\"./users\");\nvar permissions = require(\"./permissions\");\n\nvar theme = require(\"../theme\");\n\nvar settings = null;\nvar log = null\n\n\npassport.use(strategies.bearerStrategy.BearerStrategy);\npassport.use(strategies.clientPasswordStrategy.ClientPasswordStrategy);\npassport.use(strategies.anonymousStrategy);\n\nvar server = oauth2orize.createServer();\n\nserver.exchange(oauth2orize.exchange.password(strategies.passwordTokenExchange));\n\nfunction init(runtime) {\n    settings = runtime.settings;\n    log = runtime.log;\n    if (settings.adminAuth) {\n        Users.init(settings.adminAuth);\n        Tokens.init(settings.adminAuth,runtime.storage);\n        strategies.init(runtime);\n    }\n}\n\nfunction needsPermission(permission) {\n    return function(req,res,next) {\n        if (settings && settings.adminAuth) {\n            return passport.authenticate(['bearer','anon'],{ session: false })(req,res,function() {\n                if (!req.user) {\n                    return next();\n                }\n                if (permissions.hasPermission(req.authInfo.scope,permission)) {\n                    return next();\n                }\n                log.audit({event: \"permission.fail\", permissions: permission},req);\n                return res.status(401).end();\n            });\n        } else {\n            next();\n        }\n    }\n}\n\nfunction ensureClientSecret(req,res,next) {\n    if (!req.body.client_secret) {\n        req.body.client_secret = 'not_available';\n    }\n    next();\n}\nfunction authenticateClient(req,res,next) {\n    return passport.authenticate(['oauth2-client-password'], {session: false})(req,res,next);\n}\nfunction getToken(req,res,next) {\n    return server.token()(req,res,next);\n}\n\nfunction login(req,res) {\n    var response = {};\n    if (settings.adminAuth) {\n        response = {\n            \"type\":\"credentials\",\n            \"prompts\":[{id:\"username\",type:\"text\",label:\"Username\"},{id:\"password\",type:\"password\",label:\"Password\"}]\n        }\n        if (theme.context().login && theme.context().login.image) {\n            response.image = theme.context().login.image;\n        }\n    }\n    res.json(response);\n}\n\nfunction revoke(req,res) {\n    var token = req.body.token;\n    // TODO: audit log\n    Tokens.revoke(token).then(function() {\n        log.audit({event: \"auth.login.revoke\"},req);\n        res.status(200).end();\n    });\n}\n\nmodule.exports = {\n    init: init,\n    needsPermission: needsPermission,\n    ensureClientSecret: ensureClientSecret,\n    authenticateClient: authenticateClient,\n    getToken: getToken,\n    errorHandler: function(err,req,res,next) {\n        //TODO: audit log statment\n        //console.log(err.stack);\n        //log.log({level:\"audit\",type:\"auth\",msg:err.toString()});\n        return server.errorHandler()(err,req,res,next);\n    },\n    login: login,\n    revoke: revoke\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/strategies.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar BearerStrategy = require('passport-http-bearer').Strategy;\nvar ClientPasswordStrategy = require('passport-oauth2-client-password').Strategy;\n\nvar passport = require(\"passport\");\nvar crypto = require(\"crypto\");\nvar util = require(\"util\");\n\nvar Tokens = require(\"./tokens\");\nvar Users = require(\"./users\");\nvar Clients = require(\"./clients\");\nvar permissions = require(\"./permissions\");\n\nvar log;\n\nvar bearerStrategy = function (accessToken, done) {\n    // is this a valid token?\n    Tokens.get(accessToken).then(function(token) {\n        if (token) {\n            Users.get(token.user).then(function(user) {\n                if (user) {\n                    done(null,user,{scope:token.scope});\n                } else {\n                    log.audit({event: \"auth.invalid-token\"});\n                    done(null,false);\n                }\n            });\n        } else {\n            log.audit({event: \"auth.invalid-token\"});\n            done(null,false);\n        }\n    });\n}\nbearerStrategy.BearerStrategy = new BearerStrategy(bearerStrategy);\n\nvar clientPasswordStrategy = function(clientId, clientSecret, done) {\n    Clients.get(clientId).then(function(client) {\n        if (client && client.secret == clientSecret) {\n            done(null,client);\n        } else {\n            log.audit({event: \"auth.invalid-client\",client:clientId});\n            done(null,false);\n        }\n    });\n}\nclientPasswordStrategy.ClientPasswordStrategy = new ClientPasswordStrategy(clientPasswordStrategy);\n\nvar loginAttempts = [];\nvar loginSignInWindow = 600000; // 10 minutes\n\n\nvar passwordTokenExchange = function(client, username, password, scope, done) {\n    var now = Date.now();\n    loginAttempts = loginAttempts.filter(function(logEntry) {\n        return logEntry.time + loginSignInWindow > now;\n    });\n    loginAttempts.push({time:now, user:username});\n    var attemptCount = 0;\n    loginAttempts.forEach(function(logEntry) {\n        /* istanbul ignore else */\n        if (logEntry.user == username) {\n            attemptCount++;\n        }\n    });\n    if (attemptCount > 5) {\n        log.audit({event: \"auth.login.fail.too-many-attempts\",username:username,client:client.id});\n        done(new Error(\"Too many login attempts. Wait 10 minutes and try again\"),false);\n        return;\n    }\n\n    Users.authenticate(username,password).then(function(user) {\n        if (user) {\n            if (scope === \"\") {\n                scope = user.permissions;\n            }\n            if (permissions.hasPermission(user.permissions,scope)) {\n                loginAttempts = loginAttempts.filter(function(logEntry) {\n                    return logEntry.user !== username;\n                });\n                Tokens.create(username,client.id,scope).then(function(tokens) {\n                    log.audit({event: \"auth.login\",username:username,client:client.id,scope:scope});\n                    done(null,tokens.accessToken,null,{expires_in:tokens.expires_in});\n                });\n            } else {\n                log.audit({event: \"auth.login.fail.permissions\",username:username,client:client.id,scope:scope});\n                done(null,false);\n            }\n        } else {\n            log.audit({event: \"auth.login.fail.credentials\",username:username,client:client.id,scope:scope});\n            done(null,false);\n        }\n    });\n}\n\nfunction AnonymousStrategy() {\n  passport.Strategy.call(this);\n  this.name = 'anon';\n}\nutil.inherits(AnonymousStrategy, passport.Strategy);\nAnonymousStrategy.prototype.authenticate = function(req) {\n    var self = this;\n    Users.default().then(function(anon) {\n        if (anon) {\n            self.success(anon,{scope:anon.permissions});\n        } else {\n            self.fail(401);\n        }\n    });\n}\n\nmodule.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n    },\n    bearerStrategy: bearerStrategy,\n    clientPasswordStrategy: clientPasswordStrategy,\n    passwordTokenExchange: passwordTokenExchange,\n    anonymousStrategy: new AnonymousStrategy()\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/tokens.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar when = require(\"when\");\n\nfunction generateToken(length) {\n    var c = \"ABCDEFGHIJKLMNOPQRSTUZWXYZabcdefghijklmnopqrstuvwxyz1234567890\";\n    var token = [];\n    for (var i=0;i<length;i++) {\n        token.push(c[Math.floor(Math.random()*c.length)]);\n    }\n    return token.join(\"\");\n}\n\n\nvar storage;\n\nvar sessionExpiryTime\n\nvar sessions = {};\n\nvar loadedSessions = null;\n\nfunction expireSessions() {\n    var now = Date.now();\n    var modified = false;\n    for (var t in sessions) {\n        if (sessions.hasOwnProperty(t)) {\n            var session = sessions[t];\n            if (!session.hasOwnProperty(\"expires\") || session.expires < now) {\n                delete sessions[t];\n                modified = true;\n            }\n        }\n    }\n    if (modified) {\n        return storage.saveSessions(sessions);\n    } else {\n        return when.resolve();\n    }\n}\nfunction loadSessions() {\n    if (loadedSessions === null) {\n        loadedSessions = storage.getSessions().then(function(_sessions) {\n             sessions = _sessions||{};\n             return expireSessions();\n        });\n    }\n    return loadedSessions;\n}\n\nmodule.exports = {\n    init: function(adminAuthSettings, _storage) {\n        storage = _storage;\n        sessionExpiryTime = adminAuthSettings.sessionExpiryTime || 604800; // 1 week in seconds\n        // At this point, storage will not have been initialised, so defer loading\n        // the sessions until there's a request for them.\n        loadedSessions = null;\n        return when.resolve();\n    },\n    get: function(token) {\n        return loadSessions().then(function() {\n            if (sessions[token]) {\n                if (sessions[token].expires < Date.now()) {\n                    return expireSessions().then(function() { return null });\n                }\n            }\n            return when.resolve(sessions[token]);\n        });\n    },\n    create: function(user,client,scope) {\n        return loadSessions().then(function() {\n            var accessToken = generateToken(128);\n\n            var accessTokenExpiresAt = Date.now() + (sessionExpiryTime*1000);\n\n            var session = {\n                user:user,\n                client:client,\n                scope:scope,\n                accessToken: accessToken,\n                expires: accessTokenExpiresAt\n            };\n            sessions[accessToken] = session;\n            return storage.saveSessions(sessions).then(function() {\n                return {\n                    accessToken: accessToken,\n                    expires_in: sessionExpiryTime\n                }\n            });\n        });\n    },\n    revoke: function(token) {\n        return loadSessions().then(function() {\n            delete sessions[token];\n            return storage.saveSessions(sessions);\n        });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/users.js":"/**\n* Copyright JS Foundation and other contributors, http://js.foundation\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n**/\n\nvar when = require(\"when\");\nvar util = require(\"util\");\nvar bcrypt;\ntry { bcrypt = require('bcrypt'); }\ncatch(e) { bcrypt = require('bcryptjs'); }\nvar users = {};\nvar passwords = {};\nvar defaultUser = null;\n\nfunction authenticate(username,password) {\n    var user = users[username];\n    if (user) {\n        return when.promise(function(resolve,reject) {\n            bcrypt.compare(password, passwords[username], function(err, res) {\n                resolve(res?user:null);\n            });\n        });\n    }\n    return when.resolve(null);\n}\nfunction get(username) {\n    return when.resolve(users[username]);\n}\nfunction getDefaultUser() {\n    return when.resolve(null);\n}\n\nvar api = {\n    get: get,\n    authenticate: authenticate,\n    default: getDefaultUser\n}\n\nfunction init(config) {\n    users = {};\n    passwords = {};\n    defaultUser = null;\n    if (config.type == \"credentials\") {\n        if (config.users) {\n            if (typeof config.users === \"function\") {\n                api.get = config.users;\n            } else {\n                var us = config.users;\n                /* istanbul ignore else */\n                if (!util.isArray(us)) {\n                    us = [us];\n                }\n                for (var i=0;i<us.length;i++) {\n                    var u = us[i];\n                    users[u.username] = {\n                        \"username\":u.username,\n                        \"permissions\":u.permissions\n                    };\n                    passwords[u.username] = u.password;\n                }\n            }\n        }\n        if (config.authenticate && typeof config.authenticate === \"function\") {\n            api.authenticate = config.authenticate;\n        } else {\n            api.authenticate = authenticate;\n        }\n    }\n    if (config.default) {\n        if (typeof config.default === \"function\") {\n            api.default = config.default;\n        } else {\n            api.default = function() {\n                return when.resolve({\n                    \"anonymous\": true,\n                    \"permissions\":config.default.permissions\n                });\n            }\n        }\n    } else {\n        api.default = getDefaultUser;\n    }\n}\n\nmodule.exports = {\n    init: init,\n    get: function(username) { return api.get(username) },\n    authenticate: function(username,password) { return api.authenticate(username,password) },\n    default: function() { return api.default(); }\n};\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/clients.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n \nvar when = require(\"when\");\n\nvar clients = [\n    {id:\"node-red-editor\",secret:\"not_available\"},\n    {id:\"node-red-admin\",secret:\"not_available\"}\n];\n\nmodule.exports = {\n    get: function(id) {\n        for (var i=0;i<clients.length;i++) {\n            if (clients[i].id == id) {\n                return when.resolve(clients[i]);\n            }\n        }\n        return when.resolve(null);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/auth/permissions.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar util = require('util');\n\nvar readRE = /^((.+)\\.)?read$/\nvar writeRE = /^((.+)\\.)?write$/\n\nfunction hasPermission(userScope,permission) {\n    if (permission === \"\") {\n        return true;\n    }\n    var i;\n\n    if (util.isArray(permission)) {\n        // Multiple permissions requested - check each one\n        for (i=0;i<permission.length;i++) {\n            if (!hasPermission(userScope,permission[i])) {\n                return false;\n            }\n        }\n        // All permissions check out\n        return true;\n    }\n\n    if (util.isArray(userScope)) {\n        if (userScope.length === 0) {\n            return false;\n        }\n        for (i=0;i<userScope.length;i++) {\n            if (hasPermission(userScope[i],permission)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    if (userScope === \"*\" || userScope === permission) {\n        return true;\n    }\n\n    if (userScope === \"read\" || userScope === \"*.read\") {\n        return readRE.test(permission);\n    } else if (userScope === \"write\" || userScope === \"*.write\") {\n        return writeRE.test(permission);\n    }\n    return false;\n}\n\nmodule.exports = {\n    hasPermission: hasPermission,\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/info.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\nvar theme = require(\"./theme\");\nvar util = require('util');\nvar runtime;\nvar settings;\n\nmodule.exports = {\n    init: function(_runtime) {\n        runtime = _runtime;\n        settings = runtime.settings;\n    },\n    settings: function(req,res) {\n        var safeSettings = {\n            httpNodeRoot: settings.httpNodeRoot||\"/\",\n            version: settings.version,\n            user: req.user\n        }\n\n        var themeSettings = theme.settings();\n        if (themeSettings) {\n            safeSettings.editorTheme = themeSettings;\n        }\n\n        if (util.isArray(settings.paletteCategories)) {\n            safeSettings.paletteCategories = settings.paletteCategories;\n        }\n\n        if (settings.flowFilePretty) {\n            safeSettings.flowFilePretty = settings.flowFilePretty;\n        }\n\n        if (!runtime.nodes.paletteEditorEnabled()) {\n            safeSettings.editorTheme = safeSettings.editorTheme || {};\n            safeSettings.editorTheme.palette = safeSettings.editorTheme.palette || {};\n            safeSettings.editorTheme.palette.editable = false;\n        }\n\n        res.json(safeSettings);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-node-red/node-red/red/api/credentials.js":"/**\n * Copyright JS Foundation and other contributors, http://js.foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n **/\n\nvar log;\nvar api;\n\nmodule.exports = {\n    init: function(runtime) {\n        log = runtime.log;\n        api = runtime.nodes;\n    },\n    get: function (req, res) {\n        // TODO: It should verify the given node id is of the type specified -\n        //       but that would add a dependency from this module to the\n        //       registry module that knows about node types.\n        var nodeType = req.params.type;\n        var nodeID = req.params.id;\n        log.audit({event: \"credentials.get\",type:nodeType,id:nodeID},req);\n        var credentials = api.getCredentials(nodeID);\n        if (!credentials) {\n            res.json({});\n            return;\n        }\n        var definition = api.getCredentialDefinition(nodeType);\n\n        var sendCredentials = {};\n        for (var cred in definition) {\n            if (definition.hasOwnProperty(cred)) {\n                if (definition[cred].type == \"password\") {\n                    var key = 'has_' + cred;\n                    sendCredentials[key] = credentials[cred] != null && credentials[cred] !== '';\n                    continue;\n                }\n                sendCredentials[cred] = credentials[cred] || '';\n            }\n        }\n        res.json(sendCredentials);\n    }\n}\n"}